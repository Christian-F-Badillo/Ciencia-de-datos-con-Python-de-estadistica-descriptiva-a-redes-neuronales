{
  "hash": "844bcd86c4151a645b31ce6f48b84611",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: Estructuras de Datos\nauthor: Christian Badillo\nformat: html\ndate: today\norder: 4\nipynb-shell-interactivity: all\nfilters:\n  - pyodide\n  - fontawesome\n  - iconify\n---\n\nLos datos son la base de la ciencia, son la materia prima con la que trabajamos. Dada su importancia es necesario contar con herramientas que nos permitan manipularlos de manera eficiente. En este sentido, las ***estructuras de datos*** son una herramienta fundamental en la programación. Se definen como formas de organizar y almacenar datos en la memoria de un computador, de tal manera que se puedan acceder y modificar de manera eficiente.\n\nEn esta lección veremos algunas de las estructuras de datos más comunes en Python, como las listas, tuplas, conjuntos, diccionarios, arreglos de NumPy y `DataFrames` de Pandas, así como las propiedades y métodos que las caracterizan.\n\n# Listas\n\nLas listas son una de las estructuras de datos más comunes en Python. Se definen como una colección ordenada de elementos, que pueden ser de cualquier tipo. Para definir una lista se utilizan corchetes `[]` y los elementos se separan por comas `,`. \n\n```python\nlista = [1, 2, 3, 4, 5]\n```\nLas listas se suelen utilizar para almacenar colecciones de elementos relacionados, como los números de una serie, los nombres de los estudiantes de una clase, las coordenadas de un punto, etc. En general usamos listas cuando necesitamos almacenar una colección de elementos que pueden ser modificados durante la ejecución del programa.\n\nLas listas son ***mutables***, lo que significa que se pueden modificar después de haber sido creadas. Por ejemplo, se pueden agregar elementos a una lista con el método `append()`. Los **métodos** son funciones que se pueden aplicar a un objeto, en este caso a una lista y se sigue la sintaxis `objeto.metodo()`. Nuestro objeto es la lista y el método es `append()`.\n\nIniciemos una lista vacía y agreguemos elementos a ella.\n\n::: {#fb0a0d23 .cell execution_count=2}\n``` {.python .cell-code}\nlista = []\nlista.append(1)\nlista.append(2)\nlista.append(3)\n\nprint(lista)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1, 2, 3]\n```\n:::\n:::\n\n\nOtro método útil es `extend()`, que permite agregar varios elementos a la vez.\n\n::: {#f3d8a1cd .cell execution_count=3}\n``` {.python .cell-code}\nlista.extend([4, 5, 6])\nprint(lista)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1, 2, 3, 4, 5, 6]\n```\n:::\n:::\n\n\nLas listas pueden contener elementos de diferentes tipos, incluso otras listas.\n\n::: {#0c5a273c .cell execution_count=4}\n``` {.python .cell-code}\nlista.append([7, 8, 9])\nprint(lista)\nlista.append('hola')\nprint(lista)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1, 2, 3, 4, 5, 6, [7, 8, 9]]\n[1, 2, 3, 4, 5, 6, [7, 8, 9], 'hola']\n```\n:::\n:::\n\n\n## Indexación\n\nPara acceder a elementos de una lista se utiliza la indexación. Los índices en Python comienzan en 0, por lo que el primer elemento de una lista tiene índice 0, el segundo índice 1 y así sucesivamente. Para acceder a un elemento de una lista se utiliza la sintaxis `nombredelista[indice]`.\n\n::: {#216c7aeb .cell execution_count=5}\n``` {.python .cell-code}\nprint(lista[0])\nprint(lista[1])\nprint(lista[2])\n\n# Acceder al último elemento\nprint(lista[-1])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1\n2\n3\nhola\n```\n:::\n:::\n\n\n## Slicing\n\nEl *slicing* es una técnica que permite acceder a subconjuntos de elementos de una lista. Se utiliza la sintaxis `nombredelista[inicio:fin]`, donde `inicio` es el índice del primer elemento que se quiere incluir y `fin` es el índice del primer elemento que no se quiere incluir.\n\n::: {#1ea2ac6a .cell execution_count=6}\n``` {.python .cell-code}\nprint(lista[0:3])\nprint(lista[3:])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1, 2, 3]\n[4, 5, 6, [7, 8, 9], 'hola']\n```\n:::\n:::\n\n\nSi no se especifica el índice de inicio, se asume que es 0. Si no se especifica el índice de fin, se asume que es el último elemento de la lista.\n\n## Modificación\n\nPara modificar un elemento de una lista se utiliza la indexación y la asignación.\n\n::: {#5a95dbfd .cell execution_count=7}\n``` {.python .cell-code}\nlista[0] = 10\nprint(lista)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[10, 2, 3, 4, 5, 6, [7, 8, 9], 'hola']\n```\n:::\n:::\n\n\n## Eliminación\n\nPara eliminar un elemento de una lista se utiliza el método `remove()` y se especifica el elemento del elemento que se quiere eliminar.\n\n::: {#489c9181 .cell execution_count=8}\n``` {.python .cell-code}\nlista.remove(10)\nprint(lista)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[2, 3, 4, 5, 6, [7, 8, 9], 'hola']\n```\n:::\n:::\n\n\nSi queremos eliminar el último elemento de una lista se puede utilizar el método `pop()`.\n\n::: {#b29ae252 .cell execution_count=9}\n``` {.python .cell-code}\nlista.pop()\nprint(lista)\n```\n\n::: {.cell-output .cell-output-display execution_count=643}\n```\n'hola'\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n[2, 3, 4, 5, 6, [7, 8, 9]]\n```\n:::\n:::\n\n\n## Resumen\n\nLas listas tienen un gran número de métodos que permiten realizar operaciones sobre ellas. Un resumen de los métodos más comunes es el siguiente:\n\n- `append()`: Agrega un elemento al final de la lista.\n- `extend()`: Agrega varios elementos al final de la lista.\n- `insert()`: Agrega un elemento en una posición específica.\n- `remove()`: Elimina un elemento de la lista.\n- `pop()`: Elimina un elemento de la lista y lo devuelve.\n- `index()`: Devuelve el índice de un elemento en la lista.\n- `count()`: Cuenta el número de veces que un elemento aparece en la lista.\n- `sort()`: Ordena los elementos de la lista en orden ascendente.\n- `reverse()`: Invierte el orden de los elementos de la lista.\n- `copy()`: Crea una copia de la lista.\n\nVale la pena hacer enfásis en que no es necesario aprenderse todos los métodos de memoria, sino que es más importante entender para qué y cómo se pueden utilizar las listas, los métodos se pueden consultar en la documentación de Python, buscando en Google o preguntandole a ChatGPT.\n\n# Tuplas\n\nLas tuplas son una estructura de datos similar a las listas, pero con la diferencia de que son ***inmutables***, es decir, una vez creadas no se pueden modificar. Se definen utilizando paréntesis `()` y los elementos se separan por comas `,`.\n\n```python\ntupla = (1, 2, 3, 4, 5)\n```\n\nLas tuplas se utilizan cuando se necesita almacenar una colección de elementos que no van a cambiar durante la ejecución del programa como el número de ensayos de un experimento, las coordenadas de un punto, etc.\n\nLas tuplas soportan indexación, slicing y la función `len()` para obtener la longitud de la tupla.\n\n::: {#aef875ef .cell execution_count=10}\n``` {.python .cell-code}\ntupla = (1, 2, 3, 4, 5)\n\nprint(tupla[0])\nprint(tupla[1])\n\nprint(tupla[0:3])\n\nprint(len(tupla))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1\n2\n(1, 2, 3)\n5\n```\n:::\n:::\n\n\nLas tuplas también pueden contener elementos de diferentes tipos y otras tuplas.\n\n::: {#aab4dc42 .cell execution_count=11}\n``` {.python .cell-code}\ntupla = (1, 2, 3, (4, 5), 'hola', [6, 7, 8])\nprint(tupla)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(1, 2, 3, (4, 5), 'hola', [6, 7, 8])\n```\n:::\n:::\n\n\n# Conjuntos\n\nLos conjuntos son una estructura de datos que almacena elementos únicos, es decir, no se pueden repetir. Se definen utilizando llaves `{}` y los elementos se separan por comas `,`. \n\n```python\nconjunto = {1, 2, 3, 4, 5}\n```\n\nFuncionan igual que los conjuntos matemáticos, por lo que se pueden realizar operaciones como unión, intersección, diferencia, etc. Los conjuntos no soportan indexación ni slicing, ya que no tienen un **orden** definido.\n\n::: {#2140f564 .cell execution_count=12}\n``` {.python .cell-code}\nconjunto1 = {1, 2, 3, 4, 5}\nconjunto2 = {4, 5, 6, 7, 8}\n\n# Unión de conjuntos\nprint(conjunto1.union(conjunto2))\n\n# Intersección de conjuntos\nprint(conjunto1.intersection(conjunto2))\n\n# Diferencia de conjuntos\nprint(conjunto1.difference(conjunto2))\n\n# Diferencia simétrica de conjuntos\nprint(conjunto1.symmetric_difference(conjunto2))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n{1, 2, 3, 4, 5, 6, 7, 8}\n{4, 5}\n{1, 2, 3}\n{1, 2, 3, 6, 7, 8}\n```\n:::\n:::\n\n\nSe pueden agregar elementos a un conjunto con el método `add()` y eliminar elementos con el método `remove()`.\n\n::: {#b26809ba .cell execution_count=13}\n``` {.python .cell-code}\nconjunto = {1, 2, 3, 4, 5}\nconjunto.add(6)\nprint(conjunto)\n\nconjunto.remove(6)\nprint(conjunto)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n{1, 2, 3, 4, 5, 6}\n{1, 2, 3, 4, 5}\n```\n:::\n:::\n\n\n# Diccionarios\n\nLos diccionarios son una estructura de datos que almacena pares de clave-valor, es decir, cada elemento del diccionario tiene una clave que lo identifica y un valor asociado. Se definen utilizando llaves `{}`, los pares clave-valor se separan por comas `,` y la clave y el valor se separan por dos puntos `:`.\n\n```python\ndiccionario = {'nombre': 'Juan', 'edad': 25, 'ciudad': 'Bogotá'}\n```\n\nPara acceder a un valor de un diccionario se utiliza la clave correspondiente.\n\n::: {#b2b83dfc .cell execution_count=14}\n``` {.python .cell-code}\ndiccionario = {'nombre': 'Juan', 'edad': 25, 'ciudad': 'Bogotá'}\n\nprint(diccionario['nombre'])\nprint(diccionario['edad'])\nprint(diccionario['ciudad'])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nJuan\n25\nBogotá\n```\n:::\n:::\n\n\nEste tipo de estructura es muy útil para almacenar información estructurada, como los datos de una persona, los resultados de un experimento, etc. Los diccionarios son mutables, por lo que se pueden modificar, agregar y eliminar elementos.\n\n::: {#3a35e1ed .cell execution_count=15}\n``` {.python .cell-code}\n# Modificar un valor\ndiccionario['edad'] = 30\nprint(diccionario)\n\n# Agregar un nuevo par clave-valor\ndiccionario['telefono'] = '123456789'\nprint(diccionario)\n\n# Eliminar un par clave-valor\ndel diccionario['telefono']\nprint(diccionario)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n{'nombre': 'Juan', 'edad': 30, 'ciudad': 'Bogotá'}\n{'nombre': 'Juan', 'edad': 30, 'ciudad': 'Bogotá', 'telefono': '123456789'}\n{'nombre': 'Juan', 'edad': 30, 'ciudad': 'Bogotá'}\n```\n:::\n:::\n\n\nLos diccionarios tienen varios métodos útiles, como `keys()`, `values()` y `items()` que permiten obtener las claves, los valores y los pares clave-valor del diccionario, respectivamente.\n\n::: {#8636993a .cell execution_count=16}\n``` {.python .cell-code}\nprint(diccionario.keys())\n\nprint(diccionario.values())\n\nprint(diccionario.items())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ndict_keys(['nombre', 'edad', 'ciudad'])\ndict_values(['Juan', 30, 'Bogotá'])\ndict_items([('nombre', 'Juan'), ('edad', 30), ('ciudad', 'Bogotá')])\n```\n:::\n:::\n\n\nEs importante tener en cuenta que las claves de un diccionario deben ser únicas, es decir, no puede haber dos claves iguales en un diccionario. Si se intenta agregar una clave que ya existe, se reemplazará el valor asociado a esa clave. \n\nOtra característica importante de los diccionarios es que no tienen un orden definido, es decir, los elementos no se almacenan en el orden en que se agregaron, pero son altamente eficientes para buscar y acceder a elementos por su clave, formalmente se dice que tienen una complejidad de tiempo de acceso de $O(1)$ una caractertica común en las estructuras de datos de tipo *hash*.\n\n# Arreglos de NumPy\n\n[NumPy](https://numpy.org/) es una librería de Python que permite trabajar con arreglos multidimensionales de manera eficiente. Los arreglos de NumPy son similares a las listas de Python, pero con la diferencia de que todos los elementos de un arreglo de NumPy deben ser del mismo tipo. Se definen utilizando la función `array()` de NumPy.\n\n```python\nimport numpy as np\n\narreglo = np.array([1, 2, 3, 4, 5])\n```\n\nEste tipo de estructuras son ampliamente utilizadas en la ciencia de datos, ya que permiten realizar operaciones matemáticas sobre los datos de manera eficiente. Los arreglos de NumPy soportan indexación, slicing y operaciones matemáticas como suma, resta, multiplicación, operacioens de matrices, etc.\n\n::: {#ca3fb4af .cell execution_count=17}\n``` {.python .cell-code}\nimport numpy as np\n\narreglo = np.array([1, 2, 3, 4, 5]) # Crear un arreglo de NumPy\n\nprint(arreglo) # Imprimir el arreglo\n\nprint(arreglo[0]) # Acceder al primer elemento\n\nprint(arreglo[0:3]) # Acceder a los primeros tres elementos\n\nprint(arreglo + 10) # Sumar 10 a cada elemento\n\nprint(arreglo * 2) # Multiplicar cada elemento por 2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1 2 3 4 5]\n1\n[1 2 3]\n[11 12 13 14 15]\n[ 2  4  6  8 10]\n```\n:::\n:::\n\n\nLas operaicones matemáticas en NumPy se realizan elemento a elemento, es decir, se aplican a cada elemento del arreglo por separado. Esto es muy útil para realizar operaciones matemáticas sobre grandes cantidades de datos de manera eficiente.\n\nPodemos crear arreglos de NumPy multidimensionales, es decir, arreglos que contienen otros arreglos. Por ejemplo, un arreglo de dos dimensiones es similar a una matriz.\n\n::: {#5e77531b .cell execution_count=18}\n``` {.python .cell-code}\nimport numpy as np\n\nmatriz = np.array([[1, 2, 3], \n                    [4, 5, 6], \n                    [7, 8, 9]])\n\nprint(matriz)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1 2 3]\n [4 5 6]\n [7 8 9]]\n```\n:::\n:::\n\n\nPara acceder a elementos de una matriz se utiliza la indexación con dos índices, uno para la fila y otro para la columna.\n\n::: {#53bf1f46 .cell execution_count=19}\n``` {.python .cell-code}\nprint(matriz[0, 0]) # Primer elemento, fila 0, columna 0\nprint(matriz[1, 0]) # Elemento en la fila 1, columna 0\nprint(matriz[2, 2]) # Último elemento, fila 2, columna 2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1\n4\n9\n```\n:::\n:::\n\n\n# DataFrames de Pandas\n\n[Pandas](https://pandas.pydata.org/) es una librería de Python que permite trabajar con datos estructurados de manera eficiente. Una de las estructuras de datos más importantes de Pandas es el `DataFrame`, que es una tabla de datos bidimensional con filas y columnas. Se puede pensar en un `DataFrame` como una hoja de cálculo de Excel o una tabla de una base de datos.\n\nPara crear un `DataFrame` se utiliza la función `DataFrame()` de Pandas y se le pasa un diccionario con los datos.\n\n::: {#e5945763 .cell execution_count=20}\n``` {.python .cell-code}\nimport pandas as pd\n\ndatos = {'nombre': ['Juan', 'María', 'Pedro', 'Ana'],\n         'edad': [25, 30, 35, 40],\n         'ciudad': ['Bogotá', 'Medellín', 'Cali', 'Barranquilla']}\n\ndf = pd.DataFrame(datos)\n\nprint(df)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  nombre  edad        ciudad\n0   Juan    25        Bogotá\n1  María    30      Medellín\n2  Pedro    35          Cali\n3    Ana    40  Barranquilla\n```\n:::\n:::\n\n\nPandas incluye una serie de funciones y métodos para trabajar con `DataFrames`, como `head()`, `tail()`, `info()`, `describe()`, etc. Exploraremos en profundidad estas funciones en una lección posterior.\n\n## Slicing en DataFrames\n\nPor ahora veamos cómo acceder a elementos de un `DataFrame`. Podemos acceder a las primeras y últimas filas de un `DataFrame` utilizando los métodos `head()` y `tail()`, respectivamente\n\n::: {#a302c887 .cell execution_count=21}\n``` {.python .cell-code}\n# Cargo un conjunto de datos de ejemplo\ndf = pd.read_csv('https://raw.githubusercontent.com/mwaskom/seaborn-data/master/iris.csv') \n\ndf.head() # Imprimir las primeras filas del DataFrame\n\ndf.tail() # Imprimir las últimas filas del DataFrame\n```\n\n::: {.cell-output .cell-output-display execution_count=655}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>sepal_length</th>\n      <th>sepal_width</th>\n      <th>petal_length</th>\n      <th>petal_width</th>\n      <th>species</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>5.1</td>\n      <td>3.5</td>\n      <td>1.4</td>\n      <td>0.2</td>\n      <td>setosa</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>4.9</td>\n      <td>3.0</td>\n      <td>1.4</td>\n      <td>0.2</td>\n      <td>setosa</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>4.7</td>\n      <td>3.2</td>\n      <td>1.3</td>\n      <td>0.2</td>\n      <td>setosa</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>4.6</td>\n      <td>3.1</td>\n      <td>1.5</td>\n      <td>0.2</td>\n      <td>setosa</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>5.0</td>\n      <td>3.6</td>\n      <td>1.4</td>\n      <td>0.2</td>\n      <td>setosa</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=655}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>sepal_length</th>\n      <th>sepal_width</th>\n      <th>petal_length</th>\n      <th>petal_width</th>\n      <th>species</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>145</th>\n      <td>6.7</td>\n      <td>3.0</td>\n      <td>5.2</td>\n      <td>2.3</td>\n      <td>virginica</td>\n    </tr>\n    <tr>\n      <th>146</th>\n      <td>6.3</td>\n      <td>2.5</td>\n      <td>5.0</td>\n      <td>1.9</td>\n      <td>virginica</td>\n    </tr>\n    <tr>\n      <th>147</th>\n      <td>6.5</td>\n      <td>3.0</td>\n      <td>5.2</td>\n      <td>2.0</td>\n      <td>virginica</td>\n    </tr>\n    <tr>\n      <th>148</th>\n      <td>6.2</td>\n      <td>3.4</td>\n      <td>5.4</td>\n      <td>2.3</td>\n      <td>virginica</td>\n    </tr>\n    <tr>\n      <th>149</th>\n      <td>5.9</td>\n      <td>3.0</td>\n      <td>5.1</td>\n      <td>1.8</td>\n      <td>virginica</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nPodemos acceder a las columnas de un `DataFrame` utilizando la indexación con corchetes `[]` y el nombre de la columna entre comillas simples o dobles.\n\n::: {#6cfb372d .cell execution_count=22}\n``` {.python .cell-code}\ndf['sepal_length'] # Acceder a la columna 'sepal_length'\n```\n\n::: {.cell-output .cell-output-display execution_count=656}\n```\n0      5.1\n1      4.9\n2      4.7\n3      4.6\n4      5.0\n      ... \n145    6.7\n146    6.3\n147    6.5\n148    6.2\n149    5.9\nName: sepal_length, Length: 150, dtype: float64\n```\n:::\n:::\n\n\nOtra manera de acceder a una columna es utilizando la notación de punto `.` y el nombre de la columna, pero esta forma no es muy usada dado que complica el acceso a columnas con nombres que contienen espacios o caracteres especiales.\n\n::: {#4755c8aa .cell execution_count=23}\n``` {.python .cell-code}\ndf.sepal_length # Acceder a la columna 'sepal_length'\n```\n\n::: {.cell-output .cell-output-display execution_count=657}\n```\n0      5.1\n1      4.9\n2      4.7\n3      4.6\n4      5.0\n      ... \n145    6.7\n146    6.3\n147    6.5\n148    6.2\n149    5.9\nName: sepal_length, Length: 150, dtype: float64\n```\n:::\n:::\n\n\nTambién podemos acceder a filas y columnas utilizando la función `loc[]` y los nombres de las filas y columnas.\n\n::: {#cf4ee650 .cell execution_count=24}\n``` {.python .cell-code}\ndf.loc[:, 'sepal_length'] # Acceder al elemento en la fila 0 y columna 'sepal_length'\n# Recuerden que si usamos : estamos seleccionando todas las filas, primero se seleccionan las filas y luego las columnas\n```\n\n::: {.cell-output .cell-output-display execution_count=658}\n```\n0      5.1\n1      4.9\n2      4.7\n3      4.6\n4      5.0\n      ... \n145    6.7\n146    6.3\n147    6.5\n148    6.2\n149    5.9\nName: sepal_length, Length: 150, dtype: float64\n```\n:::\n:::\n\n\nSi queremos seleccionar varias columnas podemos pasar una lista con los nombres de las columnas.\n\n::: {#e88012c9 .cell execution_count=25}\n``` {.python .cell-code}\ncol_names = ['sepal_length', 'sepal_width']\ndf.loc[:, col_names] # Acceder a las columnas 'sepal_length' y 'sepal_width'\n```\n\n::: {.cell-output .cell-output-display execution_count=659}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>sepal_length</th>\n      <th>sepal_width</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>5.1</td>\n      <td>3.5</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>4.9</td>\n      <td>3.0</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>4.7</td>\n      <td>3.2</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>4.6</td>\n      <td>3.1</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>5.0</td>\n      <td>3.6</td>\n    </tr>\n    <tr>\n      <th>...</th>\n      <td>...</td>\n      <td>...</td>\n    </tr>\n    <tr>\n      <th>145</th>\n      <td>6.7</td>\n      <td>3.0</td>\n    </tr>\n    <tr>\n      <th>146</th>\n      <td>6.3</td>\n      <td>2.5</td>\n    </tr>\n    <tr>\n      <th>147</th>\n      <td>6.5</td>\n      <td>3.0</td>\n    </tr>\n    <tr>\n      <th>148</th>\n      <td>6.2</td>\n      <td>3.4</td>\n    </tr>\n    <tr>\n      <th>149</th>\n      <td>5.9</td>\n      <td>3.0</td>\n    </tr>\n  </tbody>\n</table>\n<p>150 rows × 2 columns</p>\n</div>\n```\n:::\n:::\n\n\nSi queremos seleccionar las filas 5, 14, 23 y las columnas 'sepal_length' y 'sepal_width' podemos hacerlo de la siguiente manera.\n\n::: {#837ce17e .cell execution_count=26}\n``` {.python .cell-code}\nfilas = [5, 14, 23]\ncol_names = ['sepal_length', 'sepal_width']\n\ndf.loc[filas, col_names] # Acceder a las filas 5, 14, 23 y las columnas 'sepal_length' y 'sepal_width'\n```\n\n::: {.cell-output .cell-output-display execution_count=660}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>sepal_length</th>\n      <th>sepal_width</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>5</th>\n      <td>5.4</td>\n      <td>3.9</td>\n    </tr>\n    <tr>\n      <th>14</th>\n      <td>5.8</td>\n      <td>4.0</td>\n    </tr>\n    <tr>\n      <th>23</th>\n      <td>5.1</td>\n      <td>3.3</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n## Modificación de DataFrames\n\nPodemos agregar una nueva columna a un `DataFrame` utilizando la notación de corchetes `[]` y el nombre de la nueva columna y asignándole una lista con los valores de la columna.\n\nCreemos una nueva columna que contenga la suma de las columnas 'sepal_length' y 'sepal_width'.\n\n::: {#fa4f2d9a .cell execution_count=27}\n``` {.python .cell-code}\ndf['sepal_sum'] = df['sepal_length'] + df['sepal_width']\ndf.head()\n```\n\n::: {.cell-output .cell-output-display execution_count=661}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>sepal_length</th>\n      <th>sepal_width</th>\n      <th>petal_length</th>\n      <th>petal_width</th>\n      <th>species</th>\n      <th>sepal_sum</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>5.1</td>\n      <td>3.5</td>\n      <td>1.4</td>\n      <td>0.2</td>\n      <td>setosa</td>\n      <td>8.6</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>4.9</td>\n      <td>3.0</td>\n      <td>1.4</td>\n      <td>0.2</td>\n      <td>setosa</td>\n      <td>7.9</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>4.7</td>\n      <td>3.2</td>\n      <td>1.3</td>\n      <td>0.2</td>\n      <td>setosa</td>\n      <td>7.9</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>4.6</td>\n      <td>3.1</td>\n      <td>1.5</td>\n      <td>0.2</td>\n      <td>setosa</td>\n      <td>7.7</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>5.0</td>\n      <td>3.6</td>\n      <td>1.4</td>\n      <td>0.2</td>\n      <td>setosa</td>\n      <td>8.6</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nPara eliminar una columna de un `DataFrame` se utiliza el método `drop()` y se pasa el nombre de la columna y el eje en el que se quiere eliminar, los ejes son 0 para filas y 1 para columnas.\n\n::: {#3a17dcde .cell execution_count=28}\n``` {.python .cell-code}\ndf.drop('sepal_sum', axis=1, inplace=True)\ndf.head()\n```\n\n::: {.cell-output .cell-output-display execution_count=662}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>sepal_length</th>\n      <th>sepal_width</th>\n      <th>petal_length</th>\n      <th>petal_width</th>\n      <th>species</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>5.1</td>\n      <td>3.5</td>\n      <td>1.4</td>\n      <td>0.2</td>\n      <td>setosa</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>4.9</td>\n      <td>3.0</td>\n      <td>1.4</td>\n      <td>0.2</td>\n      <td>setosa</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>4.7</td>\n      <td>3.2</td>\n      <td>1.3</td>\n      <td>0.2</td>\n      <td>setosa</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>4.6</td>\n      <td>3.1</td>\n      <td>1.5</td>\n      <td>0.2</td>\n      <td>setosa</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>5.0</td>\n      <td>3.6</td>\n      <td>1.4</td>\n      <td>0.2</td>\n      <td>setosa</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nEl parámetro `inplace=True` indica que la operación se realice sobre el `DataFrame` original, si se omite se crea una copia del `DataFrame` con la columna eliminada, pero si esta copia no se asigna a una variable se perderá.\n\nSi queremos modificar un valor de un `DataFrame` se localiza el elemento con `loc[]` y se asigna el nuevo valor.\n\n::: {#e01e3b83 .cell execution_count=29}\n``` {.python .cell-code}\ndf.head()\ndf.loc[0, 'sepal_length'] = 10\ndf.head()\n```\n\n::: {.cell-output .cell-output-display execution_count=663}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>sepal_length</th>\n      <th>sepal_width</th>\n      <th>petal_length</th>\n      <th>petal_width</th>\n      <th>species</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>5.1</td>\n      <td>3.5</td>\n      <td>1.4</td>\n      <td>0.2</td>\n      <td>setosa</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>4.9</td>\n      <td>3.0</td>\n      <td>1.4</td>\n      <td>0.2</td>\n      <td>setosa</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>4.7</td>\n      <td>3.2</td>\n      <td>1.3</td>\n      <td>0.2</td>\n      <td>setosa</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>4.6</td>\n      <td>3.1</td>\n      <td>1.5</td>\n      <td>0.2</td>\n      <td>setosa</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>5.0</td>\n      <td>3.6</td>\n      <td>1.4</td>\n      <td>0.2</td>\n      <td>setosa</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=663}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>sepal_length</th>\n      <th>sepal_width</th>\n      <th>petal_length</th>\n      <th>petal_width</th>\n      <th>species</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>10.0</td>\n      <td>3.5</td>\n      <td>1.4</td>\n      <td>0.2</td>\n      <td>setosa</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>4.9</td>\n      <td>3.0</td>\n      <td>1.4</td>\n      <td>0.2</td>\n      <td>setosa</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>4.7</td>\n      <td>3.2</td>\n      <td>1.3</td>\n      <td>0.2</td>\n      <td>setosa</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>4.6</td>\n      <td>3.1</td>\n      <td>1.5</td>\n      <td>0.2</td>\n      <td>setosa</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>5.0</td>\n      <td>3.6</td>\n      <td>1.4</td>\n      <td>0.2</td>\n      <td>setosa</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n# Conclusiones\n\nEn esta lección hemos visto algunas de las estructuras de datos más comunes en Python, como las listas, tuplas, conjuntos, diccionarios, arreglos de NumPy y `DataFrames` de Pandas. Cada una de estas estructuras tiene sus propias características y métodos que permiten realizar operaciones sobre los datos de manera eficiente. Cada estructura de datos es adecuada para diferentes tipos de problemas, por lo que es importante conocerlas y saber cuándo utilizar cada una. En las siguientes lecciones veremos cómo trabajar con estas estructuras de datos en la práctica y cómo realizar operaciones más avanzadas sobre los datos.\n\n",
    "supporting": [
      "data_structures_files"
    ],
    "filters": [],
    "includes": {
      "include-in-header": [
        "<script src=\"https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js\" integrity=\"sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==\" crossorigin=\"anonymous\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js\" integrity=\"sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==\" crossorigin=\"anonymous\" data-relocate-top=\"true\"></script>\n<script type=\"application/javascript\">define('jquery', [],function() {return window.jQuery;})</script>\n"
      ]
    }
  }
}