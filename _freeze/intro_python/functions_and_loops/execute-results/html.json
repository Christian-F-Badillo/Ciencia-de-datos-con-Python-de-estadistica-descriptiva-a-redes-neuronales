{
  "hash": "4baf1538cd2d289757074d8b15a60184",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: Funciones y Bucles de Control\nauthor: Christian Badillo\nformat: html\ndate: today\norder: 3\nfilters:\n  - pyodide\n  - fontawesome\n  - iconify\n---\n\n# Introducción\n\nEn esta lección, aprenderemos sobre funciones y estructuras de control en Python. Las funciones son bloques de código que se pueden reutilizar en diferentes partes de un programa, permitiendo que el código sea más modular y fácil de mantener. Las estructuras de control son bloques de código que permiten controlar el flujo de ejecución de un programa, como bucles y declaraciones condicionales. Son dos conceptos fundamentales en programación que nos permiten escribir código más eficiente y legible.\n\n# Tabulación en Python\n\nAntes de proceder, hay que explicar la tabulación en Python. A diferencia de otros lenguajes de programación que utilizan llaves `{}` para delimitar bloques de código, Python utiliza la tabulación para indicar la estructura del código. Esto significa que los bloques de código se definen por la cantidad de espacios o tabulaciones al principio de una línea. Es importante mantener la consistencia en la tabulación para que el código funcione correctamente. Por ejemplo, en una función, el cuerpo de la función debe estar tabulado con 4 espacios o una tabulación.\n\n```python\ndef funcion():\n    # Cuerpo de la función\n    print('Hola, mundo!')\n```\n\nSi no se mantiene la consistencia en la tabulación, Python generará un error de indentación. Por ejemplo, si el cuerpo de la función no está tabulado correctamente, se generará un error de sintaxis.\n\n# Funciones\n\nLas ***funciones*** son bloques de código que se pueden reutilizar en diferentes partes de un programa, permitiendo que el código sea más modular y fácil de mantener. En Python, las funciones se definen con la palabra clave `def`, seguida del nombre de la función y una lista de parámetros entre paréntesis. El cuerpo de la función se define con una tabulación (4 espacios) y puede contener cualquier número de instrucciones.\n\nPrimero elaboremos una función sencilla, la cual se llamará `saludo` y recibirá un parámetro `nombre`:\n\n::: {#18594104 .cell execution_count=2}\n``` {.python .cell-code}\ndef saludo(nombre):\n    print(f'Hola, {nombre}!')\n\nsaludo('Christian')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHola, Christian!\n```\n:::\n:::\n\n\nEn nuestra función usamos una f-string para imprimir un saludo personalizado, las ***f-strings*** son una forma de formatear cadenas de texto en Python, permitiendo la interpolación de variables dentro de una cadena. Para definir una f-string, se coloca una `f` antes de las comillas de apertura y se encierra la variable entre llaves `{}`. Es decir, le estamos diciendo a Python que reemplace `{nombre}` con el valor de la variable `nombre` que en este caso es `'Christian'`.\n\nLas funciones pueden devolver un valor usando la palabra clave `return`. Por ejemplo, la siguiente función `cuadrado` recibe un número `x` y devuelve su cuadrado:\n\n::: {#1b24761d .cell execution_count=3}\n``` {.python .cell-code}\ndef cuadrado(x):\n    return x ** 2\n\nprint(cuadrado(5))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n25\n```\n:::\n:::\n\n\nComo habrás notado en los ejemplos anteriores, hemos usado el nombre de la función seguido de paréntesis para llamarla. En el caso de la función `saludo`, hemos pasado un argumento `nombre` entre los paréntesis. En el caso de la función `cuadrado`, hemos pasado el número `5`. Estos argumentos se llaman ***parámetros*** y son los valores que la función espera recibir para realizar su tarea.\n\nHay varias formas de poner los argumentos en una función:\n\n- **Argumentos posicionales**: Los argumentos se pasan en el orden en que se definen en la función.\n- **Argumentos con nombre**: Los argumentos se pasan con el nombre del parámetro al que corresponden.\n- **Argumentos por defecto**: Los argumentos tienen un valor por defecto que se usa si no se proporciona un valor.\n- **Argumentos variables**: Los argumentos se pasan como una lista o un diccionario.\n\nEn los ejemplos hemos utilizado argumentos posicionales. A continuación, veremos cómo usar argumentos con nombre:\n\n::: {#01c50df5 .cell execution_count=4}\n``` {.python .cell-code}\ndef resta(num1, num2):\n    return num1 - num2\n\nprint(resta(num1=10, num2=5))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n5\n```\n:::\n:::\n\n\nEn este caso, hemos pasado los argumentos `num1` y `num2` con sus nombres correspondientes y les hemos asignado valores. Esto nos permite pasar los argumentos en cualquier orden, siempre y cuando especifiquemos el nombre del parámetro al que corresponden.\n\nAhora veamos cómo usar argumentos por defecto:\n\n::: {#9aade0ac .cell execution_count=5}\n``` {.python .cell-code}\ndef potencia(base, exponente=2):\n    return base ** exponente\n\nprint(potencia(2))\nprint(potencia(2, 3))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n4\n8\n```\n:::\n:::\n\n\nEn este caso, la función `potencia` tiene un argumento `exponente` con un valor por defecto de `2`. Si no se proporciona un valor para `exponente`, se usará el valor por defecto. Si se proporciona un valor, se usará ese valor en su lugar.\n\n## Funciones Lambda\n\nLas funciones lambda son funciones anónimas que se pueden definir en una sola línea. Se definen con la palabra clave `lambda`, seguida de una lista de parámetros y una expresión que se evalúa y devuelve el resultado. Por ejemplo, la siguiente función lambda calcula el cuadrado de un número:\n\n::: {#8641ab8a .cell execution_count=6}\n``` {.python .cell-code}\ncuadrado_lamda = lambda x: x ** 2\n\nprint(cuadrado_lamda(5))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n25\n```\n:::\n:::\n\n\nLas funciones lambda son útiles cuando se necesita una función simple y no es necesario definirla con una declaración `def`. \n\nAhora definamos una función lambda un poco más compleja para sumar dos números:\n\n::: {#12d81d50 .cell execution_count=7}\n``` {.python .cell-code}\nsuma_lambda = lambda x, y: x + y\n\nprint(suma_lambda(3, 4))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n7\n```\n:::\n:::\n\n\n## Paquetes y Módulos\n\nEn Python, las funciones se pueden organizar en módulos y paquetes para facilitar la reutilización y la organización del código. Un ***módulo*** es un archivo que contiene definiciones y declaraciones de Python, como funciones, clases y variables. Un ***paquete*** es una colección de módulos organizados en un directorio. Es decir, que un paquete es una carpeta que contiene archivos de python (módulos) que contienen funciones, clases y variables que puedes utilizar en tu programa.\n\nHay paqueterias y modulos muy útiles que se pueden importar en Python, por ejemplo, la paquetería `math` que contiene funciones matemáticas comunes, como `sqrt` para calcular la raíz cuadrada de un número. Para importar un módulo o una función de un módulo, se utiliza la palabra clave `import` seguida del nombre del módulo.\n\n```python\nimport math\n```\n\nUna vez que se ha importado un módulo, se puede acceder a sus funciones y variables utilizando la notación de punto. Por ejemplo, para calcular la raíz cuadrada de un número, se puede utilizar la función `sqrt` del módulo `math`.\n\n::: {#2c117a50 .cell execution_count=8}\n``` {.python .cell-code}\nimport math\nprint(math.sqrt(16))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n4.0\n```\n:::\n:::\n\n\nTambién es posible importar funciones específicas de un módulo utilizando la palabra clave `from`. Por ejemplo, para importar solo la función `sqrt` del módulo `math`, se puede hacer lo siguiente:\n\n::: {#1835e280 .cell execution_count=9}\n``` {.python .cell-code}\nfrom math import sqrt\n\nprint(sqrt(16))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n4.0\n```\n:::\n:::\n\n\nMuchas veces las paqueterias tienen nombres muy largos, por lo que se pueden importar con un alias utilizando la palabra clave `as`, las paqueterias más comunes en python tienen alias ya acordados en la comunidad, por ejemplo, `pandas` una paquetería muy utilizada para el análisis de datos se importa con el alias `pd`.\n\n```python\nimport pandas as pd\n```\n\nDe esta forma, se puede acceder a las funciones y variables de la paquetería `pandas` utilizando el alias `pd`.\n\nExiste un gran número de paqueterías y módulos disponibles en Python que proporcionan funcionalidades adicionales para tareas específicas, como el análisis de datos, la visualización, el aprendizaje automático, etc. Estas paqueterías pueden ser muy útiles para acelerar el desarrollo de aplicaciones y realizar tareas complejas de manera eficiente.\n\nNo todas las paqueterias vienen preinstaladas con Python, por lo que es necesario instalarlas con un administrador de paquetes, el más común es `pip`. Para instalar una paquetería con `pip`, se utiliza el siguiente comando en la terminal:\n\n```bash\npip install nombre_paqueteria\n```\n\nO si se usa jupyter notebook o jupyter lab, se puede instalar una paquetería con el comando `!pip install nombre_paqueteria`.\n\nCada paqueteria tiene su propia documentación, por lo que es recomendable revisarla para conocer todas las funciones y características que ofrece. \n\n## Legibilidad y Documentación de Funciones\n\nEs importante que las funciones sean fáciles de leer y entender. Para ello, es recomendable seguir las siguientes buenas prácticas:\n\n- **Nombres descriptivos**: Usa nombres descriptivos para las funciones y los parámetros.\n- **Comentarios**: Añade comentarios para explicar lo que hace cada parte de la función.\n- **Documentación**: Usa [docstrings](https://peps.python.org/pep-0257/) para documentar la función y proporcionar información sobre su propósito, los parámetros que espera y el valor que devuelve.\n- **Dividir en funciones más pequeñas**: Si una función es demasiado larga o hace demasiadas cosas, divídela en funciones más pequeñas que realicen tareas específicas.\n\nVeamos un ejemplo de una función bien documentada y legible:\n\n```{pyodide-python}\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom typing import Tuple\n\ndef sine_wave(amplitude: float = None, frequency: float = None, phase: float = None, duration: float = None, sample_rate: float = None) -> Tuple[np.ndarray, np.ndarray]:\n    \"\"\"\n    Generate a sine wave signal.\n\n    Parameters:\n    - `amplitude`: The amplitude of the sine wave.\n    - `frequency`: The frequency of the sine wave in Hz.\n    - `phase`: The phase of the sine wave in radians.\n    - `duration`: The duration of the signal in seconds.\n    - `sample_rate`: The sample rate of the signal in Hz.\n\n    Returns:\n    - `t`: An array of time values.\n    - `x`: An array of signal values.\n    \"\"\"\n    t = np.linspace(0, duration, int(sample_rate * duration), endpoint=False) # Generate time values\n    x = amplitude * np.sin(2 * np.pi * frequency * t + phase) # Generate signal values\n    return t, x\n\n# Generate a sine wave signal with amplitude 1, frequency 1 Hz, phase 0, duration 1 second, and sample rate 1000 Hz\nt, x = sine_wave(amplitude=1, frequency=1, phase=0, duration=1, sample_rate=1000) \n\n# Plot the sine wave signal\ndef plot_signal(t: np.ndarray, x: np.ndarray) -> None:\n    \"\"\"\n    Plot a signal.\n\n    Parameters:\n    - `t`: An array of time values.\n    - `x`: An array of signal values.\n    \"\"\"\n\n    plt.figure() # Create a new figure\n    plt.plot(t, x) # Plot the signal\n    plt.xlabel('Time (s)') # Set the x-axis label\n    plt.ylabel('Amplitude') # Set the y-axis label\n    plt.grid(True) # Show grid\n    plt.show() # Show the plot\n\nplot_signal(t, x)\n```\n\nEn este ejemplo, hemos definido una función `sine_wave` que genera una señal de onda sinusoidal con los parámetros de amplitud, frecuencia, fase, duración y tasa de muestreo especificados. Hemos documentado la función con un docstring que explica los parámetros que espera y el valor que devuelve. También hemos definido una función `plot_signal` que traza la señal generada. Esta función es más legible y fácil de entender gracias a los comentarios y la documentación.\n\nUn ejemplo profesional de documentación de funciones es la documentación de la paquetería `numpy`, que proporciona una descripción detallada de cada función, los parámetros que espera y el valor que devuelve. Puedes consultar la documentación de `numpy` en el siguiente enlace: [https://numpy.org/doc/stable/](https://numpy.org/doc/stable/).\n\n# Estrucutras de Control\n\nLas estructuras de control son bloques de código que permiten controlar el flujo de ejecución de un programa. En Python, las estructuras de control más comunes son los bucles `for` y `while`, y las declaraciones `if`, `elif` y `else`.\n\n## Estrucutras de Control: `if`, `elif` y `else`\n\nLa declaración `if` se utiliza para ejecutar un bloque de código si una condición es verdadera. La declaración `elif` se utiliza para comprobar múltiples condiciones si la condición anterior es falsa. La declaración `else` se utiliza para ejecutar un bloque de código si ninguna de las condiciones anteriores es verdadera.\n\n![Estructura de Control `if`](/img/fund_python/diagramaif-else1.png){width=75%}\n\nLa sintaxis de la declaración `if` en python es la siguiente:\n\n```python\nif condicion:\n    # Código a ejecutar si la condición es verdadera\nelif otra_condicion:\n    # Código a ejecutar si la condición anterior es falsa y esta condición es verdadera\nelse:\n    # Código a ejecutar si ninguna de las condiciones anteriores es verdadera\n```\n\n### Ejemplo\n\nSi tenemos varias condiciones que queremos comprobar, podemos usar la declaración `elif` para comprobarlas en orden. A continuación, se muestra un ejemplo de una declaración `if` con `elif` que comprueba si un número es positivo, negativo o cero:\n\n```{pyodide-python}\n# Ejemplo de declaración if con elif\nx = 0 # Cambia el valor de x para probar diferentes casos\nif x > 0:\n    print('El número es positivo')\nelif x < 0:\n    print('El número es negativo')\nelse:\n    print('El número es cero')\n```\n\n## Estrucutras de Control: Bucles `for`\n\nEl bucle `for` se utiliza para iterar sobre una secuencia de elementos, como una lista, una tupla o un rango de números. La sintaxis de un bucle `for` en Python es la siguiente:\n\n```python\nfor elemento in secuencia:\n    # Código a ejecutar en cada iteración\n```\n\n![Estructura de Control `for`](/img/fund_python/estructura_for.png){width=30%}\n\nSon muy útiles cuando se necesita realizar una tarea repetitiva, como recorrer una lista de elementos o realizar una operación en cada elemento de una secuencia, serán vitales para el análisis de datos.\n\n### Ejemplo\n\nVeamos un ejemplo donde imprimimos una cuenta regresiva desde 10 hasta 1:\n\n::: {#c4ab2e79 .cell execution_count=10}\n``` {.python .cell-code}\n# Ejemplo de bucle for\nfor i in range(10, 0, -1):\n    print(i)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n10\n9\n8\n7\n6\n5\n4\n3\n2\n1\n```\n:::\n:::\n\n\nLa función `range` genera una secuencia de números desde el primer argumento hasta el segundo argumento, con un paso especificado por el tercer argumento. En este caso, estamos generando una secuencia de números desde 10 hasta 1 con un paso de -1. Es muy común usar `range` en bucles `for`. Otra forma de usar `range` es con un solo argumento, que genera una secuencia de números desde 0 hasta el argumento especificado.\n\n::: {#3dcc46e6 .cell execution_count=11}\n``` {.python .cell-code}\n# Ejemplo de bucle for con un solo argumento\nfor i in range(5):\n    print(i)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n0\n1\n2\n3\n4\n```\n:::\n:::\n\n\nComo habras notado, la función `range` genera una secuencia de números desde 0 hasta 4, ya que el argumento especificado es 5, si cuentas los números, verás que son 5 números, si quieres hasta 5, debes poner 6.\n\nEn el siguiente tema abordaremos más los usos del ciclo `for` cuando trabajamos con listas y diccionarios o en general con *objetos iterables*.\n\n## Estrucutras de Control: Bucles `while`\n\nEl bucle `while` se utiliza para ejecutar un bloque de código mientras una condición sea verdadera. La sintaxis de un bucle `while` en Python es la siguiente:\n\n```python\nwhile condicion:\n    # Código a ejecutar mientras la condición sea verdadera\n```\n\n![Estructura de Control `while`](/img/fund_python/while.jpg){width=40%}\n\nLos bucles `while` son útiles cuando no se sabe cuántas veces se debe ejecutar un bloque de código y se necesita comprobar una condición en cada iteración. \n\n> {{< fa triangle-exclamation >}} ***ADVERTENCIA.*** Es importante tener cuidado al usar bucles `while`, ya que si la condición nunca se vuelve falsa, el bucle se ejecutará indefinidamente, lo que puede provocar un bucle infinito y bloquear el programa.\n\n### Ejemplo\n\nAhora intentemos algo más complicado, crearemos una función que nos diga cuantas vecces se repite una letra dada en una cadena de texto:\n\n::: {#9355dbb2 .cell execution_count=12}\n``` {.python .cell-code}\ndef contar_letra(cadena, letra):\n    contador = 0\n    i = 0\n    while i < len(cadena):\n        if cadena[i] == letra:\n            contador += 1\n        i += 1\n    return contador\n\n# Primer verso y coro de \"Army of One\" de Coldplay \ncadena = \"\"\"\nBeen around the world, wonders to view\nBeen around the world looking for someone like you\nPyramids try, Babylon too\nBut the beautifulest treasures lie in the deepest blue\n\nSo I never say die, aim never untrue\nI'm never so high as when I'm with you\nAnd there isn't a fire that I wouldn't walk through\nMy army of one is gonna fight for you\n\"\"\"\n\nletra = 'a'\nprint(f'La letra \"{letra}\" se repite {contar_letra(cadena, letra)} veces en la cadena de texto.')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nLa letra \"a\" se repite 14 veces en la cadena de texto.\n```\n:::\n:::\n\n\nHemos combinado el uso de un bucle `while` con una declaración `if` para contar cuántas veces se repite una letra en una cadena de texto. En general siempre podemos usar un bucle `for` en lugar de un `while`, pero en este caso, queríamos mostrar cómo se puede usar un bucle `while` para realizar la misma tarea.\n\nCombinar funciones, bucles y estructuras de control es una de las formas más poderosas de programar en cualquier lenguaje, y Python no es la excepción.\n\n# Ejercicios\n\n1. Escribe una función que tome dos números como argumentos y devuelva el mayor de los dos.\n\n2. Escribe una función que te diga si un número es par o impar.\n\n3. Crea una función que diga si una palabra es palíndroma o no.\n\n4. Crea una función que diga si un año es bisiesto o no. ( {{< fa magnifying-glass size=footnotesize >}} ***PISTA:*** un año es bisiesto si es divisible entre $4$, excepto los años que son divisibles entre $100$ pero no entre $400$).\n\n5. Escribe una función que cuente en reversa hasta 0 desde un número dado y si el número es divisible entre $3$, imprime \"Fizz\", si es divisible entre $5$, imprime \"Buzz\" y si es divisible entre $3$ y $5$, imprime \"FizzBuzz\". Por ejemplo, el número $15$ debería imprimir \"FizzBuzz\", el número $9$ debería imprimir \"Fizz\" y el número $10$ debería imprimir \"Buzz\".\n\n```{pyodide-python}\n# Escribe tu código aquí\n```\n\n# Manejando Bucles de Control\n\nHay ocasiones en las que necesitamos salir de un bucle antes de que se complete o saltar a la siguiente iteración sin ejecutar el resto del código. En Python, podemos hacer esto con las declaraciones `break` y `continue`.\n\n## Declaración `break`\n\nLa declaración `break` se utiliza para salir de un bucle antes de que se complete. Cuando se encuentra una declaración `break`, el bucle se detiene y la ejecución continúa con la siguiente instrucción después del bucle. La declaración `break` se puede utilizar en bucles `for` y `while`. Se suele utilizar para salir de un bucle cuando se cumple una condición específica utilizando una declaración `if`.\n\nSupongamos que queremos encontrar el primer número divisible entre $7$ y $5$ en un rango de números del $1$ al $100$. Podemos usar un bucle `for` y la declaración `break` para salir del bucle cuando se encuentre el número deseado.\n\n::: {#510e5b40 .cell execution_count=13}\n``` {.python .cell-code}\nfor i in range(1, 101):\n    if i % 7 == 0 and i % 5 == 0:\n        print(f'El primer número divisible entre 7 y 5 es {i}')\n        break\n    else:\n        print(f'{i} no es divisible entre 7 y 5')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1 no es divisible entre 7 y 5\n2 no es divisible entre 7 y 5\n3 no es divisible entre 7 y 5\n4 no es divisible entre 7 y 5\n5 no es divisible entre 7 y 5\n6 no es divisible entre 7 y 5\n7 no es divisible entre 7 y 5\n8 no es divisible entre 7 y 5\n9 no es divisible entre 7 y 5\n10 no es divisible entre 7 y 5\n11 no es divisible entre 7 y 5\n12 no es divisible entre 7 y 5\n13 no es divisible entre 7 y 5\n14 no es divisible entre 7 y 5\n15 no es divisible entre 7 y 5\n16 no es divisible entre 7 y 5\n17 no es divisible entre 7 y 5\n18 no es divisible entre 7 y 5\n19 no es divisible entre 7 y 5\n20 no es divisible entre 7 y 5\n21 no es divisible entre 7 y 5\n22 no es divisible entre 7 y 5\n23 no es divisible entre 7 y 5\n24 no es divisible entre 7 y 5\n25 no es divisible entre 7 y 5\n26 no es divisible entre 7 y 5\n27 no es divisible entre 7 y 5\n28 no es divisible entre 7 y 5\n29 no es divisible entre 7 y 5\n30 no es divisible entre 7 y 5\n31 no es divisible entre 7 y 5\n32 no es divisible entre 7 y 5\n33 no es divisible entre 7 y 5\n34 no es divisible entre 7 y 5\nEl primer número divisible entre 7 y 5 es 35\n```\n:::\n:::\n\n\nPodemos ver que el bucle se detiene en el número $35$, que es el primer número divisible entre $7$ y $5$ en el rango de números del $1$ al $100$.\n\n## Declaración `continue`\n\nLa declaración `continue` se utiliza para saltar a la siguiente iteración de un bucle sin ejecutar el resto del código en el bloque de bucle. Se suele utilizar para omitir ciertas iteraciones de un bucle basándose en una condición.\n\nPor ejemplo, supongamos que queremos imprimir todos los números del $1$ al $10$ excepto el número $5$. Podemos usar un bucle `for` y la declaración `continue` para saltar la iteración cuando el número es $5$.\n\n::: {#42c12644 .cell execution_count=14}\n``` {.python .cell-code}\nfor i in range(1, 11):\n    if i == 5:\n        continue\n    print(i)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1\n2\n3\n4\n6\n7\n8\n9\n10\n```\n:::\n:::\n\n\nOtra declaración que se puede usar en bucles es `pass`, que no hace nada y se utiliza como marcador de posición cuando no se necesita ejecutar ninguna instrucción en un bloque de código. Pero el resultado no es el mismo que `continue`, ya que `pass` no salta a la siguiente iteración, simplemente no hace nada.\n\n::: {#25cfce7a .cell execution_count=15}\n``` {.python .cell-code}\nfor i in range(1, 11):\n    if i == 5:\n        pass\n    print(i)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n```\n:::\n:::\n\n\nEn este caso, el número $5$ se imprimirá, pero no se ejecutará ninguna instrucción cuando `i == 5`. Es una forma de evitar errores de sintaxis cuando se necesita un bloque de código vacío (por ejemplo, en una declaración `if` o una función que aún no se ha implementado).\n\n# Conclusiones\n\nEn el contexto del análisis y el modelado de datos, ¿cómo crees que las funciones y las estructuras de control pueden ser útiles? ¿Qué tipos de tareas o problemas crees que se pueden abordar de manera más eficiente con funciones y estructuras de control? \n\nEn la próxima lección, exploraremos cómo trabajar con listas, tuplas, conjuntos y diccionarios en Python, que son estructuras de datos fundamentales para el análisis de datos y la programación en general. ¡Nos vemos en la próxima lección!\n\n",
    "supporting": [
      "functions_and_loops_files"
    ],
    "filters": [],
    "includes": {}
  }
}