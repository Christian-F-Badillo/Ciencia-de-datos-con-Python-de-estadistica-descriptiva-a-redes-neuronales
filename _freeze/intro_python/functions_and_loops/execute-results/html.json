{
  "hash": "e7ee8bb62a7e4939070b2cdc1d93ee5a",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: Funciones y Bucles de Control\nauthor: Christian Badillo\nformat: html\ndate: today\norder: 3\nipynb-shell-interactivity: all\nfilters:\n  - pyodide\n  - fontawesome\n  - iconify\n---\n\n# Funciones\n\nLas ***funciones*** son bloques de código que se pueden reutilizar en diferentes partes de un programa, permitiendo que el código sea más modular y fácil de mantener. En Python, las funciones se definen con la palabra clave `def`, seguida del nombre de la función y una lista de parámetros entre paréntesis. El cuerpo de la función se define con sangría y puede contener cualquier número de instrucciones.\n\nPrimero elaboremos una función sencilla, la cual se llamará `saludo` y recibirá un parámetro `nombre`:\n\n```` { .cell-code}\n```{{python}}\ndef saludo(nombre):\n    print(f'Hola, {nombre}!')\n\nsaludo('Christian')\n```\n\n````\nHola, Christian!\n\n\nHemos usado una **f-string** para imprimir el saludo. Las f-strings son una forma de formatear cadenas de texto en Python, permitiendo la interpolación de variables dentro de una cadena. Para definir una f-string, se coloca una `f` antes de las comillas de apertura y se encierra la variable entre llaves `{}`. Es decir, le estamos diciendo a Python que reemplace `{nombre}` con el valor de la variable `nombre` que en este caso es `'Christian'`.\n\nLas funciones pueden devolver un valor usando la palabra clave `return`. Por ejemplo, la siguiente función `cuadrado` recibe un número `x` y devuelve su cuadrado:\n\n```` { .cell-code}\n```{{python}}\ndef cuadrado(x):\n    return x ** 2\n\nprint(cuadrado(5))\n```\n\n````\n25\n\n\nComo habrás notado en los ejemplos anteriores, hemos usado el nombre de la función seguido de paréntesis para llamarla. En el caso de la función `saludo`, hemos pasado un argumento `nombre` entre los paréntesis. En el caso de la función `cuadrado`, hemos pasado el número `5`. Estos argumentos se llaman ***parámetros*** y son los valores que la función espera recibir para realizar su tarea.\n\nHay varias formas de poner los argumentos en una función:\n\n- **Argumentos posicionales**: Los argumentos se pasan en el orden en que se definen en la función.\n- **Argumentos con nombre**: Los argumentos se pasan con el nombre del parámetro al que corresponden.\n- **Argumentos por defecto**: Los argumentos tienen un valor por defecto que se usa si no se proporciona un valor.\n- **Argumentos variables**: Los argumentos se pasan como una lista o un diccionario.\n\nEn los ejemplos hemos utilizado argumentos posicionales. A continuación, veremos cómo usar argumentos con nombre:\n\n```` { .cell-code}\n```{{python}}\ndef resta(num1, num2):\n    return num1 - num2\n\nprint(resta(num1=10, num2=5))\n```\n\n````\n5\n\n\nEn este caso, hemos pasado los argumentos `num1` y `num2` con sus nombres correspondientes y les hemos asignado valores. Esto nos permite pasar los argumentos en cualquier orden, siempre y cuando especifiquemos el nombre del parámetro al que corresponden.\n\nAhora veamos cómo usar argumentos por defecto:\n\n```` { .cell-code}\n```{{python}}\ndef potencia(base, exponente=2):\n    return base ** exponente\n\nprint(potencia(2))\nprint(potencia(2, 3))\n```\n\n````\n4\n8\n\n\nEn este caso, la función `potencia` tiene un argumento `exponente` con un valor por defecto de `2`. Si no se proporciona un valor para `exponente`, se usará el valor por defecto. Si se proporciona un valor, se usará ese valor en su lugar.\n\n## Funciones Lambda\n\nLas funciones lambda son funciones anónimas que se pueden definir en una sola línea. Se definen con la palabra clave `lambda`, seguida de una lista de parámetros y una expresión que se evalúa y devuelve el resultado. Por ejemplo, la siguiente función lambda calcula el cuadrado de un número:\n\n```` { .cell-code}\n```{{python}}\ncuadrado_lamda = lambda x: x ** 2\n\nprint(cuadrado_lamda(5))\n```\n\n````\n25\n\n\nLas funciones lambda son útiles cuando se necesita una función simple y no es necesario definirla con una declaración `def`. \n\nAhora definamos una función lambda un poco más compleja para sumar dos números:\n\n```` { .cell-code}\n```{{python}}\nsuma_lambda = lambda x, y: x + y\n\nprint(suma_lambda(3, 4))\n```\n\n````\n7\n\n\n## Creando funciones legibles\n\nEs importante que las funciones sean fáciles de leer y entender. Para ello, es recomendable seguir las siguientes buenas prácticas:\n\n- **Nombres descriptivos**: Usa nombres descriptivos para las funciones y los parámetros.\n- **Comentarios**: Añade comentarios para explicar lo que hace cada parte de la función.\n- **Documentación**: Usa [docstrings](https://peps.python.org/pep-0257/) para documentar la función y proporcionar información sobre su propósito, los parámetros que espera y el valor que devuelve.\n- **Dividir en funciones más pequeñas**: Si una función es demasiado larga o hace demasiadas cosas, divídela en funciones más pequeñas que realicen tareas específicas.\n\nVeamos un ejemplo de una función bien documentada y legible:\n\n```{pyodide-python}\nimport numpy as np\nimport matplotlib.pyplot as plt\n\ndef sine_wave(amplitude: float = None, frequency: float = None, phase: float = None, duration: float = None, sample_rate: float = None):\n    \"\"\"\n    Generate a sine wave signal.\n\n    Parameters:\n    - amplitude: The amplitude of the sine wave.\n    - frequency: The frequency of the sine wave in Hz.\n    - phase: The phase of the sine wave in radians.\n    - duration: The duration of the signal in seconds.\n    - sample_rate: The sample rate of the signal in Hz.\n\n    Returns:\n    - t: An array of time values.\n    - x: An array of signal values.\n    \"\"\"\n    t = np.linspace(0, duration, int(sample_rate * duration), endpoint=False) # Generate time values\n    x = amplitude * np.sin(2 * np.pi * frequency * t + phase) # Generate signal values\n    return t, x\n\n# Generate a sine wave signal with amplitude 1, frequency 1 Hz, phase 0, duration 1 second, and sample rate 1000 Hz\nt, x = sine_wave(amplitude=1, frequency=1, phase=0, duration=1, sample_rate=1000) \n\n# Plot the sine wave signal\ndef plot_signal(t, x):\n    plt.figure() # Create a new figure\n    plt.plot(t, x) # Plot the signal\n    plt.xlabel('Time (s)') # Set the x-axis label\n    plt.ylabel('Amplitude') # Set the y-axis label\n    plt.grid(True) # Show grid\n    plt.show() # Show the plot\n\nplot_signal(t, x)\n```\n\nEn este ejemplo, hemos definido una función `sine_wave` que genera una señal de onda sinusoidal con los parámetros de amplitud, frecuencia, fase, duración y tasa de muestreo especificados. Hemos documentado la función con un docstring que explica los parámetros que espera y el valor que devuelve. También hemos definido una función `plot_signal` que traza la señal generada. Esta función es más legible y fácil de entender gracias a los comentarios y la documentación.\n\n",
    "supporting": [
      "functions_and_loops_files/figure-html"
    ],
    "filters": [],
    "includes": {}
  }
}