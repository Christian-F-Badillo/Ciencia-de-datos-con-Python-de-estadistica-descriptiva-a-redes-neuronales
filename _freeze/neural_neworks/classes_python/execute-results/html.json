{
  "hash": "e181b40ff9ea695a4d6a0b31bf203f81",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Programación Orientada a Objetos en Python\"\nauthor: \"Christian Badillo\"\nformat: html\ndate: today\norder: 1\n---\n\n# Classes y Objetos\n\nLa programación orientada a objetos (POO) es un paradigma de programación que se basa en el uso de clases y objetos. En este paradigma, los objetos son entidades que tienen atributos y métodos. Las clases son plantillas que definen la estructura de los objetos.\n\nPodemos pensar en las clases como moldes para crear objetos. Por ejemplo, si tenemos una clase `Gato`, podemos crear varios objetos de tipo `Gato` a partir de esa clase. Cada objeto de tipo `Gato` tendrá sus propios atributos y métodos.\n\nLos **atributos** de una clase son variables que almacenan información sobre el objeto. Por ejemplo, un gato puede tener atributos como `nombre`, `edad` y `color`. Son caracterticas que definen al objeto y pocas veces cambian.\n\nLos **métodos** de una clase son funciones que definen el comportamiento del objeto. Por ejemplo, un gato puede tener métodos como `maullar`, `dormir` y `comer`. Son acciones que el objeto puede realizar. Pueden modificar los atributos del objeto o realizar alguna acción en el objeto.\n\nLas características de la POO son:\n\n- **Encapsulamiento**: Las clases encapsulan los datos y los métodos que operan sobre esos datos. Esto significa que los datos y los métodos están juntos en un solo lugar.\n- **Abstracción**: Las clases permiten abstraer los detalles de implementación de un objeto. Esto significa que podemos usar un objeto sin necesidad de conocer cómo está implementado.\n- **Herencia**: Las clases pueden heredar atributos y métodos de otras clases. Esto permite reutilizar código y crear jerarquías de clases.\n- **Polimorfismo**: Las clases pueden tener métodos con el mismo nombre pero con diferentes implementaciones. Esto permite que un objeto pueda comportarse de diferentes maneras dependiendo del contexto.\n- **Modularidad**: Las clases permiten dividir un programa en módulos más pequeños. Esto facilita la reutilización de código y el mantenimiento del programa.\n\nLos objetos son instancias de una clase. Por ejemplo, si tenemos una clase `Gato`, un objeto de tipo `Gato` sería un gato en particular. Podemos crear varios objetos de tipo `Gato` a partir de la misma clase. Ya hemos visto esto una gran cantidad de veces, por ejemplo, cuando creamos una lista vacía con `[]` estamos creando un objeto de la clase `list` que tiene sus propios métodos y atributos.\n\nLa sintaxis en Python para definir una clase es la siguiente:\n\n```python\nclass NombreDeLaClase(object):\n    def __init__(self, atributo1, atributo2):\n        self.atributo1 = atributo1\n        self.atributo2 = atributo2\n\n    def metodo1(self, parametro1, parametro2):\n        pass\n\n    def metodo2(self):\n        pass\n```\n\nSe usa la palabra reservada `class` seguida del nombre de la clase y entre parentesis la clase de la que es heredera, sino se especifica la clase no hereda nada. Cada método se define como una función dentro de la clase. El método `__init__` es el constructor de la clase y se llama cuando se crea un objeto de la clase. El primer argumento de los métodos es `self`, que es una referencia al objeto en sí mismo, esto indica que el método pertenece a la clase. Además del parámetro `self`, los métodos pueden tener otros parámetros que se pasan al llamar al método. Para acceder a los atributos de la clase se usa la notación `self.atributo`.\n\nPara documentar una clase se usa el siguiente formato:\n\n```python\nclass NombreDeLaClase(objecto):\n    \"\"\"\n    Documentación de la clase\n    \"\"\"\n\n    def __init__(self, atributo1, atributo2):\n        \"\"\"\n        Documentación del método __init__\n        \"\"\"\n        self.atributo1 = atributo1\n        self.atributo2 = atributo2\n\n    def metodo1(self, parametro1, parametro2):\n        \"\"\"\n        Documentación del método metodo1\n        \"\"\"\n        pass\n\n    def metodo2(self):\n        \"\"\"\n        Documentación del método metodo2\n        \"\"\"\n        pass\n```\n\nPara instanciar un objeto de una clase se usa la siguiente sintaxis:\n\n```python\nobjeto = NombreDeLaClase(init_param1, init_param2)\n```\n\nAsignamos el objeto a una variable y llamamos a la clase con los parámetros que recibe el método `__init__`.\n\n\n## Ejemplo\n\nVamos a crear una clase llamada `Gato` que tiene los atributos `nombre`, `edad` y `color` y los métodos `maullar`, `dormir` y `comer`.\n\n::: {#0140da70 .cell execution_count=1}\n``` {.python .cell-code}\nclass Gato(object):\n    \"\"\"\n    Clase que representa un gato\n    \"\"\"\n\n    def __init__(self, nombre, edad, color):\n        \"\"\"\n        Constructor de la clase Gato\n        \"\"\"\n        self.nombre = nombre\n        self.edad = edad\n        self.color = color\n\n    def maullar(self):\n        \"\"\"\n        Método que hace que el gato maúlle\n        \"\"\"\n        print(f\"{self.nombre} está maullando\")\n\n    def dormir(self):\n        \"\"\"\n        Método que hace que el gato duerma\n        \"\"\"\n        print(f\"{self.nombre} está durmiendo\")\n\n    def comer(self):\n        \"\"\"\n        Método que hace que el gato coma\n        \"\"\"\n        print(f\"{self.nombre} está comiendo\")\n```\n:::\n\n\nAhora vamos a crear un objeto de tipo `Gato` y llamar a sus métodos.\n\n::: {#1166f7e7 .cell execution_count=2}\n``` {.python .cell-code}\ngato = Gato(\"Tom\", 3, \"gris\")\ngato.maullar()\n\ngato.dormir()\n\ngato.comer()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTom está maullando\nTom está durmiendo\nTom está comiendo\n```\n:::\n:::\n\n\nAhora creemos una nueva clase que herede de la clase `Gato`, en este caso crearemos un gato naranjoso.\n\n::: {#d7210f26 .cell execution_count=3}\n``` {.python .cell-code}\nclass Naranjoso(Gato):\n    \"\"\"\n    Clase que representa un gato naranjoso\n    \"\"\"\n\n    def __init__(self, nombre, edad):\n        \"\"\"\n        Constructor de la clase Naranjoso\n        \"\"\"\n        super().__init__(nombre, edad, \"naranja\")\n\n    def romper_cosas(self):\n        \"\"\"\n        Método que hace que el gato naranjoso rompa cosas\n        \"\"\"\n        print(f\"{self.nombre} está rompiendo cosas\")\n    \n    def travesura(self):\n        \"\"\"\n        Método que hace que el gato naranjoso haga travesuras\n        \"\"\"\n        print(f\"{self.nombre} está haciendo travesuras\")\n\n    def comer_lasaña(self):\n        \"\"\"\n        Método que hace que el gato naranjoso coma lasaña\n        \"\"\"\n        print(f\"{self.nombre} está comiendo lasaña\")\n```\n:::\n\n\nAhora vamos a crear un objeto de tipo `Naranjoso` y llamar a sus métodos.\n\n::: {#48a32142 .cell execution_count=4}\n``` {.python .cell-code}\nnaranjoso = Naranjoso(\"Garfield\", 5)\n\nnaranjoso.maullar()\n\nnaranjoso.dormir()\n\nnaranjoso.romper_cosas()\n\nnaranjoso.travesura()\n\nnaranjoso.comer_lasaña()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nGarfield está maullando\nGarfield está durmiendo\nGarfield está rompiendo cosas\nGarfield está haciendo travesuras\nGarfield está comiendo lasaña\n```\n:::\n:::\n\n\nComo hemos visto podemos usar los métodos de la clase `Gato` en la clase `Naranjoso` ya que `Naranjoso` hereda de `Gato` y hemos creado nuevos métodos para la clase `Naranjoso` que no están en la clase `Gato` sin modificar la clase `Gato`.\n\n# Ejemplo 2.\n\nVamos a crear una clase que nos permita realizar una regresión lineal.\n\n::: {#99eb7697 .cell execution_count=5}\n``` {.python .cell-code}\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport scipy.stats as stats\n\nclass LinearRegression():\n    \"\"\"\n    Clase que realiza una regresión lineal\n    \"\"\"\n\n    def __init__(self, X:pd.DataFrame=None, Y:pd.Series=None) -> None:\n        \"\"\"\n        Constructor de la clase LinearRegression\n        \"\"\"\n        self.X = X.to_numpy()\n        self.Y = Y.to_numpy()\n\n        assert  X.shape[0] == Y.shape[0], \"X and Y must have the same number of rows\"\n\n        self.n = len(X)\n        self.intercept = None\n        self.coefficients = None\n    \n    def fit(self) -> None:\n        \"\"\"\n        Método que ajusta el modelo de regresión lineal\n        \"\"\"\n\n        X = np.c_[np.ones(self.n), self.X]\n        beta = np.linalg.inv(X.T @ X) @ X.T @ self.Y\n\n        self.intercept = beta[0]\n        self.coefficients = beta[1:]\n\n    def predict(self, X:pd.DataFrame) -> pd.Series:\n        \"\"\"\n        Método que realiza predicciones\n        \"\"\"\n\n        X = np.c_[np.ones(len(X)), X.to_numpy()]\n\n        return pd.Series(X @ np.r_[self.intercept, self.coefficients])\n    \n    def plot(self) -> None:\n        \"\"\"\n        Método que realiza un gráfico de la regresión\n        \"\"\"\n        assert len(self.coefficients) == 1, \"Only works for simple linear regression\"\n\n        fig = plt.figure(figsize=(10, 6))\n        ax = sns.regplot(x = self.X, y = self.Y, ci=95, line_kws={\"color\":\"red\"}, scatter_kws={\"color\":\"blue\"})\n        ax.set_title(\"Regresión Lineal\", fontsize=20, fontweight=\"bold\")\n        ax.set_xlabel(\"X\", fontsize=15)\n        ax.set_ylabel(\"Y\", fontsize=15)\n        plt.show()\n```\n:::\n\n\nAhora vamos a crear un objeto de tipo `LinearRegression` y ajustar un modelo de regresión lineal.\n\n::: {#9813456b .cell execution_count=6}\n``` {.python .cell-code}\nnp.random.seed(42)\nX = pd.DataFrame(np.random.rand(100, 1))\nY = pd.Series(2 + 3 * X[0] + np.random.randn(100))\n\ndata = pd.concat([X, Y], axis=1)\ndata.columns = [\"X\", \"Y\"]\ndata.head()\n```\n\n::: {.cell-output .cell-output-display execution_count=16}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>X</th>\n      <th>Y</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>0.374540</td>\n      <td>3.210667</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>0.950714</td>\n      <td>4.553136</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>0.731994</td>\n      <td>4.287743</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>0.598658</td>\n      <td>1.808407</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>0.156019</td>\n      <td>2.248384</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n::: {#77f658c9 .cell execution_count=7}\n``` {.python .cell-code}\nlr = LinearRegression(X, Y)\n\nlr.fit()\n\nlr.intercept, lr.coefficients\n```\n\n::: {.cell-output .cell-output-display execution_count=17}\n```\n(2.2150961575467494, array([2.54022677]))\n```\n:::\n:::\n\n\n::: {#fd3d0039 .cell execution_count=8}\n``` {.python .cell-code}\nX_new = pd.DataFrame(np.linspace(0, 1, 100))\nY_new = lr.predict(X_new)\n\ndata_new = pd.concat([X_new, Y_new], axis=1)\ndata_new.columns = [\"X\", \"Y\"]\ndata_new.head()\n```\n\n::: {.cell-output .cell-output-display execution_count=18}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>X</th>\n      <th>Y</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>0.000000</td>\n      <td>2.215096</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>0.010101</td>\n      <td>2.240755</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>0.020202</td>\n      <td>2.266414</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>0.030303</td>\n      <td>2.292073</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>0.040404</td>\n      <td>2.317732</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n::: {#02f43310 .cell execution_count=9}\n``` {.python .cell-code}\nlr.plot()\n```\n\n::: {.cell-output .cell-output-display}\n![](classes_python_files/figure-html/cell-10-output-1.png){width=806 height=540}\n:::\n:::\n\n\n# Ejercicios\n\n1. Crea una clase llamada `Rectangulo` que tenga los atributos `base` y `altura` y los métodos `area` y `perimetro`.\n\n2. Crea una clase llamada `Calculadora` que tenga los métodos `suma`, `resta`, `multiplicacion` y `division`.\n\n3. Crea una clase para realizar gráficos distintos, por ejemplo, un histograma, un gráfico de barras, un gráfico de líneas, un gráfico de dispersión, etc. Cada método debe tener un nombre descriptivo y recibir los datos necesarios para realizar el gráfico.\n\n4. Crea una clase llamada `Estadisticas` que tenga los métodos `media`, `mediana`, `varianza` y `desviacion_estandar` para calcular estas estadísticas de un conjunto de datos.\n\n::: {#0f80a1b1 .cell execution_count=10}\n``` {.python .cell-code}\n# Respuestas\n```\n:::\n\n\n",
    "supporting": [
      "classes_python_files"
    ],
    "filters": [],
    "includes": {
      "include-in-header": [
        "<script src=\"https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js\" integrity=\"sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==\" crossorigin=\"anonymous\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js\" integrity=\"sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==\" crossorigin=\"anonymous\" data-relocate-top=\"true\"></script>\n<script type=\"application/javascript\">define('jquery', [],function() {return window.jQuery;})</script>\n"
      ]
    }
  }
}