[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "Christian Francisco Badillo Hern√°ndez",
    "section": "",
    "text": "twitter\n  \n  \n    \n     Github\n  \n  \n    \n     LinkedIn\n  \n\n  \n  \nChristian Badiillo es egresado de la Facultad de Psicolog√≠a, UNAM con apasionado inter√©s por el estudio del comportamiento humano su modelamiento computacional y el an√°lisis estad√≠stico bayesiano de datos. Actualmente es miembro del Lab25 ‚ÄúAprendizaje y Comportamiento Adaptable‚Äù de la Facultad de Psicolog√≠a, UNAM donde se dedica a la investigaci√≥n en el campo del modelamiento computacional del comportamiento y su intersecci√≥n con la inteligencia artificial.\n\n\nFacultad de Psicolog√≠a UNAM | Ciudad de M√©xico, M√©xico Licenciatura en Psicolog√≠a | Ago 2019 - Ago 2023\n\n\n\nIIMAS | Servicio Social - Desarrollo de sistemas inteligentes usando deep learning | Feb 2024 - presente\nFacultad de Psicolog√≠a UNAM | Impartici√≥n de Curso Intersemestral - Temas Selectos en Estad√≠stica | Periodo 2024-1\nUNAM | Curso de Verano - Macroentrenamiento en Inteligencia Artificial (MeIA) 2023. | Jun 2023\nNeuromatch Academy | Curso de Verano - NMA Computational Neuroscience | Jul 2022",
    "crumbs": [
      "Acerca"
    ]
  },
  {
    "objectID": "about.html#educaci√≥n",
    "href": "about.html#educaci√≥n",
    "title": "Christian Francisco Badillo Hern√°ndez",
    "section": "",
    "text": "Facultad de Psicolog√≠a UNAM | Ciudad de M√©xico, M√©xico Licenciatura en Psicolog√≠a | Ago 2019 - Ago 2023",
    "crumbs": [
      "Acerca"
    ]
  },
  {
    "objectID": "about.html#experiencia",
    "href": "about.html#experiencia",
    "title": "Christian Francisco Badillo Hern√°ndez",
    "section": "",
    "text": "IIMAS | Servicio Social - Desarrollo de sistemas inteligentes usando deep learning | Feb 2024 - presente\nFacultad de Psicolog√≠a UNAM | Impartici√≥n de Curso Intersemestral - Temas Selectos en Estad√≠stica | Periodo 2024-1\nUNAM | Curso de Verano - Macroentrenamiento en Inteligencia Artificial (MeIA) 2023. | Jun 2023\nNeuromatch Academy | Curso de Verano - NMA Computational Neuroscience | Jul 2022",
    "crumbs": [
      "Acerca"
    ]
  },
  {
    "objectID": "statistics/Linear_models.html",
    "href": "statistics/Linear_models.html",
    "title": "Modelos Lineales",
    "section": "",
    "text": "Los modelos lineales son una clase de modelos estad√≠sticos que asumen que la relaci√≥n entre las variables dependientes e independientes es lineal. En este tutorial, aprenderemos c√≥mo ajustar un modelo lineal a un conjunto de datos y c√≥mo interpretar los resultados.\nEntre los modelos lineales m√°s comunes se encuentran la regresi√≥n lineal simple y la regresi√≥n lineal m√∫ltiple. Se pueden utilizar para predecir una variable dependiente a partir de una o m√°s variables independientes.\nOtros modelos lineales incluyen algunas pruebas de hip√≥tesis, como el an√°lisis de varianza (ANOVA) y la comparaci√≥n de medias (prueba t).\nTodos estos modelos caen en la categor√≠a de modelos lineales generalizados (GLM), que son una extensi√≥n de los modelos lineales tradicionales que permiten una mayor flexibilidad en la especificaci√≥n de la distribuci√≥n de los errores y la funci√≥n de enlace.",
    "crumbs": [
      "Manejo de Datos y Estad√≠stica con Python",
      "Modelos Lineales"
    ]
  },
  {
    "objectID": "statistics/Linear_models.html#regresi√≥n-lineal-simple-por-m√≠nimos-cuadrados",
    "href": "statistics/Linear_models.html#regresi√≥n-lineal-simple-por-m√≠nimos-cuadrados",
    "title": "Modelos Lineales",
    "section": "Regresi√≥n Lineal Simple por M√≠nimos Cuadrados",
    "text": "Regresi√≥n Lineal Simple por M√≠nimos Cuadrados\nEl m√©todo m√°s com√∫n para ajustar un modelo de regresi√≥n lineal simple es el m√©todo de m√≠nimos cuadrados. Este m√©todo consiste en encontrar los valores de \\(\\beta_0\\) y \\(\\beta_1\\) que minimizan la suma de los cuadrados de los errores. La f√≥rmula para calcular los valores de \\(\\beta_0\\) y \\(\\beta_1\\) es la siguiente:\n\\[\\beta_1 = \\frac{\\sum_{i=1}^{n} (X_i - \\bar{X})(Y_i - \\bar{Y})}{\\sum_{i=1}^{n} (X_i - \\bar{X})^2}\\]\n\\[\\beta_0 = \\bar{Y} - \\beta_1\\bar{X}\\]\nDonde:\n\n\\(\\bar{X}\\) es la media de la variable independiente\n\\(\\bar{Y}\\) es la media de la variable dependiente\n\\(n\\) es el n√∫mero de observaciones\n\nUsemos los datos de la altura y el peso de un grupo de personas para ajustar un modelo de regresi√≥n lineal simple y predecir el peso de una persona en funci√≥n de su altura.\n\n\nC√≥digo\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Datos\naltura = np.array([150, 160, 170, 180, 190])\npeso = np.array([50, 60, 70, 80, 90])\n\n# Calcular medias\naltura_media = np.mean(altura)\npeso_media = np.mean(peso)\n\n# Calcular beta_1\nbeta_1 = np.sum((altura - altura_media) * (peso - peso_media)) / np.sum((altura - altura_media) ** 2)\n\n# Calcular beta_0\nbeta_0 = peso_media - beta_1 * altura_media\n\n# Imprimir coeficientes\nprint(f'beta_0: {beta_0}')\nprint(f'beta_1: {beta_1}')\n\n\nbeta_0: -100.0\nbeta_1: 1.0\n\n\nPodemos graficar los datos y la l√≠nea de regresi√≥n para visualizar la relaci√≥n entre la altura y el peso.\n\n\nC√≥digo\n# Graficar datos\nplt.scatter(altura, peso, color='blue')\nplt.plot(altura, beta_0 + beta_1 * altura, color='red')\nplt.xlabel('Altura')\nplt.ylabel('Peso')\nplt.title('Regresi√≥n Lineal Simple')\nplt.show()\n\n\n\n\n\n\n\n\n\nAhora podemos crear datos datos mas realistas y ajustar un modelo de regresi√≥n lineal simple.\n\n\nC√≥digo\n# Crear datos\nnp.random.seed(0)\n\naltura = np.random.normal(170, 10, 100)\npeso = 50 + 0.05 * altura + np.random.normal(0, 5, 100)\n\n# Calcular medias\naltura_media = np.mean(altura)\npeso_media = np.mean(peso)\n\n# Calcular beta_1\nbeta_1 = np.sum((altura - altura_media) * (peso - peso_media)) / np.sum((altura - altura_media) ** 2)\n\n# Calcular beta_0\nbeta_0 = peso_media - beta_1 * altura_media\n\n# Imprimir coeficientes\nprint(f'beta_0: {beta_0}')\nprint(f'beta_1: {beta_1}')\n\n# Graficar datos\nplt.figure(figsize=(10, 6))\nplt.scatter(altura, peso, color='blue')\nplt.plot(altura, beta_0 + beta_1 * altura, color='red')\nplt.xlabel('Altura')\nplt.ylabel('Peso')\nplt.title('Regresi√≥n Lineal Simple')\nplt.show()\n\n\nbeta_0: 40.626398573820204\nbeta_1: 0.10734921677319048\n\n\n\n\n\n\n\n\n\nUsando seaborn podemos ajustar un modelo de regresi√≥n lineal simple y visualizar los resultados.\n\n\nC√≥digo\nimport seaborn as sns\nimport pandas as pd\n\n# Crear DataFrame\ndf = pd.DataFrame({'altura': altura, 'peso': peso})\n\n# Ajustar modelo\nplt.figure(figsize=(10, 6))\nsns.lmplot(x='altura', y='peso', data=df)\n\nplt.show()\n\n\n&lt;Figure size 960x576 with 0 Axes&gt;\n\n\n\n\n\n\n\n\n\nNos muestra la gr√°fica de la regresi√≥n lineal simple y su intervalo de confianza.\nLa libreria statsmodels nos permite ajustar un modelo de regresi√≥n lineal simple y obtener un resumen de los resultados.\nPuedes instalar la libreria usando el siguiente comando:\n!pip install statsmodels\n\n\nC√≥digo\nimport statsmodels.api as sm\n\n# Ajustar modelo\nX = sm.add_constant(altura)\nmodel = sm.OLS(peso, X).fit()\n\n# Imprimir resumen\nprint(model.summary())\n\n\n                            OLS Regression Results                            \n==============================================================================\nDep. Variable:                      y   R-squared:                       0.042\nModel:                            OLS   Adj. R-squared:                  0.033\nMethod:                 Least Squares   F-statistic:                     4.341\nDate:                Mon, 17 Jun 2024   Prob (F-statistic):             0.0398\nTime:                        20:15:17   Log-Likelihood:                -305.62\nNo. Observations:                 100   AIC:                             615.2\nDf Residuals:                      98   BIC:                             620.4\nDf Model:                           1                                         \nCovariance Type:            nonrobust                                         \n==============================================================================\n                 coef    std err          t      P&gt;|t|      [0.025      0.975]\n------------------------------------------------------------------------------\nconst         40.6264      8.805      4.614      0.000      23.152      58.100\nx1             0.1073      0.052      2.083      0.040       0.005       0.210\n==============================================================================\nOmnibus:                        5.184   Durbin-Watson:                   1.995\nProb(Omnibus):                  0.075   Jarque-Bera (JB):                3.000\nSkew:                           0.210   Prob(JB):                        0.223\nKurtosis:                       2.262   Cond. No.                     2.90e+03\n==============================================================================\n\nNotes:\n[1] Standard Errors assume that the covariance matrix of the errors is correctly specified.\n[2] The condition number is large, 2.9e+03. This might indicate that there are\nstrong multicollinearity or other numerical problems.\n\n\nPara ajustar el modelo primero agregamos una columna de unos a la matriz de caracter√≠sticas X y luego ajustamos el modelo usando la funci√≥n OLS de statsmodels. Finalmente, imprimimos un resumen de los resultados del modelo.\nImprimamos el valor de X\n\n\nC√≥digo\nX\n\n\narray([[  1.        , 187.64052346],\n       [  1.        , 174.00157208],\n       [  1.        , 179.78737984],\n       [  1.        , 192.40893199],\n       [  1.        , 188.6755799 ],\n       [  1.        , 160.2272212 ],\n       [  1.        , 179.50088418],\n       [  1.        , 168.48642792],\n       [  1.        , 168.96781148],\n       [  1.        , 174.10598502],\n       [  1.        , 171.44043571],\n       [  1.        , 184.54273507],\n       [  1.        , 177.61037725],\n       [  1.        , 171.21675016],\n       [  1.        , 174.43863233],\n       [  1.        , 173.33674327],\n       [  1.        , 184.94079073],\n       [  1.        , 167.94841736],\n       [  1.        , 173.13067702],\n       [  1.        , 161.45904261],\n       [  1.        , 144.47010184],\n       [  1.        , 176.53618595],\n       [  1.        , 178.64436199],\n       [  1.        , 162.5783498 ],\n       [  1.        , 192.69754624],\n       [  1.        , 155.45634325],\n       [  1.        , 170.45758517],\n       [  1.        , 168.1281615 ],\n       [  1.        , 185.32779214],\n       [  1.        , 184.6935877 ],\n       [  1.        , 171.54947426],\n       [  1.        , 173.7816252 ],\n       [  1.        , 161.12214252],\n       [  1.        , 150.19203532],\n       [  1.        , 166.52087851],\n       [  1.        , 171.56348969],\n       [  1.        , 182.30290681],\n       [  1.        , 182.02379849],\n       [  1.        , 166.12673183],\n       [  1.        , 166.97697249],\n       [  1.        , 159.51447035],\n       [  1.        , 155.79982063],\n       [  1.        , 152.93729809],\n       [  1.        , 189.50775395],\n       [  1.        , 164.90347818],\n       [  1.        , 165.61925698],\n       [  1.        , 157.4720464 ],\n       [  1.        , 177.77490356],\n       [  1.        , 153.86102152],\n       [  1.        , 167.8725972 ],\n       [  1.        , 161.04533439],\n       [  1.        , 173.86902498],\n       [  1.        , 164.89194862],\n       [  1.        , 158.19367816],\n       [  1.        , 169.71817772],\n       [  1.        , 174.28331871],\n       [  1.        , 170.66517222],\n       [  1.        , 173.02471898],\n       [  1.        , 163.65677906],\n       [  1.        , 166.37258834],\n       [  1.        , 163.27539552],\n       [  1.        , 166.40446838],\n       [  1.        , 161.86853718],\n       [  1.        , 152.73717398],\n       [  1.        , 171.77426142],\n       [  1.        , 165.98219064],\n       [  1.        , 153.69801653],\n       [  1.        , 174.62782256],\n       [  1.        , 160.92701636],\n       [  1.        , 170.51945396],\n       [  1.        , 177.29090562],\n       [  1.        , 171.28982911],\n       [  1.        , 181.39400685],\n       [  1.        , 157.6517418 ],\n       [  1.        , 174.02341641],\n       [  1.        , 163.15189909],\n       [  1.        , 161.29202851],\n       [  1.        , 164.21150335],\n       [  1.        , 166.88447468],\n       [  1.        , 170.56165342],\n       [  1.        , 158.34850159],\n       [  1.        , 179.00826487],\n       [  1.        , 174.6566244 ],\n       [  1.        , 154.63756314],\n       [  1.        , 184.88252194],\n       [  1.        , 188.95889176],\n       [  1.        , 181.78779571],\n       [  1.        , 168.20075164],\n       [  1.        , 159.29247378],\n       [  1.        , 180.54451727],\n       [  1.        , 165.96823053],\n       [  1.        , 182.2244507 ],\n       [  1.        , 172.08274978],\n       [  1.        , 179.76639036],\n       [  1.        , 173.56366397],\n       [  1.        , 177.06573168],\n       [  1.        , 170.10500021],\n       [  1.        , 187.85870494],\n       [  1.        , 171.26912093],\n       [  1.        , 174.01989363]])\n\n\nQue corresponde a lo que se denomina como matriz de dise√±o. Que es una matriz que contiene las variables independientes y una columna de unos que representa la intersecci√≥n. Podemos usar esta matriz para ajustar el modelo de regresi√≥n lineal simple por medio de la siguiente f√≥rmula:\n\\[Y = X\\beta + \\epsilon\\]\nY usando el m√©todo de m√≠nimos cuadrados para encontrar los valores de \\(\\beta\\) que minimizan la suma de los cuadrados de los errores, nos da la siguiente f√≥rmula:\n\\[\\beta = (X^TX)^{-1}X^TY\\]\nDonde:\n\n\\(Y\\) es el vector de la variable dependiente\n\\(X\\) es la matriz de dise√±o\n\\(\\beta\\) es el vector de coeficientes\n\nHagamos esto en Python.\n\n\nC√≥digo\n# Ajustar modelo\nX = np.column_stack((np.ones(len(altura)), altura))\n\nprint(X)\n\nbeta = np.linalg.inv(X.T @ X) @ X.T @ peso\n\n# Imprimir coeficientes\nprint(f'beta_0: {beta[0]}')\nprint(f'beta_1: {beta[1]}')\n\n\n[[  1.         187.64052346]\n [  1.         174.00157208]\n [  1.         179.78737984]\n [  1.         192.40893199]\n [  1.         188.6755799 ]\n [  1.         160.2272212 ]\n [  1.         179.50088418]\n [  1.         168.48642792]\n [  1.         168.96781148]\n [  1.         174.10598502]\n [  1.         171.44043571]\n [  1.         184.54273507]\n [  1.         177.61037725]\n [  1.         171.21675016]\n [  1.         174.43863233]\n [  1.         173.33674327]\n [  1.         184.94079073]\n [  1.         167.94841736]\n [  1.         173.13067702]\n [  1.         161.45904261]\n [  1.         144.47010184]\n [  1.         176.53618595]\n [  1.         178.64436199]\n [  1.         162.5783498 ]\n [  1.         192.69754624]\n [  1.         155.45634325]\n [  1.         170.45758517]\n [  1.         168.1281615 ]\n [  1.         185.32779214]\n [  1.         184.6935877 ]\n [  1.         171.54947426]\n [  1.         173.7816252 ]\n [  1.         161.12214252]\n [  1.         150.19203532]\n [  1.         166.52087851]\n [  1.         171.56348969]\n [  1.         182.30290681]\n [  1.         182.02379849]\n [  1.         166.12673183]\n [  1.         166.97697249]\n [  1.         159.51447035]\n [  1.         155.79982063]\n [  1.         152.93729809]\n [  1.         189.50775395]\n [  1.         164.90347818]\n [  1.         165.61925698]\n [  1.         157.4720464 ]\n [  1.         177.77490356]\n [  1.         153.86102152]\n [  1.         167.8725972 ]\n [  1.         161.04533439]\n [  1.         173.86902498]\n [  1.         164.89194862]\n [  1.         158.19367816]\n [  1.         169.71817772]\n [  1.         174.28331871]\n [  1.         170.66517222]\n [  1.         173.02471898]\n [  1.         163.65677906]\n [  1.         166.37258834]\n [  1.         163.27539552]\n [  1.         166.40446838]\n [  1.         161.86853718]\n [  1.         152.73717398]\n [  1.         171.77426142]\n [  1.         165.98219064]\n [  1.         153.69801653]\n [  1.         174.62782256]\n [  1.         160.92701636]\n [  1.         170.51945396]\n [  1.         177.29090562]\n [  1.         171.28982911]\n [  1.         181.39400685]\n [  1.         157.6517418 ]\n [  1.         174.02341641]\n [  1.         163.15189909]\n [  1.         161.29202851]\n [  1.         164.21150335]\n [  1.         166.88447468]\n [  1.         170.56165342]\n [  1.         158.34850159]\n [  1.         179.00826487]\n [  1.         174.6566244 ]\n [  1.         154.63756314]\n [  1.         184.88252194]\n [  1.         188.95889176]\n [  1.         181.78779571]\n [  1.         168.20075164]\n [  1.         159.29247378]\n [  1.         180.54451727]\n [  1.         165.96823053]\n [  1.         182.2244507 ]\n [  1.         172.08274978]\n [  1.         179.76639036]\n [  1.         173.56366397]\n [  1.         177.06573168]\n [  1.         170.10500021]\n [  1.         187.85870494]\n [  1.         171.26912093]\n [  1.         174.01989363]]\nbeta_0: 40.62639857381858\nbeta_1: 0.10734921677318345\n\n\n\nDemostraci√≥n de la F√≥rmula de M√≠nimos Cuadrados*\nTenemos el modelo de regresi√≥n lineal general:\n\\[Y = \\beta_0 + \\beta_1X + ... + \\beta_nX_n + \\epsilon\\]\nLa funci√≥n de costo que queremos minimizar es el error cuadr√°tico residual (RSS), que se define como:\n\\[RSS = \\sum_{i=1}^{n} (Y_i - \\hat{Y_i})^2\\]\nEn forma matricial, la funci√≥n de costo se puede expresar como:\n\\[RSS = (Y - X\\beta)^T(Y - X\\beta)\\]\nQue se conoce como la forma cuadr√°tica de la funci√≥n de costo. Para minimizar la funci√≥n de costo, tomamos la derivada de la funci√≥n de costo con respecto a \\(\\beta\\):\n\\[\\begin{align*}\n\n\\frac{\\partial RSS}{\\partial \\beta} & = \\frac{\\partial}{\\partial \\beta} (Y - X\\beta)^T(Y - X\\beta) \\\\\n& = \\frac{\\partial}{\\partial \\beta} (Y^TY - Y^TX\\beta - (X\\beta)^TY + (X\\beta)^TX\\beta) \\\\\n& = \\frac{\\partial}{\\partial \\beta} (Y^TY - Y^TX\\beta - \\beta^TX^TY + \\beta^TX^TX\\beta) \\\\\n& = \\frac{\\partial}{\\partial \\beta} Y^TY - \\frac{\\partial}{\\partial \\beta} Y^TX\\beta - \\frac{\\partial}{\\partial \\beta} \\beta^TX^TY + \\frac{\\partial}{\\partial \\beta} \\beta^TX^TX\\beta \\\\\n& = 0 - X^TY - X^TY + 2X^TX\\beta \\\\\n& = -2X^TY + 2X^TX\\beta \\\\\n& = 2X^T(X\\beta - Y) \\\\\n\\end{align*}\\]\nIgualamos la derivada de la funci√≥n de costo a cero para encontrar el m√≠nimo:\n\\[\\frac{\\partial RSS}{\\partial \\beta} = 0\\]\n\\[2X^T(X\\beta - Y) = 0\\]\nResolviendo para \\(\\beta\\):\n\\[\\begin{align*}\n2X^T(X\\beta - Y) & = 0 \\\\\nX^T(X\\beta - Y) & = 0 \\\\\nX^TX\\beta - X^TY & = 0 \\\\\nX^TX\\beta & = X^TY \\\\\n\\beta & = (X^TX)^{-1}X^TY \\\\\n\\end{align*}\\]",
    "crumbs": [
      "Manejo de Datos y Estad√≠stica con Python",
      "Modelos Lineales"
    ]
  },
  {
    "objectID": "statistics/Linear_models.html#regresi√≥n-lineal-simple-por-descenso-del-gradiente",
    "href": "statistics/Linear_models.html#regresi√≥n-lineal-simple-por-descenso-del-gradiente",
    "title": "Modelos Lineales",
    "section": "Regresi√≥n Lineal Simple por Descenso del Gradiente",
    "text": "Regresi√≥n Lineal Simple por Descenso del Gradiente\nOtra forma de ajustar un modelo de regresi√≥n lineal simple es mediante el descenso del gradiente. Este m√©todo consiste en ajustar los valores de \\(\\beta_0\\) y \\(\\beta_1\\) iterativamente para minimizar una funci√≥n de costo. La funci√≥n de costo que se utiliza en la regresi√≥n lineal simple es el error cuadr√°tico medio (MSE), que se define como:\n\\[MSE = \\frac{1}{n} \\sum_{i=1}^{n} (Y_i - \\hat{Y_i})^2\\]\nDonde:\n\n\\(Y_i\\) es el valor observado de la variable dependiente\n\\(\\hat{Y_i}\\) es el valor predicho de la variable dependiente\n\\(n\\) es el n√∫mero de observaciones\n\nEl descenso de gradiente utiliza la derivada de la funci√≥n de costo con respecto a los par√°metros \\(\\beta_0\\) y \\(\\beta_1\\) para ajustar los valores de los par√°metros en la direcci√≥n que minimiza la funci√≥n de costo. La regla de actualizaci√≥n de los par√°metros es la siguiente:\n\\[\\beta_0 = \\beta_0 - \\alpha \\frac{1}{n} \\sum_{i=1}^{n} (Y_i - \\hat{Y_i})\\]\n\\[\\beta_1 = \\beta_1 - \\alpha \\frac{1}{n} \\sum_{i=1}^{n} (Y_i -\\hat{Y_i})X_i\\]\nDonde:\n\n\\(\\alpha\\) es la tasa de aprendizaje\n\\(\\hat{Y_i}\\) es el valor predicho de la variable dependiente\n\\(Y_i\\) es el valor observado de la variable dependiente\n\\(X_i\\) es el valor de la variable independiente\n\\(n\\) es el n√∫mero de observaciones\n\\(\\alpha\\) es la tasa de aprendizaje que controla el tama√±o de los pasos de actualizaci√≥n de los par√°metros\n\n\nDerivaci√≥n de las Ecuaciones de Descenso del Gradiente*\nAqu√≠ est√° la demostraci√≥n de la f√≥rmula de actualizaci√≥n de los par√°metros en el descenso del gradiente para la regresi√≥n lineal simple.\nLa funci√≥n de costo para la regresi√≥n lineal simple es el error cuadr√°tico medio (MSE), que se define como:\n\\[MSE = \\frac{1}{n} \\sum_{i=1}^{n} (Y_i - \\hat{Y_i})^2\\]\nReemplazando \\(\\hat{Y_i}\\) con la ecuaci√≥n de regresi√≥n lineal simple, obtenemos:\n\\[MSE = \\frac{1}{n} \\sum_{i=1}^{n} (Y_i - \\beta_0 - \\beta_1X_i)^2\\]\nDerivamos respecto a \\(\\beta_0\\) y \\(\\beta_1\\) para obtener las derivadas parciales de la funci√≥n de costo:\n\\[\\frac{\\partial MSE}{\\partial \\beta_0} = \\frac{-2}{n} \\sum_{i=1}^{n} (Y_i - \\beta_0 - \\beta_1X_i)\\]\n\\[\\frac{\\partial MSE}{\\partial \\beta_1} = \\frac{-2}{n} \\sum_{i=1}^{n} X_i (Y_i - \\beta_0 - \\beta_1X_i)\\]\nUsamos las derivadas parciales para actualizar los par√°metros en la direcci√≥n que minimiza la funci√≥n de costo:\n\\[\\beta_0 = \\beta_0 - \\alpha \\frac{\\partial MSE}{\\partial \\beta_0}\\]\n\\[\\beta_1 = \\beta_1 - \\alpha \\frac{\\partial MSE}{\\partial \\beta_1}\\]\nReemplazando las derivadas parciales, obtenemos la f√≥rmula de actualizaci√≥n de los par√°metros en el descenso del gradiente para la regresi√≥n lineal simple:\n\\[\\beta_0 = \\beta_0 + \\alpha \\frac{2}{n} \\sum_{i=1}^{n} (Y_i - \\hat{Y_i})\\]\n\\[\\beta_1 = \\beta_1 + \\alpha \\frac{2}{n} \\sum_{i=1}^{n} X_i (Y _i - \\hat{Y_i})\\]\nEl vector de coeficientes \\(\\beta\\) se puede actualizar iterativamente hasta que se alcance un criterio de convergencia, como un n√∫mero m√°ximo de iteraciones o una tolerancia en el cambio de los par√°metros.\n\n\nImplementaci√≥n del Descenso del Gradiente\nVamos a implementar el descenso del gradiente para ajustar un modelo de regresi√≥n lineal simple.\n\n\nC√≥digo\n# Normalizaci√≥n de los datos\nX = (altura - np.mean(altura)) / np.std(altura)\nY = (peso - np.mean(peso)) / np.std(peso)\nn = len(X)\n\n# Valores iniciales de los par√°metros\nb0 = 0\nb1 = 0\n\n# Hiperpar√°metros\nalpha = 1e-3\nepochs = 10000\n\n# Descenso del gradiente\nfor i in range(epochs):\n    y_pred = b0 + b1 * X # Predicci√≥n\n\n    db0 = (-2/n) * sum(Y - y_pred) # Derivada parcial de b0\n    db1 = (-2/n) * sum(X * (Y - y_pred)) # Derivada parcial de b1\n\n    b0 = b0 - alpha * db0 # Actualizar b0\n    b1 = b1 - alpha * db1 # Actualizar b1\n\n    if i % 500 == 0: # Imprimir resultados cada 500 iteraciones\n        print(f\"Epoch {i}: b0 = {b0 * np.std(peso) + np.mean(peso) - b1 * np.mean(altura)}, b1 = {b1 * (np.std(peso) / np.std(altura))}\")\n\n# Desnormalizar los par√°metros\nb1 = b1 * (np.std(peso) / np.std(altura))\nb0 = b0 * np.std(peso) + np.mean(peso) - b1 * np.mean(altura)\n\n# Imprimir coeficientes\nprint(f\"Los valores √≥ptimos son: b0 = {b0}, b1 = {b1}\")\n\n\nEpoch 0: b0 = 58.86970065046024, b1 = 0.00021469843354638102\nEpoch 500: b0 = 36.69221818906457, b1 = 0.06797607549967058\nEpoch 1000: b0 = 28.541743780104426, b1 = 0.09287914421609095\nEpoch 1500: b0 = 25.546352702386315, b1 = 0.10203130224985668\nEpoch 2000: b0 = 24.44551276862618, b1 = 0.10539482333349699\nEpoch 2500: b0 = 24.040941703173104, b1 = 0.10663095518768421\nEpoch 3000: b0 = 23.89225728322957, b1 = 0.1070852475565854\nEpoch 3500: b0 = 23.83761408547845, b1 = 0.10725220511515218\nEpoch 4000: b0 = 23.817532095303484, b1 = 0.10731356389700908\nEpoch 4500: b0 = 23.81015173789428, b1 = 0.10733611393992575\nEpoch 5000: b0 = 23.8074393734815, b1 = 0.10734440133449522\nEpoch 5500: b0 = 23.80644254903254, b1 = 0.1073474470452729\nEpoch 6000: b0 = 23.806076204828443, b1 = 0.10734856637826272\nEpoch 6500: b0 = 23.80594156921029, b1 = 0.10734897774573438\nEpoch 7000: b0 = 23.80589208910532, b1 = 0.10734912892791008\nEpoch 7500: b0 = 23.805873904609804, b1 = 0.10734918448906133\nEpoch 8000: b0 = 23.805867221603073, b1 = 0.10734920490840964\nEpoch 8500: b0 = 23.805864765522912, b1 = 0.10734921241274988\nEpoch 9000: b0 = 23.80586386288578, b1 = 0.10734921517067947\nEpoch 9500: b0 = 23.805863531156447, b1 = 0.10734921618424971\nLos valores √≥ptimos son: b0 = 40.62639861081885, b1 = 0.1073492165563143\n\n\nLa normalizaci√≥n de los datos es importante para que el descenso del gradiente converja m√°s r√°pido. En este caso, normalizamos las variables independientes y dependientes restando la media y dividiendo por la desviaci√≥n est√°ndar. Despu√©s de ajustar el modelo, desnormalizamos los par√°metros para obtener los valores en la escala original.\nOtro factor importante es la tasa de aprendizaje \\(\\alpha\\), que controla el tama√±o de los pasos de actualizaci√≥n de los par√°metros. Si la tasa de aprendizaje es demasiado peque√±a, el algoritmo puede converger lentamente. Si es demasiado grande, el algoritmo puede divergir, encontrar la tasa de aprendizaje adecuada es crucial para el √©xito del descenso del gradiente y muchos algoritmos adaptativos ajustan autom√°ticamente la tasa de aprendizaje durante el entrenamiento para mejorar la convergencia.\nVeremos de nuevo el m√©todo de descenso del gradiente cuando hablemos de redes neuronales.",
    "crumbs": [
      "Manejo de Datos y Estad√≠stica con Python",
      "Modelos Lineales"
    ]
  },
  {
    "objectID": "statistics/Linear_models.html#regresi√≥n-lineal-m√∫ltiple-por-m√≠nimos-cuadrados",
    "href": "statistics/Linear_models.html#regresi√≥n-lineal-m√∫ltiple-por-m√≠nimos-cuadrados",
    "title": "Modelos Lineales",
    "section": "Regresi√≥n Lineal M√∫ltiple por M√≠nimos Cuadrados",
    "text": "Regresi√≥n Lineal M√∫ltiple por M√≠nimos Cuadrados\nDebido a que ahora tratamos con m√∫ltiples variables independientes, la f√≥rmula para calcular los valores de \\(\\beta_0, \\beta_1, \\beta_2, ..., \\beta_n\\) esta en forma matricial:\n\\[\\beta = (X^TX)^{-1}X^TY\\]\nQu√© es id√©nctico a la f√≥rmula de la regresi√≥n lineal simple, solo que ahora \\(X\\) es una matriz que contiene las variables independientes y una columna de unos que representa la intersecci√≥n.\nUsemos datos de ejemplo para ajustar un modelo de regresi√≥n lineal m√∫ltiple y predecir la variable dependiente. Generaremos datos de 5 variables independientes y una variable dependiente.\n\n\nC√≥digo\n# Crear datos\nnp.random.seed(1014)\n\n# Variables independientes\nX1 = np.random.normal(0, 1, 100)\nX2 = np.random.normal(10, 5, 100)\nX3 = np.random.normal(-5, 2, 100)\nX4 = np.random.normal(3, 1, 100)\nX5 = np.random.normal(2, 0.5, 100)\n\n# Efecto de cada variable independiente\nbetas = np.array([5, 10, 3, -2, -1, 4])\n\n# Error\nepsilon = np.random.normal(0, 2.5, 100)\n\n# Variable dependiente\nY = betas[0] + betas[1] * X1 + betas[2] * X2 + betas[3] * X3 + betas[4] * X4 + betas[5] * X5 + epsilon\n\ndf = pd.DataFrame({'X1': X1, 'X2': X2, 'X3': X3, 'X4': X4, 'X5': X5, 'Y': Y})\n\ndf.head()\n\n\n\n\n\n\n\n\n\n\nX1\nX2\nX3\nX4\nX5\nY\n\n\n\n\n0\n0.759433\n10.731036\n-6.699854\n2.615701\n1.670699\n61.504776\n\n\n1\n-1.007260\n16.029547\n-3.969604\n1.957694\n2.076248\n55.376552\n\n\n2\n-0.644990\n10.329352\n-7.744539\n2.040599\n2.300200\n52.803668\n\n\n3\n-0.266741\n14.039842\n-7.208872\n3.020797\n2.237179\n62.968653\n\n\n4\n0.291256\n13.169584\n-5.827498\n3.217659\n1.341268\n61.591722\n\n\n\n\n\n\n\n\nAhora ajustaremos un modelo de regresi√≥n lineal m√∫ltiple a los datos y obtendremos un resumen de los resultados.\n\n\nC√≥digo\n# Ajustar modelo\nX = sm.add_constant(df[['X1', 'X2', 'X3', 'X4', 'X5']])\nmodel = sm.OLS(df['Y'], X).fit()\n\n# Imprimir resumen\nprint(model.summary())\n\n\n                            OLS Regression Results                            \n==============================================================================\nDep. Variable:                      Y   R-squared:                       0.976\nModel:                            OLS   Adj. R-squared:                  0.975\nMethod:                 Least Squares   F-statistic:                     758.3\nDate:                Mon, 17 Jun 2024   Prob (F-statistic):           2.63e-74\nTime:                        20:15:17   Log-Likelihood:                -243.14\nNo. Observations:                 100   AIC:                             498.3\nDf Residuals:                      94   BIC:                             513.9\nDf Model:                           5                                         \nCovariance Type:            nonrobust                                         \n==============================================================================\n                 coef    std err          t      P&gt;|t|      [0.025      0.975]\n------------------------------------------------------------------------------\nconst          5.4953      1.737      3.165      0.002       2.047       8.943\nX1             9.9913      0.310     32.255      0.000       9.376      10.606\nX2             2.8923      0.058     49.999      0.000       2.777       3.007\nX3            -1.9544      0.142    -13.789      0.000      -2.236      -1.673\nX4            -0.7991      0.281     -2.843      0.005      -1.357      -0.241\nX5             4.0200      0.613      6.553      0.000       2.802       5.238\n==============================================================================\nOmnibus:                        2.713   Durbin-Watson:                   2.227\nProb(Omnibus):                  0.258   Jarque-Bera (JB):                1.890\nSkew:                           0.134   Prob(JB):                        0.389\nKurtosis:                       2.383   Cond. No.                         73.8\n==============================================================================\n\nNotes:\n[1] Standard Errors assume that the covariance matrix of the errors is correctly specified.\n\n\nPodemos imprimir los coeficientes del modelo para ver c√≥mo se relacionan con los valores reales.\n\n\nC√≥digo\n# Imprimir coeficientes\nprint(f'Intercepto: {model.params[0]}')\nprint(f'Coeficientes: {model.params[1:]}')\n\n\nIntercepto: 5.495327623636475\nCoeficientes: X1    9.991312\nX2    2.892250\nX3   -1.954408\nX4   -0.799148\nX5    4.020035\ndtype: float64\n\n\n/tmp/ipykernel_95662/3979803380.py:2: FutureWarning:\n\nSeries.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`\n\n\n\nEl resumen del modelo nos proporciona informaci√≥n sobre la calidad del ajuste, los coeficientes de las variables independientes, los errores est√°ndar de los coeficientes, los valores p, el coeficiente de determinaci√≥n \\(R^2\\), entre otros.\nGr√°fiquemos los par√°metros estimados y los valores reales.\n\n\nC√≥digo\n# Graficar par√°metros estimados y valores reales\nplt.figure(figsize=(10, 6))\nplt.plot(betas, label='Real', marker='o', markersize=10)\nplt.plot(model.params, label='Estimado', marker='x', markersize=10)\nplt.xlabel('Variables', fontsize=14)\nplt.ylabel('Coeficientes', fontsize=14)\nplt.title('Coeficientes Estimados vs. Coeficientes Reales', fontsize=16, fontweight='bold')\nplt.legend()\nplt.show()\n\n\n\n\n\n\n\n\n\nLa paqueter√≠a statsmodels es muy completa y nos permite ajustar modelos de regresi√≥n lineal m√∫ltiple con facilidad. Tambi√©n podemos usar la funci√≥n ols de statsmodels.formula.api para ajustar modelos de regresi√≥n lineal m√∫ltiple con f√≥rmulas de estilo R.\n\n\nC√≥digo\nimport statsmodels.formula.api as smf\n\n# Ajustar modelo\nmodel = smf.ols('Y ~ X1 + X2 + X3 + X4 + X5', data=df).fit()\n\n# Imprimir resumen\nprint(model.summary())\n\n\n                            OLS Regression Results                            \n==============================================================================\nDep. Variable:                      Y   R-squared:                       0.976\nModel:                            OLS   Adj. R-squared:                  0.975\nMethod:                 Least Squares   F-statistic:                     758.3\nDate:                Mon, 17 Jun 2024   Prob (F-statistic):           2.63e-74\nTime:                        20:15:18   Log-Likelihood:                -243.14\nNo. Observations:                 100   AIC:                             498.3\nDf Residuals:                      94   BIC:                             513.9\nDf Model:                           5                                         \nCovariance Type:            nonrobust                                         \n==============================================================================\n                 coef    std err          t      P&gt;|t|      [0.025      0.975]\n------------------------------------------------------------------------------\nIntercept      5.4953      1.737      3.165      0.002       2.047       8.943\nX1             9.9913      0.310     32.255      0.000       9.376      10.606\nX2             2.8923      0.058     49.999      0.000       2.777       3.007\nX3            -1.9544      0.142    -13.789      0.000      -2.236      -1.673\nX4            -0.7991      0.281     -2.843      0.005      -1.357      -0.241\nX5             4.0200      0.613      6.553      0.000       2.802       5.238\n==============================================================================\nOmnibus:                        2.713   Durbin-Watson:                   2.227\nProb(Omnibus):                  0.258   Jarque-Bera (JB):                1.890\nSkew:                           0.134   Prob(JB):                        0.389\nKurtosis:                       2.383   Cond. No.                         73.8\n==============================================================================\n\nNotes:\n[1] Standard Errors assume that the covariance matrix of the errors is correctly specified.\n\n\nDos resultados importantes del resumen es la prueba Durbin-Watson y la prueba de Jarque-Bera. La prueba Durbin-Watson se utiliza para detectar la presencia de autocorrelaci√≥n en los residuos del modelo. Un valor de Durbin-Watson cercano a 2 indica que no hay autocorrelaci√≥n. La prueba de Jarque-Bera se utiliza para detectar la normalidad de los residuos del modelo. Un valor de Jarque-Bera cercano a 0 indica que los residuos son normales.\nDetectar la presencia de autocorrelaci√≥n y no normalidad en los residuos es importante para evaluar la calidad del ajuste del modelo y tomar decisiones informadas sobre su uso. Si se obtienen resultados significativos en estas pruebas, es posible que sea necesario realizar ajustes adicionales al modelo para mejorar su rendimiento.",
    "crumbs": [
      "Manejo de Datos y Estad√≠stica con Python",
      "Modelos Lineales"
    ]
  },
  {
    "objectID": "statistics/Linear_models.html#gr√°fico-q-q",
    "href": "statistics/Linear_models.html#gr√°fico-q-q",
    "title": "Modelos Lineales",
    "section": "Gr√°fico Q-Q",
    "text": "Gr√°fico Q-Q\nEl gr√°fico Q-Q (quantile-quantile) es una forma visual de evaluar si una muestra de datos proviene de una distribuci√≥n normal. En un gr√°fico Q-Q, los cuantiles de la muestra se comparan con los cuantiles de una distribuci√≥n normal te√≥rica. Si los puntos en el gr√°fico Q-Q siguen una l√≠nea recta, entonces los datos se ajustan a una distribuci√≥n normal. Evidentemente, si los puntos se alejan de la l√≠nea recta, entonces los datos no se ajustan a una distribuci√≥n normal.\nVamos a generar datos de una distribuci√≥n normal y una distribuci√≥n no normal para comparar los gr√°ficos Q-Q.\n\n\nC√≥digo\n# Datos de una distribuci√≥n normal\nnp.random.seed(0)\nnormal_data = np.random.normal(0, 1, 1000)\n\n# Datos de una distribuci√≥n no normal\nnon_normal_data = np.random.exponential(1, 1000)\n\n# Gr√°fico Q-Q\nfig, ax = plt.subplots(1, 2, figsize=(10, 6))\n\n# Distribuci√≥n normal\nax[0].set_title('Distribuci√≥n Normal')\nsm.qqplot(normal_data, line='s', ax=ax[0])\nax[0].set_aspect('equal')\nax[0].set_xlabel('Cuantiles Te√≥ricos')\nax[0].set_ylabel('Cuantiles de los Datos')\n\n# Distribuci√≥n no normal\nax[1].set_title('Distribuci√≥n No Normal')\nsm.qqplot(non_normal_data, line='s', ax=ax[1])\nax[1].set_aspect('equal')\nax[1].set_xlabel('Cuantiles Te√≥ricos')\nax[1].set_ylabel('Cuantiles de los Datos')\n\nplt.show()\n\n\n\n\n\n\n\n\n\nEn el gr√°fico Q-Q de la distribuci√≥n normal, los puntos siguen una l√≠nea recta, lo que indica que los datos se ajustan a una distribuci√≥n normal. En el gr√°fico Q-Q de la distribuci√≥n no normal, los puntos se alejan de la l√≠nea recta, lo que indica que los datos no se ajustan a una distribuci√≥n normal.",
    "crumbs": [
      "Manejo de Datos y Estad√≠stica con Python",
      "Modelos Lineales"
    ]
  },
  {
    "objectID": "statistics/Linear_models.html#prueba-de-shapiro-wilk",
    "href": "statistics/Linear_models.html#prueba-de-shapiro-wilk",
    "title": "Modelos Lineales",
    "section": "Prueba de Shapiro-Wilk",
    "text": "Prueba de Shapiro-Wilk\nLa prueba de Shapiro-Wilk es una prueba estad√≠stica que se utiliza para determinar si una muestra de datos proviene de una distribuci√≥n normal.\nHip√≥tesis:\n\n\\(H_0\\): Los datos provienen de una distribuci√≥n normal\n\\(H_1\\): Los datos no provienen de una distribuci√≥n normal\n\nVamos a aplicar la prueba de Shapiro-Wilk a los datos de las distribuciones normal y no normal.\n\n\nC√≥digo\nfrom scipy.stats import shapiro\n\n# Prueba de Shapiro-Wilk\nstat, p = shapiro(normal_data)\nprint(f'Distribuci√≥n Normal: Estad√≠stico = {stat}, p-valor = {p}')\n\nstat, p = shapiro(non_normal_data)\nprint(f'Distribuci√≥n No Normal: Estad√≠stico = {stat}, p-valor = {p}')\n\n\nDistribuci√≥n Normal: Estad√≠stico = 0.9985554728235057, p-valor = 0.5912267898687746\nDistribuci√≥n No Normal: Estad√≠stico = 0.8336406754912049, p-valor = 5.034540538267324e-31\n\n\nEl valor p de los datos normales fue de \\(0.5912267898687746\\) y el valor p de los datos no normales fue de \\(5.034540538267324e-31\\). Por lo que podemos rechazar la hip√≥tesis nula en el segundo caso.",
    "crumbs": [
      "Manejo de Datos y Estad√≠stica con Python",
      "Modelos Lineales"
    ]
  },
  {
    "objectID": "LICENSE.html",
    "href": "LICENSE.html",
    "title": "",
    "section": "",
    "text": "Ver c√≥digo\n\n\n\n\nMIT License\nCopyright (c) 2024 Christian Francisco Badillo Hern√°ndez\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the ‚ÄúSoftware‚Äù), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\nTHE SOFTWARE IS PROVIDED ‚ÄúAS IS‚Äù, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n Volver arriba"
  },
  {
    "objectID": "intro_python/Variables.html",
    "href": "intro_python/Variables.html",
    "title": "Declaraci√≥n de Variables y Operaciones",
    "section": "",
    "text": "En Python utilizamos variables para almacenar informaci√≥n en la memoria de la computadora. Las variables son como cajas en las que podemos guardar informaci√≥n, cada caja tiene un nombre y un contenido. Existen varias reglas para dar nombre a las variables en Python:\n\nEl nombre debe comenzar con una letra o un gui√≥n bajo.\nNo puede comenzar con un n√∫mero.\nPuede contener letras, n√∫meros y guiones bajos.\n\nEl proceso de crear (dar valor) a una variable se conoce como declaraci√≥n de variables y es sensible a may√∫sculas y min√∫sculas. Esto significa que si declaramos las variables nombre, Nombre y NOMBRE ser√°n diferentes.\n\n\nC√≥digo\nnombre = \"Christian\"\nNombre = \"Jimena\"\nNOMBRE = \"Luis\"\n\nprint(nombre == Nombre)\nprint(Nombre == NOMBRE)\nprint(NOMBRE == nombre)\n\n\nFalse\nFalse\nFalse\n\n\nPor lo cual podemos ver que las variables nombre, Nombre y NOMBRE son diferentes, pues al realizar la comparaci√≥n entre ellas, el resultado es False, tambi√©n podemos observar la forma de declarar variables en Python, la cual es nombre_variable = valor_variable.\nPodemos sobrescribir el contenido de una variable en cualquier momento.\n\n\nC√≥digo\nprint(nombre)\nnombre = \"Cesar\"\nprint(nombre)\n\n\nChristian\nCesar\n\n\nEn el ejemplo anterior, hemos cambiado el contenido de la variable nombre de ‚ÄúChristian‚Äù a ‚ÄúCesar‚Äù. En Python, podemos asignar cualquier tipo de dato a una variable. Los tipos de datos m√°s comunes en Python son:\n\nint: N√∫meros enteros.\nfloat: N√∫meros decimales.\nstr: Cadenas de texto.\nbool: Valores booleanos (verdadero o falso).\nlist: Listas de elementos.\ntuple: Tuplas de elementos.\ndict: Diccionarios de elementos.\n\n\n\n\n\nLos n√∫meros enteros son n√∫meros que no tienen parte decimal. En Python, podemos declarar un n√∫mero entero de la siguiente manera:\n\n\nC√≥digo\nnumero_entero = 10\nprint(numero_entero)\n\n\n10\n\n\nOtra forma de declarar un n√∫mero entero es utilizando la funci√≥n int() para convertir un n√∫mero decimal o un booleano a un n√∫mero entero. Veamos un ejemplo:\n\n\nC√≥digo\nnumero_entero = int(10.5)\nprint(numero_entero)\nnumero_entero = int(10.6)\nprint(numero_entero)\n\nnumero_entero = int(True)\nprint(numero_entero)\n\n\n10\n10\n1\n\n\nLos n√∫meros decimales son n√∫meros que tienen parte decimal. En Python, podemos declarar un n√∫mero decimal de la siguiente manera:\n\n\nC√≥digo\nnumero_decimal = 10.5\nprint(numero_decimal)\n\n\n10.5\n\n\nOtra forma de declarar un n√∫mero decimal es utilizando la funci√≥n float() para convertir un n√∫mero entero o un booleano a un n√∫mero decimal.\n\n\nC√≥digo\nnumero_decimal = float(10)\nprint(numero_decimal)\n\nnumero_decimal = float(True)\nprint(numero_decimal)\n\n\n10.0\n1.0\n\n\nIgualmente podemos utilizar la nota cient√≠fica para declarar un n√∫mero decimal en Python con la letra e seguida de un n√∫mero entero por ejemplo, 22e10 es equivalente a \\(22 * 10^10\\). En c√≥digo:\n\n\nC√≥digo\nnumero_decimal = 1.5e2\nprint(numero_decimal)\n\nnumero_decimal = 1.5e-2\nprint(numero_decimal)\n\n\n150.0\n0.015\n\n\n\n\n\nLas cadenas de texto son una secuencia de car√°cteres (letras, n√∫meros y s√≠mbolos). En Python, se pueden declarar cadenas de texto utilizando comillas simples ' o comillas dobles \". Veamos un ejemplo:\n\n\nC√≥digo\ncadena_texto = \"Hola Mundo\"\nprint(cadena_texto)\n\n\nHola Mundo\n\n\nOtra forma de declarar una cadena de texto es utilizando la funci√≥n str() para convertir un n√∫mero entero, decimal o booleano a una cadena de texto. Tambi√©n podemos combinar las comillas simples y dobles para poder usar una o la otra dentro de la cadena de texto. Por ejemplo:\n\n\nC√≥digo\ntexto= 'No te procupes, solo es un \"amigo\" / \"amiga\"'\nprint(texto)\n\n\nNo te procupes, solo es un \"amigo\" / \"amiga\"\n\n\nTamb√©n podemos imprimir saltos de l√≠nea (\\n), tabulaciones (\\t) y caracteres especiales en una cadena de texto. Por ejemplo:\n\n\nC√≥digo\ntexto = \"Las rosas son rojas,\\nLas violetas son azules,\\nViva el team frio,\\nQuiero un pan \\U0001F35E\\n\"\n\nprint(texto)\n\ntexto = \"\\n\\t Aqui no se habla\\n\\tdel formato APA\\n\\tNo, no, no ü´†\"\n\nprint(texto)\n\n\nLas rosas son rojas,\nLas violetas son azules,\nViva el team frio,\nQuiero un pan üçû\n\n\n     Aqui no se habla\n    del formato APA\n    No, no, no ü´†\n\n\n\n\n\nLos valores booleanos son valores l√≥gicos que pueden ser True (verdadero) o False (falso). En Python, podemos declarar un valor booleano de la siguiente manera:\n\n\nC√≥digo\nvalor_booleano = True\nprint(valor_booleano)\n\n\nTrue\n\n\nIgualmente existe la funci√≥n bool() pero su uso es poco utilizado, ya que los valores booleanos se utilizan principalmente en condicionales y bucles, adem√°s es necesario conocer que cosas se consideran True y False en Python.\n\n\nC√≥digo\nvalor_booleano = bool(0)\nprint(valor_booleano)\nvalor_booleano = bool(1)\nprint(valor_booleano)\n\nvalor_booleano = bool([])\nprint(valor_booleano)\nvalor_booleano = bool([1, 2, 3])\nprint(valor_booleano)\n\n\nFalse\nTrue\nFalse\nTrue\n\n\nSi recuerdan sus clases de L√≥gica, podr√°n crear una tabla de verdad para evaluar proposiciones l√≥gicas en Python.\n\n\n\nLa documentaci√≥n de c√≥digo es una pr√°ctica com√∫n en programaci√≥n y una buena costumbre para escribir c√≥digo limpio y legible. En Python, podemos documentar nuestro c√≥digo utilizando comentarios.\nLos comentarios son l√≠neas de c√≥digo que no se ejecutan y se utilizan para explicar el c√≥digo. En Python, los comentarios se crean utilizando el s√≠mbolo # y cualquier texto que se escriba despu√©s de este s√≠mbolo se considera un comentario y no se ejecuta.\n\n\nC√≥digo\n# Esto es un comentario\nprint(\"Hola Mundo\") # Aqu√≠ podemos comentar que hace esta l√≠nea de c√≥digo\n\n\nHola Mundo\n\n\nTambi√©n podemos crear comentarios multil√≠nea utilizando tres comillas simples ''' o tres comillas dobles \"\"\", se utiliza mucho esta forma de comentar para documentar funciones o clases, como lo veremos m√°s adelante.\n\n\n\nEn el siguiente bloque podr√°n ejecutar c√≥digo de Python usando su navegador web. Igualmente pueden hacerlo en su computadora o en la nube utilizando Google Colab o Kaggle. Para cada ejercicio deber de escribir su propio c√≥digo, crear un comentario con sus datos, crear su soluci√≥n y tomar una captura de pantalla del resultado. Finalmente, subir la captura a la asignaci√≥n correspondiente en Google Classroom.\n\nDeclarar una variable de cada tipo de dato en Python (entero, decimal, cadena de texto y booleano) e imprimir su valor.\nDeclarar una variable con el nombre poema y asignarle un poema de su elecci√≥n. Imprimir el poema en la consola con el formato adecuado. (Pueden utilizar emojis si lo desean).\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.",
    "crumbs": [
      "Fundamentos de Python",
      "Declaraci√≥n de Variables y Operaciones"
    ]
  },
  {
    "objectID": "intro_python/Variables.html#tipos-de-variables",
    "href": "intro_python/Variables.html#tipos-de-variables",
    "title": "Declaraci√≥n de Variables y Operaciones",
    "section": "",
    "text": "Los n√∫meros enteros son n√∫meros que no tienen parte decimal. En Python, podemos declarar un n√∫mero entero de la siguiente manera:\n\n\nC√≥digo\nnumero_entero = 10\nprint(numero_entero)\n\n\n10\n\n\nOtra forma de declarar un n√∫mero entero es utilizando la funci√≥n int() para convertir un n√∫mero decimal o un booleano a un n√∫mero entero. Veamos un ejemplo:\n\n\nC√≥digo\nnumero_entero = int(10.5)\nprint(numero_entero)\nnumero_entero = int(10.6)\nprint(numero_entero)\n\nnumero_entero = int(True)\nprint(numero_entero)\n\n\n10\n10\n1\n\n\nLos n√∫meros decimales son n√∫meros que tienen parte decimal. En Python, podemos declarar un n√∫mero decimal de la siguiente manera:\n\n\nC√≥digo\nnumero_decimal = 10.5\nprint(numero_decimal)\n\n\n10.5\n\n\nOtra forma de declarar un n√∫mero decimal es utilizando la funci√≥n float() para convertir un n√∫mero entero o un booleano a un n√∫mero decimal.\n\n\nC√≥digo\nnumero_decimal = float(10)\nprint(numero_decimal)\n\nnumero_decimal = float(True)\nprint(numero_decimal)\n\n\n10.0\n1.0\n\n\nIgualmente podemos utilizar la nota cient√≠fica para declarar un n√∫mero decimal en Python con la letra e seguida de un n√∫mero entero por ejemplo, 22e10 es equivalente a \\(22 * 10^10\\). En c√≥digo:\n\n\nC√≥digo\nnumero_decimal = 1.5e2\nprint(numero_decimal)\n\nnumero_decimal = 1.5e-2\nprint(numero_decimal)\n\n\n150.0\n0.015\n\n\n\n\n\nLas cadenas de texto son una secuencia de car√°cteres (letras, n√∫meros y s√≠mbolos). En Python, se pueden declarar cadenas de texto utilizando comillas simples ' o comillas dobles \". Veamos un ejemplo:\n\n\nC√≥digo\ncadena_texto = \"Hola Mundo\"\nprint(cadena_texto)\n\n\nHola Mundo\n\n\nOtra forma de declarar una cadena de texto es utilizando la funci√≥n str() para convertir un n√∫mero entero, decimal o booleano a una cadena de texto. Tambi√©n podemos combinar las comillas simples y dobles para poder usar una o la otra dentro de la cadena de texto. Por ejemplo:\n\n\nC√≥digo\ntexto= 'No te procupes, solo es un \"amigo\" / \"amiga\"'\nprint(texto)\n\n\nNo te procupes, solo es un \"amigo\" / \"amiga\"\n\n\nTamb√©n podemos imprimir saltos de l√≠nea (\\n), tabulaciones (\\t) y caracteres especiales en una cadena de texto. Por ejemplo:\n\n\nC√≥digo\ntexto = \"Las rosas son rojas,\\nLas violetas son azules,\\nViva el team frio,\\nQuiero un pan \\U0001F35E\\n\"\n\nprint(texto)\n\ntexto = \"\\n\\t Aqui no se habla\\n\\tdel formato APA\\n\\tNo, no, no ü´†\"\n\nprint(texto)\n\n\nLas rosas son rojas,\nLas violetas son azules,\nViva el team frio,\nQuiero un pan üçû\n\n\n     Aqui no se habla\n    del formato APA\n    No, no, no ü´†\n\n\n\n\n\nLos valores booleanos son valores l√≥gicos que pueden ser True (verdadero) o False (falso). En Python, podemos declarar un valor booleano de la siguiente manera:\n\n\nC√≥digo\nvalor_booleano = True\nprint(valor_booleano)\n\n\nTrue\n\n\nIgualmente existe la funci√≥n bool() pero su uso es poco utilizado, ya que los valores booleanos se utilizan principalmente en condicionales y bucles, adem√°s es necesario conocer que cosas se consideran True y False en Python.\n\n\nC√≥digo\nvalor_booleano = bool(0)\nprint(valor_booleano)\nvalor_booleano = bool(1)\nprint(valor_booleano)\n\nvalor_booleano = bool([])\nprint(valor_booleano)\nvalor_booleano = bool([1, 2, 3])\nprint(valor_booleano)\n\n\nFalse\nTrue\nFalse\nTrue\n\n\nSi recuerdan sus clases de L√≥gica, podr√°n crear una tabla de verdad para evaluar proposiciones l√≥gicas en Python.\n\n\n\nLa documentaci√≥n de c√≥digo es una pr√°ctica com√∫n en programaci√≥n y una buena costumbre para escribir c√≥digo limpio y legible. En Python, podemos documentar nuestro c√≥digo utilizando comentarios.\nLos comentarios son l√≠neas de c√≥digo que no se ejecutan y se utilizan para explicar el c√≥digo. En Python, los comentarios se crean utilizando el s√≠mbolo # y cualquier texto que se escriba despu√©s de este s√≠mbolo se considera un comentario y no se ejecuta.\n\n\nC√≥digo\n# Esto es un comentario\nprint(\"Hola Mundo\") # Aqu√≠ podemos comentar que hace esta l√≠nea de c√≥digo\n\n\nHola Mundo\n\n\nTambi√©n podemos crear comentarios multil√≠nea utilizando tres comillas simples ''' o tres comillas dobles \"\"\", se utiliza mucho esta forma de comentar para documentar funciones o clases, como lo veremos m√°s adelante.\n\n\n\nEn el siguiente bloque podr√°n ejecutar c√≥digo de Python usando su navegador web. Igualmente pueden hacerlo en su computadora o en la nube utilizando Google Colab o Kaggle. Para cada ejercicio deber de escribir su propio c√≥digo, crear un comentario con sus datos, crear su soluci√≥n y tomar una captura de pantalla del resultado. Finalmente, subir la captura a la asignaci√≥n correspondiente en Google Classroom.\n\nDeclarar una variable de cada tipo de dato en Python (entero, decimal, cadena de texto y booleano) e imprimir su valor.\nDeclarar una variable con el nombre poema y asignarle un poema de su elecci√≥n. Imprimir el poema en la consola con el formato adecuado. (Pueden utilizar emojis si lo desean).\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.",
    "crumbs": [
      "Fundamentos de Python",
      "Declaraci√≥n de Variables y Operaciones"
    ]
  },
  {
    "objectID": "intro_python/Variables.html#operaciones-aritm√©ticas",
    "href": "intro_python/Variables.html#operaciones-aritm√©ticas",
    "title": "Declaraci√≥n de Variables y Operaciones",
    "section": "Operaciones aritm√©ticas",
    "text": "Operaciones aritm√©ticas\nLas operaciones aritm√©ticas son operaciones matem√°ticas que se realizan con n√∫meros. En Python, podemos realizar operaciones aritm√©ticas con variables de tipo entero y decimal, como si fuese una calculadora.\n\n\nC√≥digo\nfrom math import sqrt\n# Sumemos dos numeros\nnumero1 = 10\nnumero2 = 5\n\nsuma = numero1 + numero2 # 10 + 5 = 15\nprint(suma)\n\n# Restemos dos numeros\nresta = numero1 - numero2 # 10 - 5 = 5\nprint(resta)\n\n# Multipliquemos dos numeros\nmultiplicacion = numero1 * numero2 # 10 * 5 = 50\nprint(multiplicacion)\n\n# Dividamos dos numeros\ndivision = numero1 / numero2 # 10 / 5 = 2.0\nprint(division)\n\n# Dividamos y solo tomemos la parte entera\ndivision_entera = numero1 // numero2 # 10 // 5 = 2\nprint(division_entera)\n\n# Calculemos el residuo de la divisi√≥n\nmodulo = numero1 % numero2 # 10 % 5 = 0\nprint(modulo)\n\n# Elevemos un numero a una potencia\npotencia = numero1 ** numero2 # 10 ^ 5 = 100000\nprint(potencia)\n\n# Calculemos la raiz cuadrada de un numero\nraiz_cuadrada = numero1 ** 0.5 # sqrt(10) = 3.1622776601683795\nraiz_cuadrada2 = sqrt(numero2) # sqrt(5) = 2.23606797749979\nprint(raiz_cuadrada)\nprint(raiz_cuadrada2)\n\n\n15\n5\n50\n2.0\n2\n0\n100000\n3.1622776601683795\n2.23606797749979",
    "crumbs": [
      "Fundamentos de Python",
      "Declaraci√≥n de Variables y Operaciones"
    ]
  },
  {
    "objectID": "intro_python/Variables.html#operaciones-de-comparaci√≥n",
    "href": "intro_python/Variables.html#operaciones-de-comparaci√≥n",
    "title": "Declaraci√≥n de Variables y Operaciones",
    "section": "Operaciones de comparaci√≥n",
    "text": "Operaciones de comparaci√≥n\nLas operaciones de comparaci√≥n son operaciones que se utilizan para comparar dos valores y devuelven un valor booleano (True o False).\n\n\nC√≥digo\n# Comparar si dos numeros son iguales\nnumero1 = 148\nnumero2 = 47\n\ncomparacion = numero1 == numero2\nprint(comparacion)\n\n# Comparar si dos numeros son diferentes\ncomparacion = numero1 != numero2\nprint(comparacion)\n\n# Comparar si un numero es mayor que otro\ncomparacion = numero1 &gt; numero2\nprint(comparacion)\n\n# Comparar si un numero es menor que otro\ncomparacion = numero1 &lt; numero2\nprint(comparacion)\n\n# Comparar si un numero es mayor o igual que otro\ncomparacion = numero1 &gt;= numero2\nprint(comparacion)\n\n# Comparar si un numero es menor o igual que otro\ncomparacion = numero1 &lt;= numero2\nprint(comparacion)\n\n\nFalse\nTrue\nTrue\nFalse\nTrue\nFalse",
    "crumbs": [
      "Fundamentos de Python",
      "Declaraci√≥n de Variables y Operaciones"
    ]
  },
  {
    "objectID": "intro_python/Variables.html#operaciones-con-cadenas-de-texto",
    "href": "intro_python/Variables.html#operaciones-con-cadenas-de-texto",
    "title": "Declaraci√≥n de Variables y Operaciones",
    "section": "Operaciones con cadenas de texto",
    "text": "Operaciones con cadenas de texto\nLas operaciones con cadenas de texto son operaciones que se utilizan para concatenar, multiplicar y comparar cadenas de texto. Se utilizan principalmente para manipular texto en Python.\nPara concatenar dos cadenas de texto, simplemente se utilizan el operador +.\n\n\nC√≥digo\n# Concatenar dos cadenas de texto\ncadena1 = \"Hola\"\ncadena2 = \"Mundo\"\n\nconcatenacion = cadena1 + \" \" + cadena2\nprint(concatenacion)\n\n\nHola Mundo\n\n\nPara multiplicar una cadena de texto por un n√∫mero entero, simplemente se utiliza el operador *.\n\n\nC√≥digo\n# Multiplicar una cadena de texto\ncadena = \"Me gusta programar en Python\\n\"\n\nmultiplicacion = cadena * 5\nprint(multiplicacion)\n\n\nMe gusta programar en Python\nMe gusta programar en Python\nMe gusta programar en Python\nMe gusta programar en Python\nMe gusta programar en Python\n\n\n\nPara comparar dos cadenas de texto, simplemente se utilizan los operadores de comparaci√≥n.\n\n\nC√≥digo\n# Comparar dos cadenas de texto\ncadena1 = \"Muchas gracias\"\ncadena2 = \"De nada\"\n\ncomparacion = cadena1 == cadena2 # Comparar si dos cadenas son iguales\nprint(comparacion)\n\ncomparacion = cadena1 != cadena2 # Comparar si dos cadenas son diferentes\nprint(comparacion)\n\ncomparacion = cadena1 &gt; cadena2 # Comparar si una cadena tiene m√°s caracteres que otra\nprint(comparacion)\n\ncomparacion = cadena1 &lt; cadena2 # Comparar si una cadena tiene menos caracteres que otra\nprint(comparacion)\n\ncomparacion = cadena1 &gt;= cadena2 # Comparar si una cadena tiene m√°s o igual cantidad de caracteres que otra\nprint(comparacion)\n\ncomparacion = cadena1 &lt;= cadena2 # Comparar si una cadena tiene menos o igual cantidad de caracteres que otra\nprint(comparacion)\n\n\nFalse\nTrue\nTrue\nFalse\nTrue\nFalse\n\n\n\nEjercicios 1.2\n\n Instrucciones \n\nEn el siguiente bloque podr√°n ejecutar c√≥digo de Python usando su navegador web. Igualmente pueden hacerlo en su computadora o en la nube utilizando Google Colab o Kaggle. Para cada ejercicio deber de escribir su propio c√≥digo, crear un comentario con sus datos, crear su soluci√≥n y tomar una captura de pantalla del resultado. Finalmente, subir la captura a la asignaci√≥n correspondiente en Google Classroom.\n\nSabiendo que el Teorema de Pit√°goras es \\(a^2 + b^2 = c^2\\), calcular la hipotenusa de un tri√°ngulo rect√°ngulo con catetos de 3 y 4 unidades.\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\nSi la velocidad de la luz es de \\(299,792,458\\) m/s, y el tiempo que tarda en llegar la luz del Sol a la Tierra es de \\(8.3\\) minutos, calcular la distancia en kil√≥metros que hay entre el Sol y la Tierra.\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\nCrea dos variables con tu nombre y apellido, y concat√©nalas en una sola variable. Imprime el resultado.\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\nCrea una variable con tu canci√≥n favorita y multiplica por 4 la parte de la letra que m√°s te gusta. Imprime el resultado.\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\nCrea una variable con tu pel√≠cula favorita y compara si la longitud de la cadena de texto es mayor a 10 caracteres. Imprime el resultado.\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.",
    "crumbs": [
      "Fundamentos de Python",
      "Declaraci√≥n de Variables y Operaciones"
    ]
  },
  {
    "objectID": "intro_python/data_structures.html",
    "href": "intro_python/data_structures.html",
    "title": "Estructuras de Datos",
    "section": "",
    "text": "Los datos son la base de la ciencia, son la materia prima con la que trabajamos. Dada su importancia es necesario contar con herramientas que nos permitan manipularlos de manera eficiente. En este sentido, las estructuras de datos son una herramienta fundamental en la programaci√≥n. Se definen como formas de organizar y almacenar datos en la memoria de un computador, de tal manera que se puedan acceder y modificar de manera eficiente.\nEn esta lecci√≥n veremos algunas de las estructuras de datos m√°s comunes en Python, como las listas, tuplas, conjuntos, diccionarios, arreglos de NumPy y DataFrames de Pandas, as√≠ como las propiedades y m√©todos que las caracterizan.",
    "crumbs": [
      "Fundamentos de Python",
      "Estructuras de Datos"
    ]
  },
  {
    "objectID": "intro_python/data_structures.html#indexaci√≥n",
    "href": "intro_python/data_structures.html#indexaci√≥n",
    "title": "Estructuras de Datos",
    "section": "Indexaci√≥n",
    "text": "Indexaci√≥n\nPara acceder a elementos de una lista se utiliza la indexaci√≥n. Los √≠ndices en Python comienzan en 0, por lo que el primer elemento de una lista tiene √≠ndice 0, el segundo √≠ndice 1 y as√≠ sucesivamente. Para acceder a un elemento de una lista se utiliza la sintaxis nombredelista[indice].\n\n\nC√≥digo\nprint(lista[0])\nprint(lista[1])\nprint(lista[2])\n\n# Acceder al √∫ltimo elemento\nprint(lista[-1])\n\n\n1\n2\n3\nhola",
    "crumbs": [
      "Fundamentos de Python",
      "Estructuras de Datos"
    ]
  },
  {
    "objectID": "intro_python/data_structures.html#slicing",
    "href": "intro_python/data_structures.html#slicing",
    "title": "Estructuras de Datos",
    "section": "Slicing",
    "text": "Slicing\nEl slicing es una t√©cnica que permite acceder a subconjuntos de elementos de una lista. Se utiliza la sintaxis nombredelista[inicio:fin], donde inicio es el √≠ndice del primer elemento que se quiere incluir y fin es el √≠ndice del primer elemento que no se quiere incluir.\n\n\nC√≥digo\nprint(lista[0:3])\nprint(lista[3:])\n\n\n[1, 2, 3]\n[4, 5, 6, [7, 8, 9], 'hola']\n\n\nSi no se especifica el √≠ndice de inicio, se asume que es 0. Si no se especifica el √≠ndice de fin, se asume que es el √∫ltimo elemento de la lista.",
    "crumbs": [
      "Fundamentos de Python",
      "Estructuras de Datos"
    ]
  },
  {
    "objectID": "intro_python/data_structures.html#modificaci√≥n",
    "href": "intro_python/data_structures.html#modificaci√≥n",
    "title": "Estructuras de Datos",
    "section": "Modificaci√≥n",
    "text": "Modificaci√≥n\nPara modificar un elemento de una lista se utiliza la indexaci√≥n y la asignaci√≥n.\n\n\nC√≥digo\nlista[0] = 10\nprint(lista)\n\n\n[10, 2, 3, 4, 5, 6, [7, 8, 9], 'hola']",
    "crumbs": [
      "Fundamentos de Python",
      "Estructuras de Datos"
    ]
  },
  {
    "objectID": "intro_python/data_structures.html#eliminaci√≥n",
    "href": "intro_python/data_structures.html#eliminaci√≥n",
    "title": "Estructuras de Datos",
    "section": "Eliminaci√≥n",
    "text": "Eliminaci√≥n\nPara eliminar un elemento de una lista se utiliza el m√©todo remove() y se especifica el elemento del elemento que se quiere eliminar.\n\n\nC√≥digo\nlista.remove(10)\nprint(lista)\n\n\n[2, 3, 4, 5, 6, [7, 8, 9], 'hola']\n\n\nSi queremos eliminar el √∫ltimo elemento de una lista se puede utilizar el m√©todo pop().\n\n\nC√≥digo\nlista.pop()\nprint(lista)\n\n\n'hola'\n\n\n[2, 3, 4, 5, 6, [7, 8, 9]]",
    "crumbs": [
      "Fundamentos de Python",
      "Estructuras de Datos"
    ]
  },
  {
    "objectID": "intro_python/data_structures.html#resumen",
    "href": "intro_python/data_structures.html#resumen",
    "title": "Estructuras de Datos",
    "section": "Resumen",
    "text": "Resumen\nLas listas tienen un gran n√∫mero de m√©todos que permiten realizar operaciones sobre ellas. Un resumen de los m√©todos m√°s comunes es el siguiente:\n\nappend(): Agrega un elemento al final de la lista.\nextend(): Agrega varios elementos al final de la lista.\ninsert(): Agrega un elemento en una posici√≥n espec√≠fica.\nremove(): Elimina un elemento de la lista.\npop(): Elimina un elemento de la lista y lo devuelve.\nindex(): Devuelve el √≠ndice de un elemento en la lista.\ncount(): Cuenta el n√∫mero de veces que un elemento aparece en la lista.\nsort(): Ordena los elementos de la lista en orden ascendente.\nreverse(): Invierte el orden de los elementos de la lista.\ncopy(): Crea una copia de la lista.\n\nVale la pena hacer enf√°sis en que no es necesario aprenderse todos los m√©todos de memoria, sino que es m√°s importante entender para qu√© y c√≥mo se pueden utilizar las listas, los m√©todos se pueden consultar en la documentaci√≥n de Python, buscando en Google o preguntandole a ChatGPT.",
    "crumbs": [
      "Fundamentos de Python",
      "Estructuras de Datos"
    ]
  },
  {
    "objectID": "intro_python/data_structures.html#ejericios",
    "href": "intro_python/data_structures.html#ejericios",
    "title": "Estructuras de Datos",
    "section": "Ejericios",
    "text": "Ejericios\n\nCrea una lista con los n√∫meros del 1 al 10 y calcula la suma de los elementos. Pista: utiliza la funci√≥n sum() de Python.\nCrea una tupla con los nombres de los d√≠as de la semana y accede al tercer d√≠a. Intenta modificar el tercer d√≠a y observa qu√© sucede.\nCrea una variable con la letra de una canci√≥n que te guste, separa las palabras en una lista, guarda esa lista en una variable y accede a la primera y √∫ltima palabra. Pista: utiliza el m√©todo split() de Python.\nConvierte la lista de palabras en un conjunto y observa qu√© sucede. ¬øQu√© diferencias encuentras entre la lista y el conjunto? Intenta agregar una palabra al conjunto y observa qu√© sucede. Pista: utiliza la funci√≥n set() de Python y el m√©todo add() de los conjuntos.\nCrea una funci√≥n para contar palabras en un texto, cuenta las palabras distintas en la letra de una canci√≥n que te guste y almacenalas en un diccionario con la palabra como clave y el n√∫mero de veces que aparece como valor. Pista: utiliza el m√©todo split() para separar las palabras",
    "crumbs": [
      "Fundamentos de Python",
      "Estructuras de Datos"
    ]
  },
  {
    "objectID": "intro_python/data_structures.html#slicing-en-dataframes",
    "href": "intro_python/data_structures.html#slicing-en-dataframes",
    "title": "Estructuras de Datos",
    "section": "Slicing en DataFrames",
    "text": "Slicing en DataFrames\nPor ahora veamos c√≥mo acceder a elementos de un DataFrame. Podemos acceder a las primeras y √∫ltimas filas de un DataFrame utilizando los m√©todos head() y tail(), respectivamente\n\n\nC√≥digo\n# Cargo un conjunto de datos de ejemplo\ndf = pd.read_csv('https://raw.githubusercontent.com/mwaskom/seaborn-data/master/iris.csv') \n\ndf.head() # Imprimir las primeras filas del DataFrame\n\ndf.tail() # Imprimir las √∫ltimas filas del DataFrame\n\n\n\n\n\n\n\n\n\n\nsepal_length\nsepal_width\npetal_length\npetal_width\nspecies\n\n\n\n\n0\n5.1\n3.5\n1.4\n0.2\nsetosa\n\n\n1\n4.9\n3.0\n1.4\n0.2\nsetosa\n\n\n2\n4.7\n3.2\n1.3\n0.2\nsetosa\n\n\n3\n4.6\n3.1\n1.5\n0.2\nsetosa\n\n\n4\n5.0\n3.6\n1.4\n0.2\nsetosa\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nsepal_length\nsepal_width\npetal_length\npetal_width\nspecies\n\n\n\n\n145\n6.7\n3.0\n5.2\n2.3\nvirginica\n\n\n146\n6.3\n2.5\n5.0\n1.9\nvirginica\n\n\n147\n6.5\n3.0\n5.2\n2.0\nvirginica\n\n\n148\n6.2\n3.4\n5.4\n2.3\nvirginica\n\n\n149\n5.9\n3.0\n5.1\n1.8\nvirginica\n\n\n\n\n\n\n\n\nPodemos acceder a las columnas de un DataFrame utilizando la indexaci√≥n con corchetes [] y el nombre de la columna entre comillas simples o dobles.\n\n\nC√≥digo\ndf['sepal_length'] # Acceder a la columna 'sepal_length'\n\n\n0      5.1\n1      4.9\n2      4.7\n3      4.6\n4      5.0\n      ... \n145    6.7\n146    6.3\n147    6.5\n148    6.2\n149    5.9\nName: sepal_length, Length: 150, dtype: float64\n\n\nOtra manera de acceder a una columna es utilizando la notaci√≥n de punto . y el nombre de la columna, pero esta forma no es muy usada dado que complica el acceso a columnas con nombres que contienen espacios o caracteres especiales.\n\n\nC√≥digo\ndf.sepal_length # Acceder a la columna 'sepal_length'\n\n\n0      5.1\n1      4.9\n2      4.7\n3      4.6\n4      5.0\n      ... \n145    6.7\n146    6.3\n147    6.5\n148    6.2\n149    5.9\nName: sepal_length, Length: 150, dtype: float64\n\n\nTambi√©n podemos acceder a filas y columnas utilizando la funci√≥n loc[] y los nombres de las filas y columnas.\n\n\nC√≥digo\ndf.loc[:, 'sepal_length'] # Acceder al elemento en la fila 0 y columna 'sepal_length'\n# Recuerden que si usamos : estamos seleccionando todas las filas, primero se seleccionan las filas y luego las columnas\n\n\n0      5.1\n1      4.9\n2      4.7\n3      4.6\n4      5.0\n      ... \n145    6.7\n146    6.3\n147    6.5\n148    6.2\n149    5.9\nName: sepal_length, Length: 150, dtype: float64\n\n\nSi queremos seleccionar varias columnas podemos pasar una lista con los nombres de las columnas.\n\n\nC√≥digo\ncol_names = ['sepal_length', 'sepal_width']\ndf.loc[:, col_names] # Acceder a las columnas 'sepal_length' y 'sepal_width'\n\n\n\n\n\n\n\n\n\n\nsepal_length\nsepal_width\n\n\n\n\n0\n5.1\n3.5\n\n\n1\n4.9\n3.0\n\n\n2\n4.7\n3.2\n\n\n3\n4.6\n3.1\n\n\n4\n5.0\n3.6\n\n\n...\n...\n...\n\n\n145\n6.7\n3.0\n\n\n146\n6.3\n2.5\n\n\n147\n6.5\n3.0\n\n\n148\n6.2\n3.4\n\n\n149\n5.9\n3.0\n\n\n\n\n150 rows √ó 2 columns\n\n\n\n\nSi queremos seleccionar las filas 5, 14, 23 y las columnas ‚Äòsepal_length‚Äô y ‚Äòsepal_width‚Äô podemos hacerlo de la siguiente manera.\n\n\nC√≥digo\nfilas = [5, 14, 23]\ncol_names = ['sepal_length', 'sepal_width']\n\ndf.loc[filas, col_names] # Acceder a las filas 5, 14, 23 y las columnas 'sepal_length' y 'sepal_width'\n\n\n\n\n\n\n\n\n\n\nsepal_length\nsepal_width\n\n\n\n\n5\n5.4\n3.9\n\n\n14\n5.8\n4.0\n\n\n23\n5.1\n3.3",
    "crumbs": [
      "Fundamentos de Python",
      "Estructuras de Datos"
    ]
  },
  {
    "objectID": "intro_python/data_structures.html#modificaci√≥n-de-dataframes",
    "href": "intro_python/data_structures.html#modificaci√≥n-de-dataframes",
    "title": "Estructuras de Datos",
    "section": "Modificaci√≥n de DataFrames",
    "text": "Modificaci√≥n de DataFrames\nPodemos agregar una nueva columna a un DataFrame utilizando la notaci√≥n de corchetes [] y el nombre de la nueva columna y asign√°ndole una lista con los valores de la columna.\nCreemos una nueva columna que contenga la suma de las columnas ‚Äòsepal_length‚Äô y ‚Äòsepal_width‚Äô.\n\n\nC√≥digo\ndf['sepal_sum'] = df['sepal_length'] + df['sepal_width']\ndf.head()\n\n\n\n\n\n\n\n\n\n\nsepal_length\nsepal_width\npetal_length\npetal_width\nspecies\nsepal_sum\n\n\n\n\n0\n5.1\n3.5\n1.4\n0.2\nsetosa\n8.6\n\n\n1\n4.9\n3.0\n1.4\n0.2\nsetosa\n7.9\n\n\n2\n4.7\n3.2\n1.3\n0.2\nsetosa\n7.9\n\n\n3\n4.6\n3.1\n1.5\n0.2\nsetosa\n7.7\n\n\n4\n5.0\n3.6\n1.4\n0.2\nsetosa\n8.6\n\n\n\n\n\n\n\n\nPara eliminar una columna de un DataFrame se utiliza el m√©todo drop() y se pasa el nombre de la columna y el eje en el que se quiere eliminar, los ejes son 0 para filas y 1 para columnas.\n\n\nC√≥digo\ndf.drop('sepal_sum', axis=1, inplace=True)\ndf.head()\n\n\n\n\n\n\n\n\n\n\nsepal_length\nsepal_width\npetal_length\npetal_width\nspecies\n\n\n\n\n0\n5.1\n3.5\n1.4\n0.2\nsetosa\n\n\n1\n4.9\n3.0\n1.4\n0.2\nsetosa\n\n\n2\n4.7\n3.2\n1.3\n0.2\nsetosa\n\n\n3\n4.6\n3.1\n1.5\n0.2\nsetosa\n\n\n4\n5.0\n3.6\n1.4\n0.2\nsetosa\n\n\n\n\n\n\n\n\nEl par√°metro inplace=True indica que la operaci√≥n se realice sobre el DataFrame original, si se omite se crea una copia del DataFrame con la columna eliminada, pero si esta copia no se asigna a una variable se perder√°.\nSi queremos modificar un valor de un DataFrame se localiza el elemento con loc[] y se asigna el nuevo valor.\n\n\nC√≥digo\ndf.head()\ndf.loc[0, 'sepal_length'] = 10\ndf.head()\n\n\n\n\n\n\n\n\n\n\nsepal_length\nsepal_width\npetal_length\npetal_width\nspecies\n\n\n\n\n0\n5.1\n3.5\n1.4\n0.2\nsetosa\n\n\n1\n4.9\n3.0\n1.4\n0.2\nsetosa\n\n\n2\n4.7\n3.2\n1.3\n0.2\nsetosa\n\n\n3\n4.6\n3.1\n1.5\n0.2\nsetosa\n\n\n4\n5.0\n3.6\n1.4\n0.2\nsetosa\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nsepal_length\nsepal_width\npetal_length\npetal_width\nspecies\n\n\n\n\n0\n10.0\n3.5\n1.4\n0.2\nsetosa\n\n\n1\n4.9\n3.0\n1.4\n0.2\nsetosa\n\n\n2\n4.7\n3.2\n1.3\n0.2\nsetosa\n\n\n3\n4.6\n3.1\n1.5\n0.2\nsetosa\n\n\n4\n5.0\n3.6\n1.4\n0.2\nsetosa",
    "crumbs": [
      "Fundamentos de Python",
      "Estructuras de Datos"
    ]
  },
  {
    "objectID": "intro_python/Cloud.html",
    "href": "intro_python/Cloud.html",
    "title": "Instalaci√≥n de Python",
    "section": "",
    "text": "Python  es un lenguaje de programaci√≥n de alto nivel, interpretado y orientado a objetos con sem√°ntica din√°mica. Es un lenguaje de programaci√≥n muy popular en la actualidad debido a su simplicidad y versatilidad. Y ampliamente utilizado en la ciencia de datos, inteligencia artificial, desarrollo web, desarrollo de videojuegos, entre otros.\nVamos a deshilar un poco la definici√≥n anterior para entender mejor lo que significa.\n\n\nUn lenguaje de programaci√≥n de alto nivel es un lenguaje de programaci√≥n que se encuentra m√°s cerca del lenguaje humano que del lenguaje de m√°quina. Por ejemplo para imprimir el resultado de la suma de dos n√∫meros en Python se escribe:\n\n\nC√≥digo\na = 5\nb = 3\n\nprint(a + b)\n\n\n8\n\n\nCualquier persona que entienda aritm√©tica b√°sica y sepa un poco de ingl√©s puede entender lo que hace este c√≥digo. Esto hace que los programas escritos en Python sean m√°s f√°ciles de leer y de escribir que los programas escritos en lenguajes de programaci√≥n de bajo nivel como el lenguaje ensamblador  o el lenguaje C++  . Por ejemplo en C++ el mismo programa se escribir√≠a de la siguiente forma:\n#include &lt;iostream&gt;\n\nint main() {\n    int a = 5;\n    int b = 3;\n    std::cout &lt;&lt; a + b &lt;&lt; std::endl;\n    return 0;\n} \nY en lenguaje ensamblador se escribir√≠a de la siguiente forma:\nsection .data\n    a db 5\n    b db 3\nsection .text\n    global _start\n_start:\n    mov al, [a]\n    mov bl, [b]\n    add al, bl\n    mov dl, al\n    mov eax, 4\n    mov ebx, 1\n    mov ecx, dl\n    mov edx, 1\n    int 0x80\n    mov eax, 1\n    xor ebx, ebx\n    int 0x80\n\n\n\nUn lenguaje de programaci√≥n interpretado es un lenguaje de programaci√≥n que utiliza un programa llamado int√©rprete para ejecutar el c√≥digo fuente. El int√©rprete de Python se encarga de leer el c√≥digo fuente escrito en Python y ejecutarlo l√≠nea por l√≠nea.\nPor otro lado, los lenguajes de programaci√≥n compilados utilizan un programa llamado compilador para traducir el c√≥digo fuente a un lenguaje de m√°quina que la computadora pueda entender. El c√≥digo fuente compilado se convierte en un archivo ejecutable que puede ser ejecutado por la computadora lo que da como resultado un programa m√°s r√°pido que un programa interpretado y con mayor control sobre el hardware.\n\n\n\nPython es un lenguaje de programaci√≥n orientado a objetos lo que significa que todo en Python es un objeto. Un objeto es una entidad que tiene un estado y un comportamiento. Por ejemplo, un objeto de la clase Persona tiene un estado que incluye el nombre, la edad y la direcci√≥n de la persona y un comportamiento que incluye caminar, hablar y comer.\nEl ejemplo m√°s claro de la orientaci√≥n a objetos en Python es la creaci√≥n de clases y objetos. Una clase es una plantilla que define las propiedades y los m√©todos de un objeto y un objeto es una instancia de una clase. Por ejemplo, la clase Persona define las propiedades y los m√©todos de una persona y un objeto de la clase Persona es una persona en particular.\nEsto en Python se ve de la siguiente forma:\n\n\nC√≥digo\nclass Persona:\n    def __init__(self, nombre, edad, direccion):\n        self.nombre = nombre\n        self.edad = edad\n        self.direccion = direccion\n\n    def caminar(self):\n        print(f\"{self.nombre} est√° caminando\")\n\n    def hablar(self):\n        print(f\"{self.nombre} est√° hablando\")\n\n    def comer(self):\n        print(f\"{self.nombre} est√° comiendo\")\n\npersona = Persona(\"Juan\", 25, \"Calle 123\")\npersona.caminar()\npersona.hablar()\npersona.comer()\n\n\nJuan est√° caminando\nJuan est√° hablando\nJuan est√° comiendo\n\n\n\n\n\nPython es un lenguaje de programaci√≥n con sem√°ntica din√°mica lo que significa que el tipo de una variable se determina en tiempo de ejecuci√≥n y no en tiempo de compilaci√≥n. Por ejemplo, en Python no es necesario declarar el tipo de una variable antes de utilizarla como en otros lenguajes de programaci√≥n como C++ o Java. Por ejemplo, en Python se puede escribir:\n\n\nC√≥digo\na = 5\nb = \"Hola\"\nc = 3.14\n\n\nEn este caso, Python determina que a es un entero, b es una cadena de texto y c es un n√∫mero de punto flotante en tiempo de ejecuci√≥n.\nEn otro lenguaes de programaci√≥n como C++ o Java se tendr√≠a que declarar el tipo de las variables antes de utilizarlas. Por ejemplo, en C++ se tendr√≠a que escribir:\nint a = 5;\nstd::string b = \"Hola\";\nfloat c = 3.14;\nEl tipo puede ser modificado en cualquier momento, por ejemplo:\n\n\nC√≥digo\na = 5\nprint(a)\na = \"Hola\"\nprint(a)\na = 3.14\nprint(a)\n\n\n5\nHola\n3.14",
    "crumbs": [
      "Fundamentos de Python",
      "Instalaci√≥n de Python"
    ]
  },
  {
    "objectID": "intro_python/Cloud.html#interpretado",
    "href": "intro_python/Cloud.html#interpretado",
    "title": "Instalaci√≥n de Python",
    "section": "",
    "text": "Un lenguaje de programaci√≥n interpretado es un lenguaje de programaci√≥n que utiliza un programa llamado int√©rprete para ejecutar el c√≥digo fuente. El int√©rprete de Python se encarga de leer el c√≥digo fuente escrito en Python y ejecutarlo l√≠nea por l√≠nea.\nPor otro lado, los lenguajes de programaci√≥n compilados utilizan un programa llamado compilador para traducir el c√≥digo fuente a un lenguaje de m√°quina que la computadora pueda entender. El c√≥digo fuente compilado se convierte en un archivo ejecutable que puede ser ejecutado por la computadora lo que da como resultado un programa m√°s r√°pido que un programa interpretado y con mayor control sobre el hardware.",
    "crumbs": [
      "Fundamentos de Python",
      "Instalaci√≥n de Python"
    ]
  },
  {
    "objectID": "intro_python/Cloud.html#orientado-a-objetos",
    "href": "intro_python/Cloud.html#orientado-a-objetos",
    "title": "Instalaci√≥n de Python",
    "section": "",
    "text": "Python es un lenguaje de programaci√≥n orientado a objetos lo que significa que todo en Python es un objeto. Un objeto es una entidad que tiene un estado y un comportamiento. Por ejemplo, un objeto de la clase Persona tiene un estado que incluye el nombre, la edad y la direcci√≥n de la persona y un comportamiento que incluye caminar, hablar y comer.\nEl ejemplo m√°s claro de la orientaci√≥n a objetos en Python es la creaci√≥n de clases y objetos. Una clase es una plantilla que define las propiedades y los m√©todos de un objeto y un objeto es una instancia de una clase. Por ejemplo, la clase Persona define las propiedades y los m√©todos de una persona y un objeto de la clase Persona es una persona en particular.\nEsto en Python se ve de la siguiente forma:\n\n\nC√≥digo\nclass Persona:\n    def __init__(self, nombre, edad, direccion):\n        self.nombre = nombre\n        self.edad = edad\n        self.direccion = direccion\n\n    def caminar(self):\n        print(f\"{self.nombre} est√° caminando\")\n\n    def hablar(self):\n        print(f\"{self.nombre} est√° hablando\")\n\n    def comer(self):\n        print(f\"{self.nombre} est√° comiendo\")\n\npersona = Persona(\"Juan\", 25, \"Calle 123\")\npersona.caminar()\npersona.hablar()\npersona.comer()\n\n\nJuan est√° caminando\nJuan est√° hablando\nJuan est√° comiendo",
    "crumbs": [
      "Fundamentos de Python",
      "Instalaci√≥n de Python"
    ]
  },
  {
    "objectID": "intro_python/Cloud.html#sem√°ntica-din√°mica",
    "href": "intro_python/Cloud.html#sem√°ntica-din√°mica",
    "title": "Instalaci√≥n de Python",
    "section": "",
    "text": "Python es un lenguaje de programaci√≥n con sem√°ntica din√°mica lo que significa que el tipo de una variable se determina en tiempo de ejecuci√≥n y no en tiempo de compilaci√≥n. Por ejemplo, en Python no es necesario declarar el tipo de una variable antes de utilizarla como en otros lenguajes de programaci√≥n como C++ o Java. Por ejemplo, en Python se puede escribir:\n\n\nC√≥digo\na = 5\nb = \"Hola\"\nc = 3.14\n\n\nEn este caso, Python determina que a es un entero, b es una cadena de texto y c es un n√∫mero de punto flotante en tiempo de ejecuci√≥n.\nEn otro lenguaes de programaci√≥n como C++ o Java se tendr√≠a que declarar el tipo de las variables antes de utilizarlas. Por ejemplo, en C++ se tendr√≠a que escribir:\nint a = 5;\nstd::string b = \"Hola\";\nfloat c = 3.14;\nEl tipo puede ser modificado en cualquier momento, por ejemplo:\n\n\nC√≥digo\na = 5\nprint(a)\na = \"Hola\"\nprint(a)\na = 3.14\nprint(a)\n\n\n5\nHola\n3.14",
    "crumbs": [
      "Fundamentos de Python",
      "Instalaci√≥n de Python"
    ]
  },
  {
    "objectID": "intro_python/Cloud.html#macos",
    "href": "intro_python/Cloud.html#macos",
    "title": "Instalaci√≥n de Python",
    "section": "MacOs ",
    "text": "MacOs",
    "crumbs": [
      "Fundamentos de Python",
      "Instalaci√≥n de Python"
    ]
  },
  {
    "objectID": "intro_python/Cloud.html#windows",
    "href": "intro_python/Cloud.html#windows",
    "title": "Instalaci√≥n de Python",
    "section": "Windows ",
    "text": "Windows",
    "crumbs": [
      "Fundamentos de Python",
      "Instalaci√≥n de Python"
    ]
  },
  {
    "objectID": "intro_python/Cloud.html#instalar-visual-studio-code",
    "href": "intro_python/Cloud.html#instalar-visual-studio-code",
    "title": "Instalaci√≥n de Python",
    "section": "Instalar Visual Studio Code ",
    "text": "Instalar Visual Studio Code \nLa instalaci√≥n de Visual Studio Code es muy sencilla, solo debes de ir a la p√°gina oficial de Visual Studio Code y descargar el instalador correspondiente a tu sistema operativo, pero si prefieres ver un video que te gu√≠e en la instalaci√≥n aqu√≠ te dejo uno para MacOS y otro para Windows.\n\nMacOS \n\n\n\nWindows",
    "crumbs": [
      "Fundamentos de Python",
      "Instalaci√≥n de Python"
    ]
  },
  {
    "objectID": "intro_python/functions_and_loops.html",
    "href": "intro_python/functions_and_loops.html",
    "title": "Funciones y Bucles de Control",
    "section": "",
    "text": "En esta lecci√≥n, aprenderemos sobre funciones y estructuras de control en Python. Las funciones son bloques de c√≥digo que se pueden reutilizar en diferentes partes de un programa, permitiendo que el c√≥digo sea m√°s modular y f√°cil de mantener. Las estructuras de control son bloques de c√≥digo que permiten controlar el flujo de ejecuci√≥n de un programa, como bucles y declaraciones condicionales. Son dos conceptos fundamentales en programaci√≥n que nos permiten escribir c√≥digo m√°s eficiente y legible.",
    "crumbs": [
      "Fundamentos de Python",
      "Funciones y Bucles de Control"
    ]
  },
  {
    "objectID": "intro_python/functions_and_loops.html#funciones-lambda",
    "href": "intro_python/functions_and_loops.html#funciones-lambda",
    "title": "Funciones y Bucles de Control",
    "section": "Funciones Lambda",
    "text": "Funciones Lambda\nLas funciones lambda son funciones an√≥nimas que se pueden definir en una sola l√≠nea. Se definen con la palabra clave lambda, seguida de una lista de par√°metros y una expresi√≥n que se eval√∫a y devuelve el resultado. Por ejemplo, la siguiente funci√≥n lambda calcula el cuadrado de un n√∫mero:\n\n\nC√≥digo\ncuadrado_lamda = lambda x: x ** 2\n\nprint(cuadrado_lamda(5))\n\n\n25\n\n\nLas funciones lambda son √∫tiles cuando se necesita una funci√≥n simple y no es necesario definirla con una declaraci√≥n def.\nAhora definamos una funci√≥n lambda un poco m√°s compleja para sumar dos n√∫meros:\n\n\nC√≥digo\nsuma_lambda = lambda x, y: x + y\n\nprint(suma_lambda(3, 4))\n\n\n7",
    "crumbs": [
      "Fundamentos de Python",
      "Funciones y Bucles de Control"
    ]
  },
  {
    "objectID": "intro_python/functions_and_loops.html#paquetes-y-m√≥dulos",
    "href": "intro_python/functions_and_loops.html#paquetes-y-m√≥dulos",
    "title": "Funciones y Bucles de Control",
    "section": "Paquetes y M√≥dulos",
    "text": "Paquetes y M√≥dulos\nEn Python, las funciones se pueden organizar en m√≥dulos y paquetes para facilitar la reutilizaci√≥n y la organizaci√≥n del c√≥digo. Un m√≥dulo es un archivo que contiene definiciones y declaraciones de Python, como funciones, clases y variables. Un paquete es una colecci√≥n de m√≥dulos organizados en un directorio. Es decir, que un paquete es una carpeta que contiene archivos de python (m√≥dulos) que contienen funciones, clases y variables que puedes utilizar en tu programa.\nHay paqueterias y modulos muy √∫tiles que se pueden importar en Python, por ejemplo, la paqueter√≠a math que contiene funciones matem√°ticas comunes, como sqrt para calcular la ra√≠z cuadrada de un n√∫mero. Para importar un m√≥dulo o una funci√≥n de un m√≥dulo, se utiliza la palabra clave import seguida del nombre del m√≥dulo.\nimport math\nUna vez que se ha importado un m√≥dulo, se puede acceder a sus funciones y variables utilizando la notaci√≥n de punto. Por ejemplo, para calcular la ra√≠z cuadrada de un n√∫mero, se puede utilizar la funci√≥n sqrt del m√≥dulo math.\n\n\nC√≥digo\nimport math\nprint(math.sqrt(16))\n\n\n4.0\n\n\nTambi√©n es posible importar funciones espec√≠ficas de un m√≥dulo utilizando la palabra clave from. Por ejemplo, para importar solo la funci√≥n sqrt del m√≥dulo math, se puede hacer lo siguiente:\n\n\nC√≥digo\nfrom math import sqrt\n\nprint(sqrt(16))\n\n\n4.0\n\n\nMuchas veces las paqueterias tienen nombres muy largos, por lo que se pueden importar con un alias utilizando la palabra clave as, las paqueterias m√°s comunes en python tienen alias ya acordados en la comunidad, por ejemplo, pandas una paqueter√≠a muy utilizada para el an√°lisis de datos se importa con el alias pd.\nimport pandas as pd\nDe esta forma, se puede acceder a las funciones y variables de la paqueter√≠a pandas utilizando el alias pd.\nExiste un gran n√∫mero de paqueter√≠as y m√≥dulos disponibles en Python que proporcionan funcionalidades adicionales para tareas espec√≠ficas, como el an√°lisis de datos, la visualizaci√≥n, el aprendizaje autom√°tico, etc. Estas paqueter√≠as pueden ser muy √∫tiles para acelerar el desarrollo de aplicaciones y realizar tareas complejas de manera eficiente.\nNo todas las paqueterias vienen preinstaladas con Python, por lo que es necesario instalarlas con un administrador de paquetes, el m√°s com√∫n es pip. Para instalar una paqueter√≠a con pip, se utiliza el siguiente comando en la terminal:\npip install nombre_paqueteria\nO si se usa jupyter notebook o jupyter lab, se puede instalar una paqueter√≠a con el comando !pip install nombre_paqueteria.\nCada paqueteria tiene su propia documentaci√≥n, por lo que es recomendable revisarla para conocer todas las funciones y caracter√≠sticas que ofrece.",
    "crumbs": [
      "Fundamentos de Python",
      "Funciones y Bucles de Control"
    ]
  },
  {
    "objectID": "intro_python/functions_and_loops.html#legibilidad-y-documentaci√≥n-de-funciones",
    "href": "intro_python/functions_and_loops.html#legibilidad-y-documentaci√≥n-de-funciones",
    "title": "Funciones y Bucles de Control",
    "section": "Legibilidad y Documentaci√≥n de Funciones",
    "text": "Legibilidad y Documentaci√≥n de Funciones\nEs importante que las funciones sean f√°ciles de leer y entender. Para ello, es recomendable seguir las siguientes buenas pr√°cticas:\n\nNombres descriptivos: Usa nombres descriptivos para las funciones y los par√°metros.\nComentarios: A√±ade comentarios para explicar lo que hace cada parte de la funci√≥n.\nDocumentaci√≥n: Usa docstrings para documentar la funci√≥n y proporcionar informaci√≥n sobre su prop√≥sito, los par√°metros que espera y el valor que devuelve.\nDividir en funciones m√°s peque√±as: Si una funci√≥n es demasiado larga o hace demasiadas cosas, div√≠dela en funciones m√°s peque√±as que realicen tareas espec√≠ficas.\n\nVeamos un ejemplo de una funci√≥n bien documentada y legible:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nEn este ejemplo, hemos definido una funci√≥n sine_wave que genera una se√±al de onda sinusoidal con los par√°metros de amplitud, frecuencia, fase, duraci√≥n y tasa de muestreo especificados. Hemos documentado la funci√≥n con un docstring que explica los par√°metros que espera y el valor que devuelve. Tambi√©n hemos definido una funci√≥n plot_signal que traza la se√±al generada. Esta funci√≥n es m√°s legible y f√°cil de entender gracias a los comentarios y la documentaci√≥n.\nUn ejemplo profesional de documentaci√≥n de funciones es la documentaci√≥n de la paqueter√≠a numpy, que proporciona una descripci√≥n detallada de cada funci√≥n, los par√°metros que espera y el valor que devuelve. Puedes consultar la documentaci√≥n de numpy en el siguiente enlace: https://numpy.org/doc/stable/.",
    "crumbs": [
      "Fundamentos de Python",
      "Funciones y Bucles de Control"
    ]
  },
  {
    "objectID": "intro_python/functions_and_loops.html#estrucutras-de-control-if-elif-y-else",
    "href": "intro_python/functions_and_loops.html#estrucutras-de-control-if-elif-y-else",
    "title": "Funciones y Bucles de Control",
    "section": "Estrucutras de Control: if, elif y else",
    "text": "Estrucutras de Control: if, elif y else\nLa declaraci√≥n if se utiliza para ejecutar un bloque de c√≥digo si una condici√≥n es verdadera. La declaraci√≥n elif se utiliza para comprobar m√∫ltiples condiciones si la condici√≥n anterior es falsa. La declaraci√≥n else se utiliza para ejecutar un bloque de c√≥digo si ninguna de las condiciones anteriores es verdadera.\n\n\n\nEstructura de Control if\n\n\nLa sintaxis de la declaraci√≥n if en python es la siguiente:\nif condicion:\n    # C√≥digo a ejecutar si la condici√≥n es verdadera\nelif otra_condicion:\n    # C√≥digo a ejecutar si la condici√≥n anterior es falsa y esta condici√≥n es verdadera\nelse:\n    # C√≥digo a ejecutar si ninguna de las condiciones anteriores es verdadera\n\nEjemplo\nSi tenemos varias condiciones que queremos comprobar, podemos usar la declaraci√≥n elif para comprobarlas en orden. A continuaci√≥n, se muestra un ejemplo de una declaraci√≥n if con elif que comprueba si un n√∫mero es positivo, negativo o cero:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.",
    "crumbs": [
      "Fundamentos de Python",
      "Funciones y Bucles de Control"
    ]
  },
  {
    "objectID": "intro_python/functions_and_loops.html#estrucutras-de-control-bucles-for",
    "href": "intro_python/functions_and_loops.html#estrucutras-de-control-bucles-for",
    "title": "Funciones y Bucles de Control",
    "section": "Estrucutras de Control: Bucles for",
    "text": "Estrucutras de Control: Bucles for\nEl bucle for se utiliza para iterar sobre una secuencia de elementos, como una lista, una tupla o un rango de n√∫meros. La sintaxis de un bucle for en Python es la siguiente:\nfor elemento in secuencia:\n    # C√≥digo a ejecutar en cada iteraci√≥n\n\n\n\nEstructura de Control for\n\n\nSon muy √∫tiles cuando se necesita realizar una tarea repetitiva, como recorrer una lista de elementos o realizar una operaci√≥n en cada elemento de una secuencia, ser√°n vitales para el an√°lisis de datos.\n\nEjemplo\nVeamos un ejemplo donde imprimimos una cuenta regresiva desde 10 hasta 1:\n\n\nC√≥digo\n# Ejemplo de bucle for\nfor i in range(10, 0, -1):\n    print(i)\n\n\n10\n9\n8\n7\n6\n5\n4\n3\n2\n1\n\n\nLa funci√≥n range genera una secuencia de n√∫meros desde el primer argumento hasta el segundo argumento, con un paso especificado por el tercer argumento. En este caso, estamos generando una secuencia de n√∫meros desde 10 hasta 1 con un paso de -1. Es muy com√∫n usar range en bucles for. Otra forma de usar range es con un solo argumento, que genera una secuencia de n√∫meros desde 0 hasta el argumento especificado.\n\n\nC√≥digo\n# Ejemplo de bucle for con un solo argumento\nfor i in range(5):\n    print(i)\n\n\n0\n1\n2\n3\n4\n\n\nComo habras notado, la funci√≥n range genera una secuencia de n√∫meros desde 0 hasta 4, ya que el argumento especificado es 5, si cuentas los n√∫meros, ver√°s que son 5 n√∫meros, si quieres hasta 5, debes poner 6.\nEn el siguiente tema abordaremos m√°s los usos del ciclo for cuando trabajamos con listas y diccionarios o en general con objetos iterables.",
    "crumbs": [
      "Fundamentos de Python",
      "Funciones y Bucles de Control"
    ]
  },
  {
    "objectID": "intro_python/functions_and_loops.html#estrucutras-de-control-bucles-while",
    "href": "intro_python/functions_and_loops.html#estrucutras-de-control-bucles-while",
    "title": "Funciones y Bucles de Control",
    "section": "Estrucutras de Control: Bucles while",
    "text": "Estrucutras de Control: Bucles while\nEl bucle while se utiliza para ejecutar un bloque de c√≥digo mientras una condici√≥n sea verdadera. La sintaxis de un bucle while en Python es la siguiente:\nwhile condicion:\n    # C√≥digo a ejecutar mientras la condici√≥n sea verdadera\n\n\n\nEstructura de Control while\n\n\nLos bucles while son √∫tiles cuando no se sabe cu√°ntas veces se debe ejecutar un bloque de c√≥digo y se necesita comprobar una condici√≥n en cada iteraci√≥n.\n\n ADVERTENCIA. Es importante tener cuidado al usar bucles while, ya que si la condici√≥n nunca se vuelve falsa, el bucle se ejecutar√° indefinidamente, lo que puede provocar un bucle infinito y bloquear el programa.\n\n\nEjemplo\nAhora intentemos algo m√°s complicado, crearemos una funci√≥n que nos diga cuantas vecces se repite una letra dada en una cadena de texto:\n\n\nC√≥digo\ndef contar_letra(cadena, letra):\n    contador = 0\n    i = 0\n    while i &lt; len(cadena):\n        if cadena[i] == letra:\n            contador += 1\n        i += 1\n    return contador\n\n# Primer verso y coro de \"Army of One\" de Coldplay \ncadena = \"\"\"\nBeen around the world, wonders to view\nBeen around the world looking for someone like you\nPyramids try, Babylon too\nBut the beautifulest treasures lie in the deepest blue\n\nSo I never say die, aim never untrue\nI'm never so high as when I'm with you\nAnd there isn't a fire that I wouldn't walk through\nMy army of one is gonna fight for you\n\"\"\"\n\nletra = 'a'\nprint(f'La letra \"{letra}\" se repite {contar_letra(cadena, letra)} veces en la cadena de texto.')\n\n\nLa letra \"a\" se repite 14 veces en la cadena de texto.\n\n\nHemos combinado el uso de un bucle while con una declaraci√≥n if para contar cu√°ntas veces se repite una letra en una cadena de texto. En general siempre podemos usar un bucle for en lugar de un while, pero en este caso, quer√≠amos mostrar c√≥mo se puede usar un bucle while para realizar la misma tarea.\nCombinar funciones, bucles y estructuras de control es una de las formas m√°s poderosas de programar en cualquier lenguaje, y Python no es la excepci√≥n.",
    "crumbs": [
      "Fundamentos de Python",
      "Funciones y Bucles de Control"
    ]
  },
  {
    "objectID": "intro_python/functions_and_loops.html#declaraci√≥n-break",
    "href": "intro_python/functions_and_loops.html#declaraci√≥n-break",
    "title": "Funciones y Bucles de Control",
    "section": "Declaraci√≥n break",
    "text": "Declaraci√≥n break\nLa declaraci√≥n break se utiliza para salir de un bucle antes de que se complete. Cuando se encuentra una declaraci√≥n break, el bucle se detiene y la ejecuci√≥n contin√∫a con la siguiente instrucci√≥n despu√©s del bucle. La declaraci√≥n break se puede utilizar en bucles for y while. Se suele utilizar para salir de un bucle cuando se cumple una condici√≥n espec√≠fica utilizando una declaraci√≥n if.\nSupongamos que queremos encontrar el primer n√∫mero divisible entre \\(7\\) y \\(5\\) en un rango de n√∫meros del \\(1\\) al \\(100\\). Podemos usar un bucle for y la declaraci√≥n break para salir del bucle cuando se encuentre el n√∫mero deseado.\n\n\nC√≥digo\nfor i in range(1, 101):\n    if i % 7 == 0 and i % 5 == 0:\n        print(f'El primer n√∫mero divisible entre 7 y 5 es {i}')\n        break\n    else:\n        print(f'{i} no es divisible entre 7 y 5')\n\n\n1 no es divisible entre 7 y 5\n2 no es divisible entre 7 y 5\n3 no es divisible entre 7 y 5\n4 no es divisible entre 7 y 5\n5 no es divisible entre 7 y 5\n6 no es divisible entre 7 y 5\n7 no es divisible entre 7 y 5\n8 no es divisible entre 7 y 5\n9 no es divisible entre 7 y 5\n10 no es divisible entre 7 y 5\n11 no es divisible entre 7 y 5\n12 no es divisible entre 7 y 5\n13 no es divisible entre 7 y 5\n14 no es divisible entre 7 y 5\n15 no es divisible entre 7 y 5\n16 no es divisible entre 7 y 5\n17 no es divisible entre 7 y 5\n18 no es divisible entre 7 y 5\n19 no es divisible entre 7 y 5\n20 no es divisible entre 7 y 5\n21 no es divisible entre 7 y 5\n22 no es divisible entre 7 y 5\n23 no es divisible entre 7 y 5\n24 no es divisible entre 7 y 5\n25 no es divisible entre 7 y 5\n26 no es divisible entre 7 y 5\n27 no es divisible entre 7 y 5\n28 no es divisible entre 7 y 5\n29 no es divisible entre 7 y 5\n30 no es divisible entre 7 y 5\n31 no es divisible entre 7 y 5\n32 no es divisible entre 7 y 5\n33 no es divisible entre 7 y 5\n34 no es divisible entre 7 y 5\nEl primer n√∫mero divisible entre 7 y 5 es 35\n\n\nPodemos ver que el bucle se detiene en el n√∫mero \\(35\\), que es el primer n√∫mero divisible entre \\(7\\) y \\(5\\) en el rango de n√∫meros del \\(1\\) al \\(100\\).",
    "crumbs": [
      "Fundamentos de Python",
      "Funciones y Bucles de Control"
    ]
  },
  {
    "objectID": "intro_python/functions_and_loops.html#declaraci√≥n-continue",
    "href": "intro_python/functions_and_loops.html#declaraci√≥n-continue",
    "title": "Funciones y Bucles de Control",
    "section": "Declaraci√≥n continue",
    "text": "Declaraci√≥n continue\nLa declaraci√≥n continue se utiliza para saltar a la siguiente iteraci√≥n de un bucle sin ejecutar el resto del c√≥digo en el bloque de bucle. Se suele utilizar para omitir ciertas iteraciones de un bucle bas√°ndose en una condici√≥n.\nPor ejemplo, supongamos que queremos imprimir todos los n√∫meros del \\(1\\) al \\(10\\) excepto el n√∫mero \\(5\\). Podemos usar un bucle for y la declaraci√≥n continue para saltar la iteraci√≥n cuando el n√∫mero es \\(5\\).\n\n\nC√≥digo\nfor i in range(1, 11):\n    if i == 5:\n        continue\n    print(i)\n\n\n1\n2\n3\n4\n6\n7\n8\n9\n10\n\n\nOtra declaraci√≥n que se puede usar en bucles es pass, que no hace nada y se utiliza como marcador de posici√≥n cuando no se necesita ejecutar ninguna instrucci√≥n en un bloque de c√≥digo. Pero el resultado no es el mismo que continue, ya que pass no salta a la siguiente iteraci√≥n, simplemente no hace nada.\n\n\nC√≥digo\nfor i in range(1, 11):\n    if i == 5:\n        pass\n    print(i)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nEn este caso, el n√∫mero \\(5\\) se imprimir√°, pero no se ejecutar√° ninguna instrucci√≥n cuando i == 5. Es una forma de evitar errores de sintaxis cuando se necesita un bloque de c√≥digo vac√≠o (por ejemplo, en una declaraci√≥n if o una funci√≥n que a√∫n no se ha implementado).",
    "crumbs": [
      "Fundamentos de Python",
      "Funciones y Bucles de Control"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Ciencia de Datos con Python",
    "section": "",
    "text": "Este curso tiene como meta introducir a los estudiantes de la Facultad de Psicolog√≠a al mundo de la ciencia de datos utilizando Python. A lo largo del curso se abordar√°n temas como la programaci√≥n en Python, la estad√≠stica descriptiva e inferencial, el an√°lisis y visualizaci√≥n de datos, y la creaci√≥n de redes neuronales.\nEl curso no supone ning√∫n conocimiento previo de programaci√≥n, pero se espera que los estudiantes tengan una actitud proactiva y est√©n dispuestos a aprender y a poner en pr√°ctica los conceptos que se presenten en clase.\nAunque se repasar√°n de manera breve conceptos de estad√≠stica y probabilidad, es recomendable tener un conocimiento b√°sico de estos temas para poder aprovechar al m√°ximo el curso. Otro requisito importante es tener una computadora personal con acceso a internet y disponibilidad de llevar al sal√≥n, ya que la mayor parte de las actividades requerir√°n de una computadora personal.\nUna parte importante del curso es crear un ambiente de aprendizaje colaborativo, por lo que se espera que los estudiantes participen activamente en las clases, realicen las tareas y actividades que se les asignen, y que est√©n dispuestos a ayudar a sus compa√±eros en caso de que lo necesiten. Adem√°s se crear√°n equipos permanentes de trabajo, por lo que es importante que los estudiantes se comprometan a trabajar en equipo dado que todas las actividades se realizar√°n en equipo fomentando un m√©todo de trabajo llamado ‚Äúpair programming‚Äù.",
    "crumbs": [
      "Inicio"
    ]
  },
  {
    "objectID": "index.html#acerca-de-este-curso",
    "href": "index.html#acerca-de-este-curso",
    "title": "Ciencia de Datos con Python",
    "section": "",
    "text": "Este curso tiene como meta introducir a los estudiantes de la Facultad de Psicolog√≠a al mundo de la ciencia de datos utilizando Python. A lo largo del curso se abordar√°n temas como la programaci√≥n en Python, la estad√≠stica descriptiva e inferencial, el an√°lisis y visualizaci√≥n de datos, y la creaci√≥n de redes neuronales.\nEl curso no supone ning√∫n conocimiento previo de programaci√≥n, pero se espera que los estudiantes tengan una actitud proactiva y est√©n dispuestos a aprender y a poner en pr√°ctica los conceptos que se presenten en clase.\nAunque se repasar√°n de manera breve conceptos de estad√≠stica y probabilidad, es recomendable tener un conocimiento b√°sico de estos temas para poder aprovechar al m√°ximo el curso. Otro requisito importante es tener una computadora personal con acceso a internet y disponibilidad de llevar al sal√≥n, ya que la mayor parte de las actividades requerir√°n de una computadora personal.\nUna parte importante del curso es crear un ambiente de aprendizaje colaborativo, por lo que se espera que los estudiantes participen activamente en las clases, realicen las tareas y actividades que se les asignen, y que est√©n dispuestos a ayudar a sus compa√±eros en caso de que lo necesiten. Adem√°s se crear√°n equipos permanentes de trabajo, por lo que es importante que los estudiantes se comprometan a trabajar en equipo dado que todas las actividades se realizar√°n en equipo fomentando un m√©todo de trabajo llamado ‚Äúpair programming‚Äù.",
    "crumbs": [
      "Inicio"
    ]
  },
  {
    "objectID": "index.html#objetivos-del-curso",
    "href": "index.html#objetivos-del-curso",
    "title": "Ciencia de Datos con Python",
    "section": "Objetivos del curso",
    "text": "Objetivos del curso\n\nAprender y poner en pr√°ctica los conceptos b√°sicos de la programaci√≥n en Python.\nComprender los conceptos b√°sicos de la estad√≠stica descriptiva e inferencial a trav√©s de ejemplos pr√°cticos en Python.\nAprender a utilizar las librer√≠as m√°s populares de Python para el an√°lisis y la visualizaci√≥n de datos.\nComprender los conceptos b√°sicos de las redes neuronales y aprender a crear redes neuronales utilizando Python.\nAprender a presentar y comunicar los resultados de un an√°lisis de datos de manera efectiva y con c√≥digo reproducible.\n\n\n\nInstructor\n\n ¬† Christian Francisco Badillo Hern√°ndez\n ¬† Lab 25, Facultad de Psicolog√≠a, UNAM\n ¬† cris.badillo1408@gmail.com\n\n\n\nDetalles del curso\n\n ¬† Lunes - Viernes\n ¬† 10 de junio - 28 de junio de 2024\n ¬† 13:30 - 15:30 hrs\n ¬† A209\n ¬† Classroom",
    "crumbs": [
      "Inicio"
    ]
  },
  {
    "objectID": "index.html#temario",
    "href": "index.html#temario",
    "title": "Ciencia de Datos con Python",
    "section": "Temario",
    "text": "Temario\n\nIntroducci√≥n a Python y la Ciencia de Datos.\n\nTipos, variables y operaciones matem√°ticas b√°sicas.\n\nStrings (cadenas de texto).\nInteger (N√∫meros enteros).\nFloats (D√©cimales)\nBooleanos\nExpresiones y declaraciones.\nOperaciones.\n\nDefinici√≥n de funciones.\n\nDefinici√≥n de funciones en python\nUso de funciones.\nFunciones lambda\n\nFlujos de control.\n\nFlujo de control If, else, elif\nFlujo de control while\nFlujo de control for\nKeywords de flujos de control: pass, continue, break\n\nEstructuras de datos.\n\nSet.\nTuplas.\nDiccionarios.\nListas.\nMatrices.\nNdarrays.\nData Frames.\n\nM√≥dulos y paquetes.\n\nDefinici√≥n de m√≥dulos y paquetes.\n\n\nLimpieza, manejo y creaci√≥n de bases de datos con pandas.\n\nTipos de bases de datos.\n\nBases de datos relacionales.\nBase de datos no relacionales.\n\nIntroducci√≥n al manejo de bases de datos con pandas.\n\nCarga de bases de datos locales o de la nube.\nB√∫squeda de datos faltantes.\nDescripci√≥n de bases de datos.\nModificaci√≥n de bases de datos.\nCreaci√≥n de bases de datos.\n\n\nAn√°lisis descriptivo y visualizaci√≥n de datos.\n\nVisualizaci√≥n de datos con Matplotlib y Seaborn.\n\nIntroducci√≥n a la visualizaci√≥n de datos.\nMatriz de correlaci√≥n.\nVisualizaciones b√°sicas (histogramas, cajas de bigotes, etc.).\nVisualizaciones en 3D y combinaciones de gr√°ficos.\n\n\nEstad√≠stica Inferencial con Python.\n\nPaqueter√≠as de An√°lisis estad√≠stico.\n\nStatsmodels.\nScikit-learn.\nPaqueter√≠as bayesianas (PyMC3, PyJAGS, PySTAN).\n\nRegresi√≥n lineal.\nRegresi√≥n m√∫ltiple.\nModelos lineales generalizados (regresi√≥n log√≠stica, ANOVA, T-Student, etc).\nEstimaci√≥n Bayesiana (Uso de algoritmos MCMC).\n\nIntroducci√≥n a Machine learning: Redes Neuronales.\n\nConceptos b√°sicos de Inteligencia artificial y redes neuronales.\nPaqueter√≠as para redes neuronales.\n\nTensorflow.\nScikit-learn.\nKeras.\n\nProgramaci√≥n del perceptr√≥n multicapa.\nAnalizando datos con un red neuronal multicapa.\n\n\n\nPuedes descargar el temario completo en el siguiente enlace:\n Descarga el temario",
    "crumbs": [
      "Inicio"
    ]
  },
  {
    "objectID": "statistics/data_manipulation.html",
    "href": "statistics/data_manipulation.html",
    "title": "Manipulaci√≥n de datos con Pandas",
    "section": "",
    "text": "Una base de datos es un conjunto de datos organizados y relacionados entre s√≠. Existen diferentes tipos de bases de datos, como las bases de datos relacionales y las bases de datos no relacionales.\nLas bases de datos relacionales son las m√°s comunes y se basan en el modelo relacional, que organiza los datos en tablas. Cada tabla tiene filas y columnas, donde cada fila representa un registro y cada columna representa un campo.\nLas bases de datos no relacionales son aquellas que no se basan en el modelo relacional y pueden tener diferentes estructuras, como documentos, gr√°ficos, clave-valor, entre otros.\nExisten lenguajes de consulta para interactuar con las bases de datos, como SQL (Structured Query Language) para las bases de datos relacionales y NoSQL (Not only SQL) para las bases de datos no relacionales.\nAunque existen paqueterias en Python para interactuar con bases de datos, en este curso nos enfocaremos en la manipulaci√≥n de datos con Pandas, una librer√≠a de Python que nos permite manipular datos de manera sencilla y eficiente. Los datos que cargar√©mos en este curso son datos en formato CSV, que es un formato de archivo que se utiliza para almacenar datos en forma de tabla.\nA diferencia de las bases de datos, los datos en formato CSV no tienen un motor de base de datos que nos permita interactuar con ellos. Por lo tanto, no podemos hacer consultas con SQL, pero podemos manipular los datos con Pandas.",
    "crumbs": [
      "Manejo de Datos y Estad√≠stica con Python",
      "Manipulaci√≥n de datos con Pandas"
    ]
  },
  {
    "objectID": "statistics/data_manipulation.html#explorando-los-datos",
    "href": "statistics/data_manipulation.html#explorando-los-datos",
    "title": "Manipulaci√≥n de datos con Pandas",
    "section": "Explorando los datos",
    "text": "Explorando los datos\nPrimero como ya vimos en la lecci√≥n anterior, podemos ver las primeras filas de los datos con el m√©todo head(). En este caso tenemos datos de hongos, donde cada fila representa un hongo y cada columna una caracter√≠stica del hongo.\nLas columnas son las siguientes:\n\nCap Diameter: Di√°metro del sombrero.\nCap Shape: Forma del sombrero.\nGill Attachment: Tipo de uni√≥n de las branquias.\nGill Color: Color de las branquias.\nStem Height: Altura del tallo.\nStem Width: Ancho del tallo.\nStem Color: Color del tallo.\nSeason: Temporada en la que se encontr√≥ el hongo.\nClass: Si es comestible (0) o venerenoso (1).\n\n\n\nC√≥digo\ndata.head()\n\n\n\n\n\n\n\n\n\n\ncap-diameter\ncap-shape\ngill-attachment\ngill-color\nstem-height\nstem-width\nstem-color\nseason\nclass\n\n\n\n\n0\n1372\n2\n2\n10\n3.807467\n1545\n11\n1.804273\n1\n\n\n1\n1461\n2\n2\n10\n3.807467\n1557\n11\n1.804273\n1\n\n\n2\n1371\n2\n2\n10\n3.612496\n1566\n11\n1.804273\n1\n\n\n3\n1261\n6\n2\n10\n3.787572\n1566\n11\n1.804273\n1\n\n\n4\n1305\n6\n2\n10\n3.711971\n1464\n11\n0.943195\n1\n\n\n\n\n\n\n\n\nLo primero que podemos hacer es ver la forma de los datos, es decir, cu√°ntas filas y columnas tenemos. Para esto usamos el atributo shape.\n\n\nC√≥digo\ndata.shape\n\n\n(54035, 9)\n\n\nTenemos 54039 y 9 columnas en nuestros datos. Podemos ver los nombres de las columnas con el atributo columns.\n\n\nC√≥digo\ndata.columns\n\n\nIndex(['cap-diameter', 'cap-shape', 'gill-attachment', 'gill-color',\n       'stem-height', 'stem-width', 'stem-color', 'season', 'class'],\n      dtype='object')\n\n\nTambi√©n podemos ver los tipos de datos de las columnas con el atributo dtypes.\n\n\nC√≥digo\ndata.dtypes\n\n\ncap-diameter         int64\ncap-shape            int64\ngill-attachment      int64\ngill-color           int64\nstem-height        float64\nstem-width           int64\nstem-color           int64\nseason             float64\nclass                int64\ndtype: object\n\n\nEl tipo de dato es muy importante, ya que restringe las cosas que podemos hacer con los datos. En este dataset, tenemos datos tipo int64 y float64 que son enteros y d√©cimales respectivamente. El tipo de dato m√°s com√∫n en Pandas es object, que es un tipo de dato gen√©rico que puede contener cualquier tipo de dato, no es recomendable tener columnas con este tipo de dato, ya que puede ser un indicio de que los datos no est√°n limpios.\nCon el metodo info() podemos ver un resumen de los datos, incluyendo el n√∫mero de valores no nulos y el uso de memoria.\n\n\nC√≥digo\ndata.info()\n\n\n&lt;class 'pandas.core.frame.DataFrame'&gt;\nRangeIndex: 54035 entries, 0 to 54034\nData columns (total 9 columns):\n #   Column           Non-Null Count  Dtype  \n---  ------           --------------  -----  \n 0   cap-diameter     54035 non-null  int64  \n 1   cap-shape        54035 non-null  int64  \n 2   gill-attachment  54035 non-null  int64  \n 3   gill-color       54035 non-null  int64  \n 4   stem-height      54035 non-null  float64\n 5   stem-width       54035 non-null  int64  \n 6   stem-color       54035 non-null  int64  \n 7   season           54035 non-null  float64\n 8   class            54035 non-null  int64  \ndtypes: float64(2), int64(7)\nmemory usage: 3.7 MB\n\n\nGracias a este m√©todo podemos ver que no tenemos valores nulos en nuestro dataset. Si tuvieramos valores nulos, tendr√≠amos que decidir si eliminarlos, reemplazarlos o imputarlos (usar un valor promedio, mediana, moda, etc. para reemplazar los valores nulos).\nPara identificar los valores NA en los datos, podemos usar el m√©todo isna(), combinado con el m√©todo sum() para ver el n√∫mero de valores NA en cada columna.\n\n\nC√≥digo\ndata.isna().sum()\n\n\ncap-diameter       0\ncap-shape          0\ngill-attachment    0\ngill-color         0\nstem-height        0\nstem-width         0\nstem-color         0\nseason             0\nclass              0\ndtype: int64\n\n\nPodemos identificar los valores √∫nicos de una columna con el m√©todo unique(). Por ejemplo, si queremos ver los valores √∫nicos de la columna class, podemos hacer lo siguiente:\n\n\nC√≥digo\ndata['class'].unique()\n\n\narray([1, 0])\n\n\nEn este caso, los valores √∫nicos son 0 y 1, que representan si el hongo es comestible o venenoso. Podemos ver los valores √∫nicos de todas las columnas con el m√©todo unique().",
    "crumbs": [
      "Manejo de Datos y Estad√≠stica con Python",
      "Manipulaci√≥n de datos con Pandas"
    ]
  },
  {
    "objectID": "statistics/data_manipulation.html#estad√≠sticas-descriptivas",
    "href": "statistics/data_manipulation.html#estad√≠sticas-descriptivas",
    "title": "Manipulaci√≥n de datos con Pandas",
    "section": "Estad√≠sticas descriptivas",
    "text": "Estad√≠sticas descriptivas\nPodemos obtener estad√≠sticas descriptivas de los datos num√©ricos con el m√©todo describe().\n\n\nC√≥digo\ndata.describe()\n\n\n\n\n\n\n\n\n\n\ncap-diameter\ncap-shape\ngill-attachment\ngill-color\nstem-height\nstem-width\nstem-color\nseason\nclass\n\n\n\n\ncount\n54035.000000\n54035.000000\n54035.000000\n54035.000000\n54035.000000\n54035.000000\n54035.000000\n54035.000000\n54035.000000\n\n\nmean\n567.257204\n4.000315\n2.142056\n7.329509\n0.759110\n1051.081299\n8.418062\n0.952163\n0.549181\n\n\nstd\n359.883763\n2.160505\n2.228821\n3.200266\n0.650969\n782.056076\n3.262078\n0.305594\n0.497580\n\n\nmin\n0.000000\n0.000000\n0.000000\n0.000000\n0.000426\n0.000000\n0.000000\n0.027372\n0.000000\n\n\n25%\n289.000000\n2.000000\n0.000000\n5.000000\n0.270997\n421.000000\n6.000000\n0.888450\n0.000000\n\n\n50%\n525.000000\n5.000000\n1.000000\n8.000000\n0.593295\n923.000000\n11.000000\n0.943195\n1.000000\n\n\n75%\n781.000000\n6.000000\n4.000000\n10.000000\n1.054858\n1523.000000\n11.000000\n0.943195\n1.000000\n\n\nmax\n1891.000000\n6.000000\n6.000000\n11.000000\n3.835320\n3569.000000\n12.000000\n1.804273\n1.000000\n\n\n\n\n\n\n\n\nPor comodidad se suele usar el m√©todo transpose() para ver las estad√≠sticas descriptivas de manera vertical, una abreviatura de esto es .T.\n\n\nC√≥digo\ndata.describe().T\n\n\n\n\n\n\n\n\n\n\ncount\nmean\nstd\nmin\n25%\n50%\n75%\nmax\n\n\n\n\ncap-diameter\n54035.0\n567.257204\n359.883763\n0.000000\n289.000000\n525.000000\n781.000000\n1891.000000\n\n\ncap-shape\n54035.0\n4.000315\n2.160505\n0.000000\n2.000000\n5.000000\n6.000000\n6.000000\n\n\ngill-attachment\n54035.0\n2.142056\n2.228821\n0.000000\n0.000000\n1.000000\n4.000000\n6.000000\n\n\ngill-color\n54035.0\n7.329509\n3.200266\n0.000000\n5.000000\n8.000000\n10.000000\n11.000000\n\n\nstem-height\n54035.0\n0.759110\n0.650969\n0.000426\n0.270997\n0.593295\n1.054858\n3.835320\n\n\nstem-width\n54035.0\n1051.081299\n782.056076\n0.000000\n421.000000\n923.000000\n1523.000000\n3569.000000\n\n\nstem-color\n54035.0\n8.418062\n3.262078\n0.000000\n6.000000\n11.000000\n11.000000\n12.000000\n\n\nseason\n54035.0\n0.952163\n0.305594\n0.027372\n0.888450\n0.943195\n0.943195\n1.804273\n\n\nclass\n54035.0\n0.549181\n0.497580\n0.000000\n0.000000\n1.000000\n1.000000\n1.000000\n\n\n\n\n\n\n\n\nAlgunas estad√≠sticas descriptivas que obtenemos son:\n\ncount: N√∫mero de valores no nulos.\nmean: Media de los valores.\nstd: Desviaci√≥n est√°ndar de los valores.\nmin: Valor m√≠nimo.\n25%: Primer cuartil.\n50%: Mediana.\n75%: Tercer cuartil.\nmax: Valor m√°ximo.\n\nPodemos guardar estas estad√≠sticas en un nuevo DataFrame para manipularlas m√°s adelante.\n\n\nC√≥digo\nestadisticas = data.describe().T\n\n\nSi recuerdan sus cursos de estad√≠stica una medida de dispersi√≥n es el rango, que es la diferencia entre el valor m√°ximo y el valor m√≠nimo. Podemos calcular el rango de los datos rest√°ndo el valor m√°ximo y el valor m√≠nimo de cada columna y guardarlo en una nueva columna llamada rango.\n\n\nC√≥digo\nestadisticas['rango'] = estadisticas['max'] - estadisticas['min']\nestadisticas.head(9)\n\n\n\n\n\n\n\n\n\n\ncount\nmean\nstd\nmin\n25%\n50%\n75%\nmax\nrango\n\n\n\n\ncap-diameter\n54035.0\n567.257204\n359.883763\n0.000000\n289.000000\n525.000000\n781.000000\n1891.000000\n1891.000000\n\n\ncap-shape\n54035.0\n4.000315\n2.160505\n0.000000\n2.000000\n5.000000\n6.000000\n6.000000\n6.000000\n\n\ngill-attachment\n54035.0\n2.142056\n2.228821\n0.000000\n0.000000\n1.000000\n4.000000\n6.000000\n6.000000\n\n\ngill-color\n54035.0\n7.329509\n3.200266\n0.000000\n5.000000\n8.000000\n10.000000\n11.000000\n11.000000\n\n\nstem-height\n54035.0\n0.759110\n0.650969\n0.000426\n0.270997\n0.593295\n1.054858\n3.835320\n3.834894\n\n\nstem-width\n54035.0\n1051.081299\n782.056076\n0.000000\n421.000000\n923.000000\n1523.000000\n3569.000000\n3569.000000\n\n\nstem-color\n54035.0\n8.418062\n3.262078\n0.000000\n6.000000\n11.000000\n11.000000\n12.000000\n12.000000\n\n\nseason\n54035.0\n0.952163\n0.305594\n0.027372\n0.888450\n0.943195\n0.943195\n1.804273\n1.776901\n\n\nclass\n54035.0\n0.549181\n0.497580\n0.000000\n0.000000\n1.000000\n1.000000\n1.000000\n1.000000\n\n\n\n\n\n\n\n\nOtro estad√≠stico importante es la varianza, que es una medida de dispersi√≥n que nos indica qu√© tan dispersos est√°n los datos. Podemos calcular la varianza de los datos con el m√©todo var() y guardarla en una nueva columna llamada varianza.\n\n\nC√≥digo\nestadisticas['varianza'] = data.var()\nestadisticas.head(9)\n\n\n\n\n\n\n\n\n\n\ncount\nmean\nstd\nmin\n25%\n50%\n75%\nmax\nrango\nvarianza\n\n\n\n\ncap-diameter\n54035.0\n567.257204\n359.883763\n0.000000\n289.000000\n525.000000\n781.000000\n1891.000000\n1891.000000\n129516.323081\n\n\ncap-shape\n54035.0\n4.000315\n2.160505\n0.000000\n2.000000\n5.000000\n6.000000\n6.000000\n6.000000\n4.667783\n\n\ngill-attachment\n54035.0\n2.142056\n2.228821\n0.000000\n0.000000\n1.000000\n4.000000\n6.000000\n6.000000\n4.967642\n\n\ngill-color\n54035.0\n7.329509\n3.200266\n0.000000\n5.000000\n8.000000\n10.000000\n11.000000\n11.000000\n10.241701\n\n\nstem-height\n54035.0\n0.759110\n0.650969\n0.000426\n0.270997\n0.593295\n1.054858\n3.835320\n3.834894\n0.423760\n\n\nstem-width\n54035.0\n1051.081299\n782.056076\n0.000000\n421.000000\n923.000000\n1523.000000\n3569.000000\n3569.000000\n611611.705997\n\n\nstem-color\n54035.0\n8.418062\n3.262078\n0.000000\n6.000000\n11.000000\n11.000000\n12.000000\n12.000000\n10.641151\n\n\nseason\n54035.0\n0.952163\n0.305594\n0.027372\n0.888450\n0.943195\n0.943195\n1.804273\n1.776901\n0.093387\n\n\nclass\n54035.0\n0.549181\n0.497580\n0.000000\n0.000000\n1.000000\n1.000000\n1.000000\n1.000000\n0.247586\n\n\n\n\n\n\n\n\nUn √∫ltimo estad√≠stico es el rango intercuartil (IQR), que es la diferencia entre el tercer cuartil y el primer cuartil. Podemos calcular el IQR de los datos al restar las columnas 75% y 25% y guardar el resultado en una nueva columna llamada IQR.\n\n\nC√≥digo\nestadisticas['IQR'] = estadisticas['75%'] - estadisticas['25%']\n\nestadisticas.head(9)\n\n\n\n\n\n\n\n\n\n\ncount\nmean\nstd\nmin\n25%\n50%\n75%\nmax\nrango\nvarianza\nIQR\n\n\n\n\ncap-diameter\n54035.0\n567.257204\n359.883763\n0.000000\n289.000000\n525.000000\n781.000000\n1891.000000\n1891.000000\n129516.323081\n492.000000\n\n\ncap-shape\n54035.0\n4.000315\n2.160505\n0.000000\n2.000000\n5.000000\n6.000000\n6.000000\n6.000000\n4.667783\n4.000000\n\n\ngill-attachment\n54035.0\n2.142056\n2.228821\n0.000000\n0.000000\n1.000000\n4.000000\n6.000000\n6.000000\n4.967642\n4.000000\n\n\ngill-color\n54035.0\n7.329509\n3.200266\n0.000000\n5.000000\n8.000000\n10.000000\n11.000000\n11.000000\n10.241701\n5.000000\n\n\nstem-height\n54035.0\n0.759110\n0.650969\n0.000426\n0.270997\n0.593295\n1.054858\n3.835320\n3.834894\n0.423760\n0.783861\n\n\nstem-width\n54035.0\n1051.081299\n782.056076\n0.000000\n421.000000\n923.000000\n1523.000000\n3569.000000\n3569.000000\n611611.705997\n1102.000000\n\n\nstem-color\n54035.0\n8.418062\n3.262078\n0.000000\n6.000000\n11.000000\n11.000000\n12.000000\n12.000000\n10.641151\n5.000000\n\n\nseason\n54035.0\n0.952163\n0.305594\n0.027372\n0.888450\n0.943195\n0.943195\n1.804273\n1.776901\n0.093387\n0.054744\n\n\nclass\n54035.0\n0.549181\n0.497580\n0.000000\n0.000000\n1.000000\n1.000000\n1.000000\n1.000000\n0.247586\n1.000000\n\n\n\n\n\n\n\n\nPodemos ver que hemos calculado el rango, la varianza y el IQR de los datos. Estos estad√≠sticos nos dan una idea de la dispersi√≥n de los datos y nos ayudan a entender mejor los datos.\nOtro estadtico importante es la correlaci√≥n, que nos indica la relaci√≥n entre dos variables. Podemos calcular la correlaci√≥n de los datos con el m√©todo corr().\n\n\nC√≥digo\ncorrelacion = data.corr()\ncorrelacion\n\n\n\n\n\n\n\n\n\n\ncap-diameter\ncap-shape\ngill-attachment\ngill-color\nstem-height\nstem-width\nstem-color\nseason\nclass\n\n\n\n\ncap-diameter\n1.000000\n0.204011\n0.200481\n0.186377\n0.135652\n0.828469\n0.121856\n0.113334\n-0.165676\n\n\ncap-shape\n0.204011\n1.000000\n0.043066\n0.131387\n-0.010393\n0.222494\n0.029035\n0.055442\n-0.133338\n\n\ngill-attachment\n0.200481\n0.043066\n1.000000\n0.100276\n-0.075284\n0.245300\n0.020073\n-0.040315\n-0.052541\n\n\ngill-color\n0.186377\n0.131387\n0.100276\n1.000000\n0.015057\n0.110283\n0.186090\n0.059965\n-0.063947\n\n\nstem-height\n0.135652\n-0.010393\n-0.075284\n0.015057\n1.000000\n0.098095\n0.002624\n-0.000292\n0.183354\n\n\nstem-width\n0.828469\n0.222494\n0.245300\n0.110283\n0.098095\n1.000000\n0.157394\n0.040679\n-0.182856\n\n\nstem-color\n0.121856\n0.029035\n0.020073\n0.186090\n0.002624\n0.157394\n1.000000\n0.010750\n-0.128339\n\n\nseason\n0.113334\n0.055442\n-0.040315\n0.059965\n-0.000292\n0.040679\n0.010750\n1.000000\n-0.082919\n\n\nclass\n-0.165676\n-0.133338\n-0.052541\n-0.063947\n0.183354\n-0.182856\n-0.128339\n-0.082919\n1.000000",
    "crumbs": [
      "Manejo de Datos y Estad√≠stica con Python",
      "Manipulaci√≥n de datos con Pandas"
    ]
  },
  {
    "objectID": "statistics/data_manipulation.html#filtrando-datos",
    "href": "statistics/data_manipulation.html#filtrando-datos",
    "title": "Manipulaci√≥n de datos con Pandas",
    "section": "Filtrando datos",
    "text": "Filtrando datos\nPodemos filtrar los datos de acuerdo a una condici√≥n. Por ejemplo, si queremos ver los hongos que son venenosos, podemos filtrar los datos de la siguiente manera:\n\n\nC√≥digo\nvenenosos = data[data['class'] == 1]\nvenenosos.head()\n\n\n\n\n\n\n\n\n\n\ncap-diameter\ncap-shape\ngill-attachment\ngill-color\nstem-height\nstem-width\nstem-color\nseason\nclass\n\n\n\n\n0\n1372\n2\n2\n10\n3.807467\n1545\n11\n1.804273\n1\n\n\n1\n1461\n2\n2\n10\n3.807467\n1557\n11\n1.804273\n1\n\n\n2\n1371\n2\n2\n10\n3.612496\n1566\n11\n1.804273\n1\n\n\n3\n1261\n6\n2\n10\n3.787572\n1566\n11\n1.804273\n1\n\n\n4\n1305\n6\n2\n10\n3.711971\n1464\n11\n0.943195\n1\n\n\n\n\n\n\n\n\nLa notaci√≥n para realizar filtrado en pandas es df[df['columna'] == valor], donde df es el DataFrame, columna es la columna que queremos filtrar y valor es el valor que queremos filtrar.\nPodemos hacer filtrados m√°s complejos, por ejemplo, si queremos ver los hongos venenosos que tienen un di√°metro de sombrero mayor a su media, podemos hacer lo siguiente:\n\n\nC√≥digo\nvenenosos_grandes = data[(data['class'] == 1) & (data['cap-diameter'] &gt; data['cap-diameter'].mean())]\n\nvenenosos_grandes.head()\n\n\n\n\n\n\n\n\n\n\ncap-diameter\ncap-shape\ngill-attachment\ngill-color\nstem-height\nstem-width\nstem-color\nseason\nclass\n\n\n\n\n0\n1372\n2\n2\n10\n3.807467\n1545\n11\n1.804273\n1\n\n\n1\n1461\n2\n2\n10\n3.807467\n1557\n11\n1.804273\n1\n\n\n2\n1371\n2\n2\n10\n3.612496\n1566\n11\n1.804273\n1\n\n\n3\n1261\n6\n2\n10\n3.787572\n1566\n11\n1.804273\n1\n\n\n4\n1305\n6\n2\n10\n3.711971\n1464\n11\n0.943195\n1\n\n\n\n\n\n\n\n\nLa sintaxis en este caso es df[(df['columna1'] == valor1) & (df['columna2'] &gt; valor2)], donde & es el operador l√≥gico AND y cada condici√≥n va entre par√©ntesis. Es recomendable no usar m√°s de dos condiciones en un filtro, ya que puede ser dif√≠cil de leer.\nOtras operaciones l√≥gicas que podemos usar son | para el operador OR y ~ para el operador NOT. Por ejemplo, si queremos ver los hongos que son venenosos o que tienen un di√°metro de sombrero mayor a su media, podemos hacer lo siguiente:\n\n\nC√≥digo\nvenenosos_o_grandes = data[(data['class'] == 1) | (data['cap-diameter'] &gt; data['cap-diameter'].mean())]\n\nvenenosos_o_grandes.head()\n\n\n\n\n\n\n\n\n\n\ncap-diameter\ncap-shape\ngill-attachment\ngill-color\nstem-height\nstem-width\nstem-color\nseason\nclass\n\n\n\n\n0\n1372\n2\n2\n10\n3.807467\n1545\n11\n1.804273\n1\n\n\n1\n1461\n2\n2\n10\n3.807467\n1557\n11\n1.804273\n1\n\n\n2\n1371\n2\n2\n10\n3.612496\n1566\n11\n1.804273\n1\n\n\n3\n1261\n6\n2\n10\n3.787572\n1566\n11\n1.804273\n1\n\n\n4\n1305\n6\n2\n10\n3.711971\n1464\n11\n0.943195\n1",
    "crumbs": [
      "Manejo de Datos y Estad√≠stica con Python",
      "Manipulaci√≥n de datos con Pandas"
    ]
  },
  {
    "objectID": "statistics/data_manipulation.html#ordenando-datos",
    "href": "statistics/data_manipulation.html#ordenando-datos",
    "title": "Manipulaci√≥n de datos con Pandas",
    "section": "Ordenando datos",
    "text": "Ordenando datos\nPodemos ordenar los datos de acuerdo a una columna. Por ejemplo, si queremos ordenar los hongos por su di√°metro de sombrero de manera ascendente, podemos hacer lo siguiente:\n\n\nC√≥digo\ndata.sort_values(by='cap-diameter').head()\n\n\n\n\n\n\n\n\n\n\ncap-diameter\ncap-shape\ngill-attachment\ngill-color\nstem-height\nstem-width\nstem-color\nseason\nclass\n\n\n\n\n11696\n0\n6\n0\n11\n1.019047\n21\n12\n0.943195\n1\n\n\n12214\n1\n2\n1\n6\n0.895698\n42\n7\n0.943195\n1\n\n\n11814\n1\n6\n0\n11\n1.198101\n1\n11\n0.888450\n1\n\n\n12206\n2\n2\n1\n6\n1.058837\n31\n7\n0.943195\n1\n\n\n35395\n2\n0\n0\n3\n1.452757\n174\n6\n0.943195\n1\n\n\n\n\n\n\n\n\nHemos utilizado el m√©todo sort_values() para ordenar los datos de acuerdo a la columna cap-diameter. Por defecto, el m√©todo ordena de manera ascendente, pero podemos cambiarlo a descendente con el argumento ascending=False. El argumento by es la columna por la que queremos ordenar los datos. Si queremos ordenar los datos de manera descendente, podemos hacer lo siguiente:\n\n\nC√≥digo\ndata.sort_values(by='cap-diameter', ascending=False).head()\n\n\n\n\n\n\n\n\n\n\ncap-diameter\ncap-shape\ngill-attachment\ngill-color\nstem-height\nstem-width\nstem-color\nseason\nclass\n\n\n\n\n45984\n1891\n4\n4\n10\n3.413547\n3164\n11\n0.943195\n0\n\n\n26230\n1890\n2\n1\n5\n0.357683\n3149\n11\n1.804273\n1\n\n\n23968\n1890\n2\n0\n4\n0.839141\n2268\n11\n1.804273\n0\n\n\n26229\n1890\n6\n1\n10\n0.878931\n2774\n11\n0.943195\n1\n\n\n46039\n1890\n6\n4\n10\n3.628412\n3338\n11\n0.943195\n0\n\n\n\n\n\n\n\n\nPara ordenar con m√∫ltiples columnas, podemos pasar una lista de columnas al argumento by. Por ejemplo, si queremos ordenar los hongos por su di√°metro de sombrero de manera ascendente y por su altura de tallo de manera descendente, podemos hacer lo siguiente:\n\n\nC√≥digo\ndata.sort_values(by=['cap-diameter', 'stem-height'], ascending=[True, False], kind=\"mergesort\").head(10)\n\n\n\n\n\n\n\n\n\n\ncap-diameter\ncap-shape\ngill-attachment\ngill-color\nstem-height\nstem-width\nstem-color\nseason\nclass\n\n\n\n\n11696\n0\n6\n0\n11\n1.019047\n21\n12\n0.943195\n1\n\n\n11814\n1\n6\n0\n11\n1.198101\n1\n11\n0.888450\n1\n\n\n12214\n1\n2\n1\n6\n0.895698\n42\n7\n0.943195\n1\n\n\n35395\n2\n0\n0\n3\n1.452757\n174\n6\n0.943195\n1\n\n\n12206\n2\n2\n1\n6\n1.058837\n31\n7\n0.943195\n1\n\n\n12207\n2\n6\n1\n6\n0.752455\n40\n12\n0.943195\n1\n\n\n11819\n3\n6\n0\n11\n1.142396\n10\n12\n0.888450\n1\n\n\n11701\n3\n6\n0\n11\n1.098627\n22\n11\n0.888450\n1\n\n\n11738\n4\n6\n0\n11\n1.023026\n23\n12\n0.943195\n1\n\n\n12274\n4\n6\n1\n6\n0.983236\n34\n7\n0.888450\n1\n\n\n\n\n\n\n\n\nCon el argumento kind podemos especificar el algoritmo de ordenamiento. En este caso hemos usado mergesort, que es un algoritmo de ordenamiento estable y eficiente. Otros algoritmos que podemos usar son quicksort y heapsort.\nEl ordenamiento con m√°s de una columna es √∫til cuando queremos ordenar los datos de acuerdo a una columna y en caso de empate, ordenarlos de acuerdo a otra columna. En este caso, primero ordenamos los datos de acuerdo a la columna cap-diameter y en caso de empate, ordenamos los datos de acuerdo a la columna stem-height. Podemos comprobarlo viendo los primeros 10 datos.",
    "crumbs": [
      "Manejo de Datos y Estad√≠stica con Python",
      "Manipulaci√≥n de datos con Pandas"
    ]
  },
  {
    "objectID": "statistics/data_manipulation.html#agrupando-datos",
    "href": "statistics/data_manipulation.html#agrupando-datos",
    "title": "Manipulaci√≥n de datos con Pandas",
    "section": "Agrupando datos",
    "text": "Agrupando datos\nPodemos agrupar los datos de acuerdo a una columna. Por ejemplo, si queremos agrupar los hongos por su color de tallo y ver cu√°ntos hongos hay de cada color, podemos hacer lo siguiente:\n\n\nC√≥digo\ndata.groupby('stem-color').size()\n\n\nstem-color\n0       173\n1      1918\n2      1059\n3      2626\n4       576\n5       226\n6     15316\n7      1848\n8      1025\n9       541\n10     1393\n11    20317\n12     7017\ndtype: int64\n\n\nEl m√©todo groupby() agrupa los datos de acuerdo a una columna y el m√©todo size() nos da el tama√±o de cada grupo. En este caso, hemos agrupado los hongos por su color de tallo y hemos obtenido el tama√±o de cada grupo.\nOtro m√©todo que podemos usar es count(), que nos da el n√∫mero de valores no nulos de cada columna.\n\n\nC√≥digo\ndata.groupby('stem-color').count()\n\n\n\n\n\n\n\n\n\n\ncap-diameter\ncap-shape\ngill-attachment\ngill-color\nstem-height\nstem-width\nseason\nclass\n\n\nstem-color\n\n\n\n\n\n\n\n\n\n\n\n\n0\n173\n173\n173\n173\n173\n173\n173\n173\n\n\n1\n1918\n1918\n1918\n1918\n1918\n1918\n1918\n1918\n\n\n2\n1059\n1059\n1059\n1059\n1059\n1059\n1059\n1059\n\n\n3\n2626\n2626\n2626\n2626\n2626\n2626\n2626\n2626\n\n\n4\n576\n576\n576\n576\n576\n576\n576\n576\n\n\n5\n226\n226\n226\n226\n226\n226\n226\n226\n\n\n6\n15316\n15316\n15316\n15316\n15316\n15316\n15316\n15316\n\n\n7\n1848\n1848\n1848\n1848\n1848\n1848\n1848\n1848\n\n\n8\n1025\n1025\n1025\n1025\n1025\n1025\n1025\n1025\n\n\n9\n541\n541\n541\n541\n541\n541\n541\n541\n\n\n10\n1393\n1393\n1393\n1393\n1393\n1393\n1393\n1393\n\n\n11\n20317\n20317\n20317\n20317\n20317\n20317\n20317\n20317\n\n\n12\n7017\n7017\n7017\n7017\n7017\n7017\n7017\n7017\n\n\n\n\n\n\n\n\nLa diferencia es que size() nos da el tama√±o de cada grupo, mientras que count() nos da el n√∫mero de valores no nulos de cada columna.\nPara hacer operaciones m√°s complejas, podemos usar el m√©todo agg(), que nos permite aplicar una o m√°s funciones a cada grupo. Por ejemplo, si queremos obtener la media y la mediana del di√°metro de sombrero de cada grupo, podemos hacer lo siguiente:\n\n\nC√≥digo\ndata.groupby('stem-color')['cap-diameter'].agg(['mean', 'median'])\n\n\n\n\n\n\n\n\n\n\nmean\nmedian\n\n\nstem-color\n\n\n\n\n\n\n0\n957.127168\n962.0\n\n\n1\n498.565172\n458.5\n\n\n2\n338.590179\n331.0\n\n\n3\n454.637091\n395.0\n\n\n4\n385.489583\n38.0\n\n\n5\n377.615044\n384.0\n\n\n6\n544.769130\n518.0\n\n\n7\n375.433442\n377.0\n\n\n8\n726.983415\n756.0\n\n\n9\n632.057301\n431.0\n\n\n10\n685.408471\n765.0\n\n\n11\n659.824531\n637.0\n\n\n12\n453.907653\n438.0\n\n\n\n\n\n\n\n\nEn este caso, hemos agrupado los hongos por su color de tallo y hemos obtenido la media y la mediana del di√°metro de sombrero de cada grupo.",
    "crumbs": [
      "Manejo de Datos y Estad√≠stica con Python",
      "Manipulaci√≥n de datos con Pandas"
    ]
  },
  {
    "objectID": "statistics/data_manipulation.html#guardando-datos",
    "href": "statistics/data_manipulation.html#guardando-datos",
    "title": "Manipulaci√≥n de datos con Pandas",
    "section": "Guardando datos",
    "text": "Guardando datos\nPodemos guardar los datos en un archivo CSV con el m√©todo to_csv(). Por ejemplo, si queremos guardar los datos en un archivo llamado mushroom.csv, podemos hacer lo siguiente:\n\n\nC√≥digo\n#data.to_csv('mushroom.csv', index=False)\n\n\nEl argumento index=False evita que se guarde el √≠ndice en el archivo CSV. Existen otros formatos en los que podemos guardar los datos, como Excel, JSON, entre otros. Para guardar los datos en un archivo Excel, podemos usar el m√©todo to_excel().\n\n\nC√≥digo\n#data.to_excel('mushroom.xlsx', index=False)\n\n\nPara guardar los datos en un archivo JSON, podemos usar el m√©todo to_json().\n\n\nC√≥digo\n#data.to_json('mushroom.json', orient='records')",
    "crumbs": [
      "Manejo de Datos y Estad√≠stica con Python",
      "Manipulaci√≥n de datos con Pandas"
    ]
  },
  {
    "objectID": "statistics/data_manipulation.html#ejercicios",
    "href": "statistics/data_manipulation.html#ejercicios",
    "title": "Manipulaci√≥n de datos con Pandas",
    "section": "Ejercicios",
    "text": "Ejercicios\nCreen un documento de Jupyter Notebook por equipo y resuelvan los siguientes ejercicios, utilicen Markdown para explicar sus respuestas y comentarios en el c√≥digo. Se sugiere la creaci√≥n de funciones para resolver los ejercicios.\n\nCarga los datos de Iris desde la siguiente liga ‚Äúhttps://raw.githubusercontent.com/mwaskom/seaborn-data/master/iris.csv‚Äù y muestra las primeras 10 filas, muestra la forma de los datos, los nombres de las columnas, los tipos de datos, el tama√±o de los datos y si hay valores nulos (NA).\nCalcula las estad√≠sticas descriptivas de los datos.\nFiltra los datos para obtener las flores que tienen un ancho de p√©talo mayor a su media, mediana, media y mediana. Impreme las primeras 10 filas.\nOrdena los datos de acuerdo a la longitud de s√©palo de manera ascendente y de acuerdo a la longitud de p√©talo de manera descendente. Muestra las primeras 10 filas.\nFiltra los datos para obtener las flores que tienen un ancho de p√©talo mayor a su media y que son de la especie setosa. Muestra las primeras 10 filas.\nAgrupa los datos por especie y calcula los estad√≠sticos descriptivos de cada grupo (media, mediana, moda, varianza, rango, IQR). Muestra los resultados.\nGuarda los datos de los estad√≠sticos descriptivos del ejercicio 2 en un archivo CSV, Excel y JSON.\nCalcula la correlaci√≥n de los datos y muestra los resultados.\nSugiere que gr√°ficos podr√≠as hacer con los datos y que informaci√≥n podr√≠as obtener de ellos.\nExplica ¬øqu√© an√°lisis podr√≠as hacer con los datos?, ¬øqu√© preguntas podr√≠as responder con los datos?",
    "crumbs": [
      "Manejo de Datos y Estad√≠stica con Python",
      "Manipulaci√≥n de datos con Pandas"
    ]
  },
  {
    "objectID": "statistics/data-visualization.html",
    "href": "statistics/data-visualization.html",
    "title": "Visualizaci√≥n de datos",
    "section": "",
    "text": "La visualizaci√≥n de datos es una herramienta fundamental en el an√°lisis de datos. Nos permite entender de manera r√°pida y sencilla la informaci√≥n que tenemos a nuestra disposici√≥n. En este tutorial vamos a ver c√≥mo podemos visualizar datos en Python utilizando la librer√≠a matplotlib y seaborn, que son las librer√≠as m√°s populares para visualizaci√≥n de datos en Python.\nEn Google Colab, podemos visualizar datos utilizando las librer√≠as matplotlib y seaborn ya que vienen instaladas por defecto. Para instalar estas librer√≠as de forma local, podemos utilizar el siguiente comando en una celda de Jupyter Notebook:\n!pip install matplotlib seaborn\nSi estas usando un archivo con extensi√≥n .py, puedes instalar las librer√≠as utilizando el comando en la terminal:\npip install matplotlib seaborn\n\n\nMatplotlib es una librer√≠a de visualizaci√≥n de datos en 2D que produce gr√°ficos de alta calidad en una variedad de formatos y entornos. En este tutorial vamos a ver c√≥mo podemos utilizar matplotlib para visualizar datos en Python.\nUtilizaremos los datos de hongos que vimos en el tutorial anterior para hacer una visualizaci√≥n de los datos. Primero, vamos a cargar los datos.\n\n\nC√≥digo\nimport pandas as pd\n\nurl = \"https://raw.githubusercontent.com/Christian-F-Badillo/Ciencia-de-datos-con-Python-de-estadistica-descriptiva-a-redes-neuronales/main/data/archive/mushroom_cleaned.csv\"\ndata = pd.read_csv(url)\ndata.head()\n\n\n\n\n\n\n\n\n\n\ncap-diameter\ncap-shape\ngill-attachment\ngill-color\nstem-height\nstem-width\nstem-color\nseason\nclass\n\n\n\n\n0\n1372\n2\n2\n10\n3.807467\n1545\n11\n1.804273\n1\n\n\n1\n1461\n2\n2\n10\n3.807467\n1557\n11\n1.804273\n1\n\n\n2\n1371\n2\n2\n10\n3.612496\n1566\n11\n1.804273\n1\n\n\n3\n1261\n6\n2\n10\n3.787572\n1566\n11\n1.804273\n1\n\n\n4\n1305\n6\n2\n10\n3.711971\n1464\n11\n0.943195\n1\n\n\n\n\n\n\n\n\nUna gran ventaja de usar pandas y matplotlib juntos es que podemos visualizar los datos directamente desde un DataFrame. Por ejemplo, podemos hacer un histograma de la variable cap-shape.\n\n\nC√≥digo\nimport matplotlib.pyplot as plt\n\ndata[\"cap-shape\"].value_counts().plot(kind=\"bar\")\nplt.title(\"Distribuci√≥n de la forma del sombrero\")\nplt.show()\n\n\n\n\n\n\n\n\n\nEn este caso, utilizamos el m√©todo value_counts() para contar el n√∫mero de valores √∫nicos en la columna cap-shape y luego utilizamos el m√©todo plot() para hacer un histograma de los valores. Finalmente, utilizamos el m√©todo show() para mostrar el gr√°fico.\nEl parametro kind nos permite especificar el tipo de gr√°fico que queremos hacer. En este caso, utilizamos bar para hacer un histograma de barras. De acuerdo a la documentaci√≥n de plot(), los valores v√°lidos para el parametro kind son:\n\nline: Gr√°fico de l√≠nea.\nbar: Gr√°fico de barras.\nbarh: Gr√°fico de barras horizontales.\nhist: Histograma.\nbox: Diagrama de caja.\nkde: Estimaci√≥n de densidad de kernel.\ndensity: Estimaci√≥n de densidad.\narea: Gr√°fico de √°rea.\npie: Gr√°fico de pastel.\nscatter: Gr√°fico de dispersi√≥n.\nhexbin.: Gr√°fico que puede considerarse una mezcla de un histograma y un gr√°fico de dispersi√≥n.\n\n\nAdem√°s, podemos personalizar el gr√°fico utilizando los m√©todos de matplotlib. Por ejemplo, podemos cambiar el color de las barras y agregar etiquetas a los ejes. A pesar de la utilidad de pandas y matplotlib, a veces es necesario utilizar matplotlib directamente para hacer gr√°ficos m√°s complejos.\nEl primer paso para crear un gr√°fico con matplotlib es crear una figura y un eje. Luego, podemos utilizar los m√©todos de matplotlib para personalizar el gr√°fico. Por ejemplo, podemos hacer un gr√°fico de dispersi√≥n de las variables cap-diameter y stem-height.\n\n\nC√≥digo\nfig, ax = plt.subplots()\n\nax.scatter(data[\"cap-diameter\"], data[\"stem-height\"])\nax.set_title(\"Gr√°fico de dispersi√≥n de di√°metro del sombrero y altura del tallo\")\nax.set_xlabel(\"Di√°metro del sombrero\")\nax.set_ylabel(\"Altura del tallo\")\n\nplt.show()\n\n\n\n\n\n\n\n\n\nEn este caso, utilizamos el m√©todo subplots() para crear una figura y un eje. Luego, utilizamos el m√©todo scatter() para hacer un gr√°fico de dispersi√≥n de las variables cap-diameter y stem-height. Finalmente, utilizamos los m√©todos set_title(), set_xlabel() y set_ylabel() para personalizar el gr√°fico.\nEditemos a√∫n m√°s el gr√°fico para que sea m√°s informativo. Podemos cambiar el color de los puntos, agregar una leyenda y cambiar el tama√±o de los puntos.\n\n\nC√≥digo\nfig, ax = plt.subplots(figsize=(10, 6))\n\nax.scatter(data[\"cap-diameter\"], data[\"stem-height\"], c=data[\"class\"], s=50, alpha=0.25)\nax.set_title(\"Gr√°fico de dispersi√≥n de di√°metro del sombrero y altura del tallo\")\nax.set_xlabel(\"Di√°metro del sombrero\")\nax.set_ylabel(\"Altura del tallo\")\nax.legend(labels=[\"Comestible\", \"Venenoso\"], title=\"Clase\")\n\nplt.show()\n\n\n\n\n\n\n\n\n\nEn este caso, utilizamos el parametro c para cambiar el color de los puntos de acuerdo a la variable class, el parametro s para cambiar el tama√±o de los puntos y el parametro alpha para cambiar la transparencia de los puntos. Adem√°s, utilizamos el m√©todo legend() para agregar una leyenda al gr√°fico.\nAhora veamos como hacer un histograma de las variables cap-diameter usando los m√©todos de matplotlib.\n\n\nC√≥digo\nfig, ax = plt.subplots()\n\nax.hist(data[\"cap-diameter\"], bins=20, color=\"skyblue\", edgecolor=\"black\")\nax.set_title(\"Histograma del di√°metro del sombrero\")\nax.set_xlabel(\"Di√°metro del sombrero\")\nax.set_ylabel(\"Frecuencia\")\n\nplt.show()\n\n\n\n\n\n\n\n\n\nEn este caso, utilizamos el m√©todo hist() para hacer un histograma de la variable cap-diameter. El parametro bins nos permite especificar el n√∫mero de contenedores en el histograma. Adem√°s, utilizamos los parametros color y edgecolor para cambiar el color de las barras y el color de los bordes de las barras.\nAhora filtremos los datos para los hongos comestibles.\n\n\nC√≥digo\nedible = data[data[\"class\"] == 1]\n\nedible = edible[[\"cap-diameter\", \"stem-height\"]]\n\nedible.head()\n\n\n\n\n\n\n\n\n\n\ncap-diameter\nstem-height\n\n\n\n\n0\n1372\n3.807467\n\n\n1\n1461\n3.807467\n\n\n2\n1371\n3.612496\n\n\n3\n1261\n3.787572\n\n\n4\n1305\n3.711971\n\n\n\n\n\n\n\n\nHagamos un gr√°fico de hexbin de las variables cap-diameter y stem-height para los hongos comestibles.\n\n\nC√≥digo\nfig = plt.figure(figsize=(10, 6))\n\nax = edible.plot.hexbin(x=\"cap-diameter\", y=\"stem-height\", gridsize=20, cmap=\"coolwarm\")\n\nax.set_title(\"Gr√°fico de hexbin de di√°metro del sombrero y altura del tallo para hongos comestibles\")\nax.set_xlabel(\"Di√°metro del sombrero\")\nax.set_ylabel(\"Altura del tallo\")\n\nplt.show()\n\n\n&lt;Figure size 960x576 with 0 Axes&gt;\n\n\n\n\n\n\n\n\n\nEn un gr√°fico de hexbin, los puntos se agrupan en hex√°gonos y el color de los hex√°gonos se basa en el n√∫mero de puntos en cada hex√°gono. En este caso, utilizamos el parametro gridsize para especificar el tama√±o de los hex√°gonos y el parametro cmap para cambiar el mapa de colores.\nLa sintaxis que usamos aqu√≠ es otra forma de hacer los gr√°ficos. Primerop creamos la figura con plt.figure() y luego utilizamos el m√©todo plot.hexbin() para hacer el gr√°fico de hexbin que nos ofrece la clase DataFrame de pandas. Finalmente, utilizamos los m√©todos set_title(), set_xlabel() y set_ylabel() para personalizar el gr√°fico.\n\n\n\nSeaborn es una librer√≠a de visualizaci√≥n de datos en Python que se basa en matplotlib y proporciona una interfaz de alto nivel para crear gr√°ficos atractivos y informativos. En este tutorial vamos a ver c√≥mo podemos utilizar seaborn para visualizar datos en Python.\nPrimero, hagamos un gr√°fico de cajas de las variables cap-diameter para los hongos comestibles y venenosos.\n\n\nC√≥digo\nimport seaborn as sns\n\nfig, ax = plt.subplots(figsize=(10, 6))\n\nsns.boxplot(x=\"class\", y=\"cap-diameter\", data=data, ax=ax)\nax.set_title(\"Diagrama de caja del di√°metro del sombrero por clase\")\nax.set_xlabel(\"Clase\")\nax.set_ylabel(\"Di√°metro del sombrero\")\n\nplt.show()\n\n\n\n\n\n\n\n\n\nPersonalicemos el gr√°fico para que sea m√°s informativo. Podemos cambiar el color de las cajas y los bigotes, agregar una leyenda y cambiar el tama√±o de las cajas.\n\n\nC√≥digo\nfig, ax = plt.subplots(figsize=(10, 6))\n\nsns.boxplot(hue=\"class\", x=\"class\", y=\"cap-diameter\", data=data, ax=ax, palette=\"Set2\", linewidth=2)\n\nax.set_title(\"Diagrama de caja del di√°metro del sombrero por clase\")\nax.set_xlabel(\"Clase\")\nax.set_ylabel(\"Di√°metro del sombrero\")\n\nplt.show()\n\n\n\n\n\n\n\n\n\nAhora aumentemos el tama√±o de la letra de las etiquetas de los ejes, agreguemos que los valores at√≠picos se muestren como puntos y cambiemos el estilo de las cajas.\n\n\nC√≥digo\nfig, ax = plt.subplots(figsize=(10, 6))\n\nsns.boxplot(hue=\"class\", x=\"class\", y=\"cap-diameter\", data=data, ax=ax, \n            palette=\"Set2\", linewidth=2, fliersize=5, notch=True)\n\nax.set_title(\"Diagrama de caja del di√°metro del sombrero por clase\", fontsize=16)\nax.set_xlabel(\"Clase\", fontsize=14)\nax.set_ylabel(\"Di√°metro del sombrero\", fontsize=14)\n\nplt.show()\n\n\n\n\n\n\n\n\n\nUsemos los mismos datos para crear un gr√°fico de viol√≠n de las variables cap-diameter para los hongos comestibles y venenosos.\n\n\nC√≥digo\nfig, ax = plt.subplots(figsize=(10, 6))\n\nsns.violinplot(x=\"class\", y=\"cap-diameter\", data=data, ax=ax, hue=\"class\", palette=\"Set1\")\n\nax.set_title(\"Gr√°fico de viol√≠n del di√°metro del sombrero por clase\", fontsize=16, fontweight=\"bold\")\nax.set_xlabel(\"Clase\", fontsize=14)\nax.set_ylabel(\"Di√°metro del sombrero\", fontsize=14)\n\nplt.show()\n\n\n\n\n\n\n\n\n\nEn un gr√°fico de viol√≠n, la forma del viol√≠n representa la distribuci√≥n de los datos. En este caso, utilizamos el parametro hue para cambiar el color de los violines de acuerdo a la variable class y el parametro palette para cambiar la paleta de colores. Nos incluye un gr√°fico de caja en el interior del viol√≠n, que nos permite ver la distribuci√≥n de los datos de una manera m√°s detallada. Modifiquemos el gr√°fico para que sea m√°s informativo.\n\n\nC√≥digo\nfig, ax = plt.subplots(figsize=(10, 6))\n\nsns.violinplot(x=\"class\", y=\"cap-diameter\", data=data, ax=ax, \n                hue=\"class\", palette=\"Set1\", inner=\"box\", fill=False,\n                inner_kws={\"linewidth\": 1.5, \"box_width\": 17, \"whis_width\":2})\n\nax.set_title(\"Gr√°fico de viol√≠n del di√°metro del sombrero por clase\", fontsize=16, fontweight=\"bold\")\nax.set_xlabel(\"Clase\", fontsize=14)\nax.set_ylabel(\"Di√°metro del sombrero\", fontsize=14)\n\nplt.show()\n\n\n\n\n\n\n\n\n\nAqu√≠ hemos especificado que el interior del viol√≠n sea un gr√°fico de caja con el parametro inner=\"box\". Adem√°s, hemos cambiado el ancho de las cajas con el parametro inner_kws={\"box_width\": 17} y el ancho de los bigotes con el parametro inner_kws={\"whis_width\": 2}. Con el parametro fill=False, hemos eliminado el relleno del viol√≠n.\nUn gr√°fico √∫til a la hora de analizar datos es la matriz de correlaci√≥n. La matriz de correlaci√≥n nos permite ver c√≥mo se relacionan las variables entre s√≠. En seaborn, podemos hacer una matriz de correlaci√≥n utilizando el m√©todo heatmap().\n\n\nC√≥digo\nfig, ax = plt.subplots(figsize=(10, 6))\n\ncorr = data.corr()\n\nsns.heatmap(corr, annot=True, cmap=\"coolwarm\", ax=ax, vmax=1, vmin=-1)\n\nax.set_title(\"Matriz de correlaci√≥n de las variables\", fontsize=16, fontweight=\"bold\")\n\nplt.show()\n\n\n\n\n\n\n\n\n\nEn este caso, utilizamos el m√©todo corr() para calcular la matriz de correlaci√≥n de los datos y luego utilizamos el m√©todo heatmap() para hacer una matriz de correlaci√≥n. El parametro annot=True nos permite mostrar los valores de la correlaci√≥n en los cuadros y el parametro cmap=\"coolwarm\" nos permite cambiar el mapa de colores. Los parametros vmax y vmin nos permiten especificar los valores m√°ximos y m√≠nimos de la escala de colores, sino se dan, se toman los valores m√°ximos y m√≠nimos de la matriz de correlaci√≥n.\nUna buena forma de presentar los datos de dos variables es juntar un gr√°fico de dispersi√≥n con un histograma. En seaborn, podemos hacer un gr√°fico de dispersi√≥n con histogramas utilizando el m√©todo jointplot().\n\n\nC√≥digo\nfig = plt.figure(figsize=(10, 6))\n\nsns.jointplot(x=\"cap-diameter\", y=\"stem-height\", data=data, kind=\"scatter\", color=\"skyblue\")\n\nplt.show()\n\n\n&lt;Figure size 960x576 with 0 Axes&gt;\n\n\n\n\n\n\n\n\n\nEn este caso, utilizamos el parametro kind=\"scatter\" para hacer un gr√°fico de dispersi√≥n. Los valores v√°lidos para el parametro kind son:\n\nscatter: Gr√°fico de dispersi√≥n.\nkde: Estimaci√≥n de densidad de kernel.\nhist: Histograma.\nhex: Gr√°fico de hexbin.\nreg: Gr√°fico de regresi√≥n.\nresid: Gr√°fico de residuos.\n\nAdem√°s con el par√°metro hue podemos cambiar el color de los puntos de acuerdo a una variable categ√≥rica.\n\n\nC√≥digo\nfig = plt.figure(figsize=(10, 6))\n\nax = sns.jointplot(x=\"cap-diameter\", y=\"stem-height\", data=data, \n                    kind=\"scatter\", color=\"skyblue\", hue=\"class\")\n\nax.set_axis_labels(\"Di√°metro del sombrero\", \"Altura del tallo\", fontsize=12)\nax.fig.suptitle(\"Gr√°fico de dispersi√≥n de di√°metro del sombrero y altura del tallo\", \n                fontsize=14, fontweight=\"bold\", y = 1.02)\n\nplt.show()\n\n\n&lt;Figure size 960x576 with 0 Axes&gt;\n\n\n\n\n\n\n\n\n\nEste gr√°fico nos permite ver la relaci√≥n entre dos variables y la distribuci√≥n de cada variable de forma simult√°nea. Vemos que no hay diferencias claras entre las variables cap-diameter y stem-height para los hongos comestibles y venenosos.\nSeaborn tiene una funci√≥n para mostrar gr√°ficos con la relaci√≥n entre todas las variables de un DataFrame. Esta funci√≥n se llama pairplot().\n\n\nC√≥digo\nfig = plt.figure(figsize=(10, 6))\n\nsns.pairplot(data, hue=\"class\", palette=\"Set1\")\n\nplt.show()\n\n\n&lt;Figure size 960x576 with 0 Axes&gt;\n\n\n\n\n\n\n\n\n\nSi son muchas variables, podemos seleccionar solo algunas para hacer el gr√°fico. En este caso, seleccionamos las variables cap-diameter, stem-height, cap-surface y cap-color.\n\n\nC√≥digo\nfig = plt.figure(figsize=(10, 6))\n\nsns.pairplot(data[[\"cap-diameter\", \"stem-height\", \"class\"]], hue=\"class\", palette=\"Set1\")\n\nplt.show()\n\n\n&lt;Figure size 960x576 with 0 Axes&gt;\n\n\n\n\n\n\n\n\n\nNos mostrar√° un gr√°fico de dispersi√≥n de todas las variables seleccionadas y un histograma de cada variable en la diagonal. Adem√°s, podemos cambiar el color de los puntos de acuerdo a una variable categ√≥rica con el parametro hue.",
    "crumbs": [
      "Manejo de Datos y Estad√≠stica con Python",
      "Visualizaci√≥n de datos"
    ]
  },
  {
    "objectID": "statistics/data-visualization.html#matplotlib",
    "href": "statistics/data-visualization.html#matplotlib",
    "title": "Visualizaci√≥n de datos",
    "section": "",
    "text": "Matplotlib es una librer√≠a de visualizaci√≥n de datos en 2D que produce gr√°ficos de alta calidad en una variedad de formatos y entornos. En este tutorial vamos a ver c√≥mo podemos utilizar matplotlib para visualizar datos en Python.\nUtilizaremos los datos de hongos que vimos en el tutorial anterior para hacer una visualizaci√≥n de los datos. Primero, vamos a cargar los datos.\n\n\nC√≥digo\nimport pandas as pd\n\nurl = \"https://raw.githubusercontent.com/Christian-F-Badillo/Ciencia-de-datos-con-Python-de-estadistica-descriptiva-a-redes-neuronales/main/data/archive/mushroom_cleaned.csv\"\ndata = pd.read_csv(url)\ndata.head()\n\n\n\n\n\n\n\n\n\n\ncap-diameter\ncap-shape\ngill-attachment\ngill-color\nstem-height\nstem-width\nstem-color\nseason\nclass\n\n\n\n\n0\n1372\n2\n2\n10\n3.807467\n1545\n11\n1.804273\n1\n\n\n1\n1461\n2\n2\n10\n3.807467\n1557\n11\n1.804273\n1\n\n\n2\n1371\n2\n2\n10\n3.612496\n1566\n11\n1.804273\n1\n\n\n3\n1261\n6\n2\n10\n3.787572\n1566\n11\n1.804273\n1\n\n\n4\n1305\n6\n2\n10\n3.711971\n1464\n11\n0.943195\n1\n\n\n\n\n\n\n\n\nUna gran ventaja de usar pandas y matplotlib juntos es que podemos visualizar los datos directamente desde un DataFrame. Por ejemplo, podemos hacer un histograma de la variable cap-shape.\n\n\nC√≥digo\nimport matplotlib.pyplot as plt\n\ndata[\"cap-shape\"].value_counts().plot(kind=\"bar\")\nplt.title(\"Distribuci√≥n de la forma del sombrero\")\nplt.show()\n\n\n\n\n\n\n\n\n\nEn este caso, utilizamos el m√©todo value_counts() para contar el n√∫mero de valores √∫nicos en la columna cap-shape y luego utilizamos el m√©todo plot() para hacer un histograma de los valores. Finalmente, utilizamos el m√©todo show() para mostrar el gr√°fico.\nEl parametro kind nos permite especificar el tipo de gr√°fico que queremos hacer. En este caso, utilizamos bar para hacer un histograma de barras. De acuerdo a la documentaci√≥n de plot(), los valores v√°lidos para el parametro kind son:\n\nline: Gr√°fico de l√≠nea.\nbar: Gr√°fico de barras.\nbarh: Gr√°fico de barras horizontales.\nhist: Histograma.\nbox: Diagrama de caja.\nkde: Estimaci√≥n de densidad de kernel.\ndensity: Estimaci√≥n de densidad.\narea: Gr√°fico de √°rea.\npie: Gr√°fico de pastel.\nscatter: Gr√°fico de dispersi√≥n.\nhexbin.: Gr√°fico que puede considerarse una mezcla de un histograma y un gr√°fico de dispersi√≥n.\n\n\nAdem√°s, podemos personalizar el gr√°fico utilizando los m√©todos de matplotlib. Por ejemplo, podemos cambiar el color de las barras y agregar etiquetas a los ejes. A pesar de la utilidad de pandas y matplotlib, a veces es necesario utilizar matplotlib directamente para hacer gr√°ficos m√°s complejos.\nEl primer paso para crear un gr√°fico con matplotlib es crear una figura y un eje. Luego, podemos utilizar los m√©todos de matplotlib para personalizar el gr√°fico. Por ejemplo, podemos hacer un gr√°fico de dispersi√≥n de las variables cap-diameter y stem-height.\n\n\nC√≥digo\nfig, ax = plt.subplots()\n\nax.scatter(data[\"cap-diameter\"], data[\"stem-height\"])\nax.set_title(\"Gr√°fico de dispersi√≥n de di√°metro del sombrero y altura del tallo\")\nax.set_xlabel(\"Di√°metro del sombrero\")\nax.set_ylabel(\"Altura del tallo\")\n\nplt.show()\n\n\n\n\n\n\n\n\n\nEn este caso, utilizamos el m√©todo subplots() para crear una figura y un eje. Luego, utilizamos el m√©todo scatter() para hacer un gr√°fico de dispersi√≥n de las variables cap-diameter y stem-height. Finalmente, utilizamos los m√©todos set_title(), set_xlabel() y set_ylabel() para personalizar el gr√°fico.\nEditemos a√∫n m√°s el gr√°fico para que sea m√°s informativo. Podemos cambiar el color de los puntos, agregar una leyenda y cambiar el tama√±o de los puntos.\n\n\nC√≥digo\nfig, ax = plt.subplots(figsize=(10, 6))\n\nax.scatter(data[\"cap-diameter\"], data[\"stem-height\"], c=data[\"class\"], s=50, alpha=0.25)\nax.set_title(\"Gr√°fico de dispersi√≥n de di√°metro del sombrero y altura del tallo\")\nax.set_xlabel(\"Di√°metro del sombrero\")\nax.set_ylabel(\"Altura del tallo\")\nax.legend(labels=[\"Comestible\", \"Venenoso\"], title=\"Clase\")\n\nplt.show()\n\n\n\n\n\n\n\n\n\nEn este caso, utilizamos el parametro c para cambiar el color de los puntos de acuerdo a la variable class, el parametro s para cambiar el tama√±o de los puntos y el parametro alpha para cambiar la transparencia de los puntos. Adem√°s, utilizamos el m√©todo legend() para agregar una leyenda al gr√°fico.\nAhora veamos como hacer un histograma de las variables cap-diameter usando los m√©todos de matplotlib.\n\n\nC√≥digo\nfig, ax = plt.subplots()\n\nax.hist(data[\"cap-diameter\"], bins=20, color=\"skyblue\", edgecolor=\"black\")\nax.set_title(\"Histograma del di√°metro del sombrero\")\nax.set_xlabel(\"Di√°metro del sombrero\")\nax.set_ylabel(\"Frecuencia\")\n\nplt.show()\n\n\n\n\n\n\n\n\n\nEn este caso, utilizamos el m√©todo hist() para hacer un histograma de la variable cap-diameter. El parametro bins nos permite especificar el n√∫mero de contenedores en el histograma. Adem√°s, utilizamos los parametros color y edgecolor para cambiar el color de las barras y el color de los bordes de las barras.\nAhora filtremos los datos para los hongos comestibles.\n\n\nC√≥digo\nedible = data[data[\"class\"] == 1]\n\nedible = edible[[\"cap-diameter\", \"stem-height\"]]\n\nedible.head()\n\n\n\n\n\n\n\n\n\n\ncap-diameter\nstem-height\n\n\n\n\n0\n1372\n3.807467\n\n\n1\n1461\n3.807467\n\n\n2\n1371\n3.612496\n\n\n3\n1261\n3.787572\n\n\n4\n1305\n3.711971\n\n\n\n\n\n\n\n\nHagamos un gr√°fico de hexbin de las variables cap-diameter y stem-height para los hongos comestibles.\n\n\nC√≥digo\nfig = plt.figure(figsize=(10, 6))\n\nax = edible.plot.hexbin(x=\"cap-diameter\", y=\"stem-height\", gridsize=20, cmap=\"coolwarm\")\n\nax.set_title(\"Gr√°fico de hexbin de di√°metro del sombrero y altura del tallo para hongos comestibles\")\nax.set_xlabel(\"Di√°metro del sombrero\")\nax.set_ylabel(\"Altura del tallo\")\n\nplt.show()\n\n\n&lt;Figure size 960x576 with 0 Axes&gt;\n\n\n\n\n\n\n\n\n\nEn un gr√°fico de hexbin, los puntos se agrupan en hex√°gonos y el color de los hex√°gonos se basa en el n√∫mero de puntos en cada hex√°gono. En este caso, utilizamos el parametro gridsize para especificar el tama√±o de los hex√°gonos y el parametro cmap para cambiar el mapa de colores.\nLa sintaxis que usamos aqu√≠ es otra forma de hacer los gr√°ficos. Primerop creamos la figura con plt.figure() y luego utilizamos el m√©todo plot.hexbin() para hacer el gr√°fico de hexbin que nos ofrece la clase DataFrame de pandas. Finalmente, utilizamos los m√©todos set_title(), set_xlabel() y set_ylabel() para personalizar el gr√°fico.",
    "crumbs": [
      "Manejo de Datos y Estad√≠stica con Python",
      "Visualizaci√≥n de datos"
    ]
  },
  {
    "objectID": "statistics/data-visualization.html#seaborn",
    "href": "statistics/data-visualization.html#seaborn",
    "title": "Visualizaci√≥n de datos",
    "section": "",
    "text": "Seaborn es una librer√≠a de visualizaci√≥n de datos en Python que se basa en matplotlib y proporciona una interfaz de alto nivel para crear gr√°ficos atractivos y informativos. En este tutorial vamos a ver c√≥mo podemos utilizar seaborn para visualizar datos en Python.\nPrimero, hagamos un gr√°fico de cajas de las variables cap-diameter para los hongos comestibles y venenosos.\n\n\nC√≥digo\nimport seaborn as sns\n\nfig, ax = plt.subplots(figsize=(10, 6))\n\nsns.boxplot(x=\"class\", y=\"cap-diameter\", data=data, ax=ax)\nax.set_title(\"Diagrama de caja del di√°metro del sombrero por clase\")\nax.set_xlabel(\"Clase\")\nax.set_ylabel(\"Di√°metro del sombrero\")\n\nplt.show()\n\n\n\n\n\n\n\n\n\nPersonalicemos el gr√°fico para que sea m√°s informativo. Podemos cambiar el color de las cajas y los bigotes, agregar una leyenda y cambiar el tama√±o de las cajas.\n\n\nC√≥digo\nfig, ax = plt.subplots(figsize=(10, 6))\n\nsns.boxplot(hue=\"class\", x=\"class\", y=\"cap-diameter\", data=data, ax=ax, palette=\"Set2\", linewidth=2)\n\nax.set_title(\"Diagrama de caja del di√°metro del sombrero por clase\")\nax.set_xlabel(\"Clase\")\nax.set_ylabel(\"Di√°metro del sombrero\")\n\nplt.show()\n\n\n\n\n\n\n\n\n\nAhora aumentemos el tama√±o de la letra de las etiquetas de los ejes, agreguemos que los valores at√≠picos se muestren como puntos y cambiemos el estilo de las cajas.\n\n\nC√≥digo\nfig, ax = plt.subplots(figsize=(10, 6))\n\nsns.boxplot(hue=\"class\", x=\"class\", y=\"cap-diameter\", data=data, ax=ax, \n            palette=\"Set2\", linewidth=2, fliersize=5, notch=True)\n\nax.set_title(\"Diagrama de caja del di√°metro del sombrero por clase\", fontsize=16)\nax.set_xlabel(\"Clase\", fontsize=14)\nax.set_ylabel(\"Di√°metro del sombrero\", fontsize=14)\n\nplt.show()\n\n\n\n\n\n\n\n\n\nUsemos los mismos datos para crear un gr√°fico de viol√≠n de las variables cap-diameter para los hongos comestibles y venenosos.\n\n\nC√≥digo\nfig, ax = plt.subplots(figsize=(10, 6))\n\nsns.violinplot(x=\"class\", y=\"cap-diameter\", data=data, ax=ax, hue=\"class\", palette=\"Set1\")\n\nax.set_title(\"Gr√°fico de viol√≠n del di√°metro del sombrero por clase\", fontsize=16, fontweight=\"bold\")\nax.set_xlabel(\"Clase\", fontsize=14)\nax.set_ylabel(\"Di√°metro del sombrero\", fontsize=14)\n\nplt.show()\n\n\n\n\n\n\n\n\n\nEn un gr√°fico de viol√≠n, la forma del viol√≠n representa la distribuci√≥n de los datos. En este caso, utilizamos el parametro hue para cambiar el color de los violines de acuerdo a la variable class y el parametro palette para cambiar la paleta de colores. Nos incluye un gr√°fico de caja en el interior del viol√≠n, que nos permite ver la distribuci√≥n de los datos de una manera m√°s detallada. Modifiquemos el gr√°fico para que sea m√°s informativo.\n\n\nC√≥digo\nfig, ax = plt.subplots(figsize=(10, 6))\n\nsns.violinplot(x=\"class\", y=\"cap-diameter\", data=data, ax=ax, \n                hue=\"class\", palette=\"Set1\", inner=\"box\", fill=False,\n                inner_kws={\"linewidth\": 1.5, \"box_width\": 17, \"whis_width\":2})\n\nax.set_title(\"Gr√°fico de viol√≠n del di√°metro del sombrero por clase\", fontsize=16, fontweight=\"bold\")\nax.set_xlabel(\"Clase\", fontsize=14)\nax.set_ylabel(\"Di√°metro del sombrero\", fontsize=14)\n\nplt.show()\n\n\n\n\n\n\n\n\n\nAqu√≠ hemos especificado que el interior del viol√≠n sea un gr√°fico de caja con el parametro inner=\"box\". Adem√°s, hemos cambiado el ancho de las cajas con el parametro inner_kws={\"box_width\": 17} y el ancho de los bigotes con el parametro inner_kws={\"whis_width\": 2}. Con el parametro fill=False, hemos eliminado el relleno del viol√≠n.\nUn gr√°fico √∫til a la hora de analizar datos es la matriz de correlaci√≥n. La matriz de correlaci√≥n nos permite ver c√≥mo se relacionan las variables entre s√≠. En seaborn, podemos hacer una matriz de correlaci√≥n utilizando el m√©todo heatmap().\n\n\nC√≥digo\nfig, ax = plt.subplots(figsize=(10, 6))\n\ncorr = data.corr()\n\nsns.heatmap(corr, annot=True, cmap=\"coolwarm\", ax=ax, vmax=1, vmin=-1)\n\nax.set_title(\"Matriz de correlaci√≥n de las variables\", fontsize=16, fontweight=\"bold\")\n\nplt.show()\n\n\n\n\n\n\n\n\n\nEn este caso, utilizamos el m√©todo corr() para calcular la matriz de correlaci√≥n de los datos y luego utilizamos el m√©todo heatmap() para hacer una matriz de correlaci√≥n. El parametro annot=True nos permite mostrar los valores de la correlaci√≥n en los cuadros y el parametro cmap=\"coolwarm\" nos permite cambiar el mapa de colores. Los parametros vmax y vmin nos permiten especificar los valores m√°ximos y m√≠nimos de la escala de colores, sino se dan, se toman los valores m√°ximos y m√≠nimos de la matriz de correlaci√≥n.\nUna buena forma de presentar los datos de dos variables es juntar un gr√°fico de dispersi√≥n con un histograma. En seaborn, podemos hacer un gr√°fico de dispersi√≥n con histogramas utilizando el m√©todo jointplot().\n\n\nC√≥digo\nfig = plt.figure(figsize=(10, 6))\n\nsns.jointplot(x=\"cap-diameter\", y=\"stem-height\", data=data, kind=\"scatter\", color=\"skyblue\")\n\nplt.show()\n\n\n&lt;Figure size 960x576 with 0 Axes&gt;\n\n\n\n\n\n\n\n\n\nEn este caso, utilizamos el parametro kind=\"scatter\" para hacer un gr√°fico de dispersi√≥n. Los valores v√°lidos para el parametro kind son:\n\nscatter: Gr√°fico de dispersi√≥n.\nkde: Estimaci√≥n de densidad de kernel.\nhist: Histograma.\nhex: Gr√°fico de hexbin.\nreg: Gr√°fico de regresi√≥n.\nresid: Gr√°fico de residuos.\n\nAdem√°s con el par√°metro hue podemos cambiar el color de los puntos de acuerdo a una variable categ√≥rica.\n\n\nC√≥digo\nfig = plt.figure(figsize=(10, 6))\n\nax = sns.jointplot(x=\"cap-diameter\", y=\"stem-height\", data=data, \n                    kind=\"scatter\", color=\"skyblue\", hue=\"class\")\n\nax.set_axis_labels(\"Di√°metro del sombrero\", \"Altura del tallo\", fontsize=12)\nax.fig.suptitle(\"Gr√°fico de dispersi√≥n de di√°metro del sombrero y altura del tallo\", \n                fontsize=14, fontweight=\"bold\", y = 1.02)\n\nplt.show()\n\n\n&lt;Figure size 960x576 with 0 Axes&gt;\n\n\n\n\n\n\n\n\n\nEste gr√°fico nos permite ver la relaci√≥n entre dos variables y la distribuci√≥n de cada variable de forma simult√°nea. Vemos que no hay diferencias claras entre las variables cap-diameter y stem-height para los hongos comestibles y venenosos.\nSeaborn tiene una funci√≥n para mostrar gr√°ficos con la relaci√≥n entre todas las variables de un DataFrame. Esta funci√≥n se llama pairplot().\n\n\nC√≥digo\nfig = plt.figure(figsize=(10, 6))\n\nsns.pairplot(data, hue=\"class\", palette=\"Set1\")\n\nplt.show()\n\n\n&lt;Figure size 960x576 with 0 Axes&gt;\n\n\n\n\n\n\n\n\n\nSi son muchas variables, podemos seleccionar solo algunas para hacer el gr√°fico. En este caso, seleccionamos las variables cap-diameter, stem-height, cap-surface y cap-color.\n\n\nC√≥digo\nfig = plt.figure(figsize=(10, 6))\n\nsns.pairplot(data[[\"cap-diameter\", \"stem-height\", \"class\"]], hue=\"class\", palette=\"Set1\")\n\nplt.show()\n\n\n&lt;Figure size 960x576 with 0 Axes&gt;\n\n\n\n\n\n\n\n\n\nNos mostrar√° un gr√°fico de dispersi√≥n de todas las variables seleccionadas y un histograma de cada variable en la diagonal. Adem√°s, podemos cambiar el color de los puntos de acuerdo a una variable categ√≥rica con el parametro hue.",
    "crumbs": [
      "Manejo de Datos y Estad√≠stica con Python",
      "Visualizaci√≥n de datos"
    ]
  },
  {
    "objectID": "statistics/data-visualization.html#conclusiones",
    "href": "statistics/data-visualization.html#conclusiones",
    "title": "Visualizaci√≥n de datos",
    "section": "Conclusiones",
    "text": "Conclusiones\nEn este tutorial, hemos visto c√≥mo podemos visualizar datos en Python utilizando las librer√≠as matplotlib y seaborn. Hemos visto c√≥mo hacer gr√°ficos de barras, gr√°ficos de dispersi√≥n, histogramas, diagramas de caja, gr√°ficos de viol√≠n, matrices de correlaci√≥n, gr√°ficos de dispersi√≥n con histogramas y gr√°ficos de pares. Estas son solo algunas de las muchas formas en que podemos visualizar datos en Python. La visualizaci√≥n de datos es una herramienta poderosa que nos permite entender de manera r√°pida y sencilla la informaci√≥n que tenemos a nuestra disposici√≥n.\nPara m√°s informaci√≥n sobre matplotlib y seaborn, puedes consultar la documentaci√≥n oficial:\n\nDocumentaci√≥n de Matplotlib\nDocumentaci√≥n de Seaborn",
    "crumbs": [
      "Manejo de Datos y Estad√≠stica con Python",
      "Visualizaci√≥n de datos"
    ]
  },
  {
    "objectID": "test.html",
    "href": "test.html",
    "title": "Pyodide in Quarto HTML Documents",
    "section": "",
    "text": "This is a pyodide-enabled code cell in a Quarto HTML document.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n Volver arriba"
  }
]