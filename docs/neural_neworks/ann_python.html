<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="es" xml:lang="es"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.42">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Christian Badillo">

<title>Redes Neuronales Artificiales en Python – Ciencia de Datos con Python</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js" integrity="sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==" crossorigin="anonymous"></script><script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<link href="../neural_neworks/neural_networks.html" rel="prev">
<script src="../site_libs/cookie-consent/cookie-consent.js"></script>
<link href="../site_libs/cookie-consent/cookie-consent.css" rel="stylesheet">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-de84f8d6bb715db06a919283c2d1e787.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-dark-9a023c9ade86a60361e96e3e3f11bc54.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap-a392a59a750219dd8cd4275847812d66.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../site_libs/bootstrap/bootstrap-dark-b4fdfc6d9ce015fe3d0478e9c1e39699.min.css" rel="prefetch" append-hash="true" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<link href="../site_libs/quarto-contrib/fontawesome6-1.2.0/all.min.css" rel="stylesheet">
<link href="../site_libs/quarto-contrib/fontawesome6-1.2.0/latex-fontsize.css" rel="stylesheet">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "Sin resultados",
    "search-matching-documents-text": "documentos encontrados",
    "search-copy-link-title": "Copiar el enlace en la búsqueda",
    "search-hide-matches-text": "Ocultar resultados adicionales",
    "search-more-match-text": "resultado adicional en este documento",
    "search-more-matches-text": "resultados adicionales en este documento",
    "search-clear-button-title": "Borrar",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancelar",
    "search-submit-button-title": "Enviar",
    "search-label": "Buscar"
  }
}</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-0QFEMB55EW"></script>

<script type="text/plain" cookie-consent="tracking">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-0QFEMB55EW', { 'anonymize_ip': true});
</script>

<script type="text/javascript" charset="UTF-8">
document.addEventListener('DOMContentLoaded', function () {
cookieconsent.run({
  "notice_banner_type":"headline",
  "consent_type":"express",
  "palette":"light",
  "language":"en",
  "page_load_consent_levels":["strictly-necessary"],
  "notice_banner_reject_button_hide":false,
  "preferences_center_close_button_hide":false,
  "website_name":""
  ,
"language":"es"
  });
});
</script> 
  
<script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" integrity="sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==" crossorigin="anonymous"></script>



<script type="application/javascript">define('jquery', [],function() {return window.jQuery;})</script>


  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../styles.css">
<meta property="og:title" content="Redes Neuronales Artificiales en Python – Ciencia de Datos con Python">
<meta property="og:description" content="Página web para el curso intersemestral Ciencia de Datos con Python para la Facultad de Psicología, UNAM periodo 2024-1">
<meta property="og:image" content="https://christian-f-badillo.github.io/Ciencia-de-datos-con-Python-de-estadistica-descriptiva-a-redes-neuronales/neural_neworks/ann_python_files/figure-html/cell-6-output-1.png">
<meta property="og:site_name" content="Ciencia de Datos con Python">
<meta property="og:locale" content="es_MX">
<meta property="og:image:height" content="868">
<meta property="og:image:width" content="1094">
<meta name="twitter:title" content="Redes Neuronales Artificiales en Python – Ciencia de Datos con Python">
<meta name="twitter:description" content="Página web para el curso intersemestral Ciencia de Datos con Python para la Facultad de Psicología, UNAM periodo 2024-1">
<meta name="twitter:image" content="https://christian-f-badillo.github.io/Ciencia-de-datos-con-Python-de-estadistica-descriptiva-a-redes-neuronales/neural_neworks/ann_python_files/figure-html/cell-6-output-1.png">
<meta name="twitter:image-height" content="868">
<meta name="twitter:image-width" content="1094">
<meta name="twitter:card" content="summary_large_image">
</head>

<body class="nav-sidebar docked">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Alternar barra lateral" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../neural_neworks/classes_python.html">Redes Neuronales</a></li><li class="breadcrumb-item"><a href="../neural_neworks/ann_python.html">Redes Neuronales Artificiales en Python</a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Alternar barra lateral" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Buscar" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation docked overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header sidebar-header-stacked">
      <a href="../index.html" class="sidebar-logo-link">
      <img src="../img/logo-members/Lab25_logo_2015.png" alt="" class="sidebar-logo py-0 d-lg-inline d-none">
      </a>
    <div class="sidebar-title mb-0 py-0">
      <a href="../">Ciencia de Datos con Python</a> 
        <div class="sidebar-tools-main tools-wide">
    <div class="dropdown">
      <a href="" title="" id="quarto-navigation-tool-dropdown-0" class="quarto-navigation-tool dropdown-toggle px-1" data-bs-toggle="dropdown" aria-expanded="false" role="link" aria-label=""><i class="bi bi-github"></i></a>
      <ul class="dropdown-menu" aria-labelledby="quarto-navigation-tool-dropdown-0">
          <li>
            <a class="dropdown-item sidebar-tools-main-item" href="https://github.com/Christian-F-Badillo/Ciencia-de-datos-con-Python-de-estadistica-descriptiva-a-redes-neuronales">
            Source Code
            </a>
          </li>
      </ul>
    </div>
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Alternar modo oscuro"><i class="bi"></i></a>
  <a href="" class="quarto-reader-toggle quarto-navigation-tool px-1" onclick="window.quartoToggleReader(); return false;" title="Alternar modo lector">
  <div class="quarto-reader-toggle-btn">
  <i class="bi"></i>
  </div>
</a>
</div>
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Buscar"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Inicio</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../about.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Acerca</span></a>
  </div>
</li>
        <li class="px-0"><hr class="sidebar-divider hi "></li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true">
 <span class="menu-text">Fundamentos de Python</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true" aria-label="Alternar sección">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../intro_python/Cloud.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Instalación de Python</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../intro_python/Variables.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Declaración de Variables y Operaciones</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../intro_python/functions_and_loops.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Funciones y Bucles de Control</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../intro_python/data_structures.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Estructuras de Datos</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" role="navigation" aria-expanded="true">
 <span class="menu-text">Manejo de Datos y Estadística con Python</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" role="navigation" aria-expanded="true" aria-label="Alternar sección">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-2" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../statistics/data_manipulation.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Manipulación de datos con Pandas</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../statistics/data-visualization.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Visualización de datos</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../statistics/Linear_models.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Modelos Lineales</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../statistics/hipothesis_testing.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Prueba de Hipótesis</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../statistics/bayesian_statistics.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Introducción a Estadística Bayesiana</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" role="navigation" aria-expanded="true">
 <span class="menu-text">Redes Neuronales</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" role="navigation" aria-expanded="true" aria-label="Alternar sección">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-3" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../neural_neworks/classes_python.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Programación Orientada a Objetos en Python</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../neural_neworks/neural_networks.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Introducción a Redes Neuronales</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../neural_neworks/ann_python.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text">Redes Neuronales Artificiales en Python</span></a>
  </div>
</li>
      </ul>
  </li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Tabla de Contenido</h2>
   
  <ul>
  <li><a href="#scikit-learn" id="toc-scikit-learn" class="nav-link active" data-scroll-target="#scikit-learn"><code>scikit-learn</code></a>
  <ul class="collapse">
  <li><a href="#ejemplo-de-clasificación" id="toc-ejemplo-de-clasificación" class="nav-link" data-scroll-target="#ejemplo-de-clasificación">Ejemplo de clasificación</a></li>
  </ul></li>
  <li><a href="#pytorch" id="toc-pytorch" class="nav-link" data-scroll-target="#pytorch"><code>PyTorch</code></a>
  <ul class="collapse">
  <li><a href="#uso-básico-de-pytorch" id="toc-uso-básico-de-pytorch" class="nav-link" data-scroll-target="#uso-básico-de-pytorch">Uso básico de PyTorch</a></li>
  <li><a href="#estructura-de-una-red-neuronal-artificial-en-pytorch" id="toc-estructura-de-una-red-neuronal-artificial-en-pytorch" class="nav-link" data-scroll-target="#estructura-de-una-red-neuronal-artificial-en-pytorch">Estructura de una red neuronal artificial en PyTorch</a></li>
  <li><a href="#entrenamiento-de-la-red-neuronal" id="toc-entrenamiento-de-la-red-neuronal" class="nav-link" data-scroll-target="#entrenamiento-de-la-red-neuronal">Entrenamiento de la red neuronal</a></li>
  <li><a href="#preparación-de-los-datos" id="toc-preparación-de-los-datos" class="nav-link" data-scroll-target="#preparación-de-los-datos">Preparación de los datos</a></li>
  <li><a href="#red-neuronal-con-pytorch" id="toc-red-neuronal-con-pytorch" class="nav-link" data-scroll-target="#red-neuronal-con-pytorch">Red Neuronal con PyTorch</a></li>
  </ul></li>
  <li><a href="#aspectos-importantes" id="toc-aspectos-importantes" class="nav-link" data-scroll-target="#aspectos-importantes">Aspectos importantes</a></li>
  <li><a href="#tensorflow" id="toc-tensorflow" class="nav-link" data-scroll-target="#tensorflow"><code>TensorFlow</code></a>
  <ul class="collapse">
  <li><a href="#uso-básico-de-tensorflow" id="toc-uso-básico-de-tensorflow" class="nav-link" data-scroll-target="#uso-básico-de-tensorflow">Uso básico de TensorFlow</a></li>
  <li><a href="#estructura-de-una-red-neuronal-artificial-en-tensorflow" id="toc-estructura-de-una-red-neuronal-artificial-en-tensorflow" class="nav-link" data-scroll-target="#estructura-de-una-red-neuronal-artificial-en-tensorflow">Estructura de una red neuronal artificial en TensorFlow</a></li>
  </ul></li>
  <li><a href="#salvando-y-cargando-modelos" id="toc-salvando-y-cargando-modelos" class="nav-link" data-scroll-target="#salvando-y-cargando-modelos">Salvando y cargando modelos</a></li>
  <li><a href="#conclusiones" id="toc-conclusiones" class="nav-link" data-scroll-target="#conclusiones">Conclusiones</a></li>
  </ul>
<div class="toc-actions"><ul><li><a href="https://github.com/Christian-F-Badillo/Ciencia-de-datos-con-Python-de-estadistica-descriptiva-a-redes-neuronales/edit/main/neural_neworks/ann_python.qmd" class="toc-action"><i class="bi bi-github"></i>Editar esta página</a></li><li><a href="https://github.com/Christian-F-Badillo/Ciencia-de-datos-con-Python-de-estadistica-descriptiva-a-redes-neuronales/issues/new" class="toc-action"><i class="bi empty"></i>Informar de un problema</a></li></ul></div></nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default"><nav class="quarto-page-breadcrumbs quarto-title-breadcrumbs d-none d-lg-block" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../neural_neworks/classes_python.html">Redes Neuronales</a></li><li class="breadcrumb-item"><a href="../neural_neworks/ann_python.html">Redes Neuronales Artificiales en Python</a></li></ol></nav>
<div class="quarto-title">
<div class="quarto-title-block"><div><h1 class="title">Redes Neuronales Artificiales en Python</h1><button type="button" class="btn code-tools-button dropdown-toggle" id="quarto-code-tools-menu" data-bs-toggle="dropdown" aria-expanded="false"><i class="bi"></i> Ver código</button><ul class="dropdown-menu dropdown-menu-end" aria-labelelledby="quarto-code-tools-menu"><li><a id="quarto-show-all-code" class="dropdown-item" href="javascript:void(0)" role="button">Mostrar todo el código</a></li><li><a id="quarto-hide-all-code" class="dropdown-item" href="javascript:void(0)" role="button">Ocultar todo el código</a></li><li><hr class="dropdown-divider"></li><li><a id="quarto-view-source" class="dropdown-item" href="javascript:void(0)" role="button" data-quarto-source-url="https://github.com/Christian-F-Badillo/Ciencia-de-datos-con-Python-de-estadistica-descriptiva-a-redes-neuronales/blob/main/neural_neworks/ann_python.qmd">Ver el código fuente</a></li></ul></div></div>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Autor/a</div>
    <div class="quarto-title-meta-contents">
             <p>Christian Badillo </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Fecha de publicación</div>
    <div class="quarto-title-meta-contents">
      <p class="date">23 de marzo de 2025</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<p>Existen muchas librerías en Python que permiten implementar redes neuronales artificiales. En este tutorial, vamos a utilizar la librería <code>scikit-learn</code>, <code>keras</code> y <code>tensorflow</code> para implementar una red neuronal artificial para resolver problemas de clasificación y regresión.</p>
<section id="scikit-learn" class="level2">
<h2 class="anchored" data-anchor-id="scikit-learn"><code>scikit-learn</code></h2>
<p><code>scikit-learn</code> es una librería de Python que permite implementar algoritmos de aprendizaje supervisado y no supervisado. En particular, <code>scikit-learn</code> incluye una clase llamada <code>MLPClassifier</code> que permite implementar redes neuronales artificiales para problemas de clasificación.</p>
<section id="ejemplo-de-clasificación" class="level3">
<h3 class="anchored" data-anchor-id="ejemplo-de-clasificación">Ejemplo de clasificación</h3>
<p>En este ejemplo, vamos a utilizar la base de datos <code>iris</code> para entrenar una red neuronal artificial que permita clasificar las flores en tres categorías: <code>setosa</code>, <code>versicolor</code> y <code>virginica</code>.</p>
<div id="f6fe799c" class="cell" data-execution_count="1">
<details open="" class="code-fold">
<summary>Código</summary>
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb1-3"><a href="#cb1-3"></a><span class="im">from</span> sklearn.datasets <span class="im">import</span> load_iris</span>
<span id="cb1-4"><a href="#cb1-4"></a><span class="im">from</span> sklearn.model_selection <span class="im">import</span> train_test_split</span>
<span id="cb1-5"><a href="#cb1-5"></a><span class="im">from</span> sklearn.neural_network <span class="im">import</span> MLPClassifier</span>
<span id="cb1-6"><a href="#cb1-6"></a></span>
<span id="cb1-7"><a href="#cb1-7"></a><span class="co"># Cargar la base de datos iris</span></span>
<span id="cb1-8"><a href="#cb1-8"></a>iris <span class="op">=</span> load_iris()</span>
<span id="cb1-9"><a href="#cb1-9"></a>X <span class="op">=</span> iris.data</span>
<span id="cb1-10"><a href="#cb1-10"></a>y <span class="op">=</span> iris.target</span>
<span id="cb1-11"><a href="#cb1-11"></a></span>
<span id="cb1-12"><a href="#cb1-12"></a><span class="bu">print</span>(iris.target_names)</span>
<span id="cb1-13"><a href="#cb1-13"></a><span class="bu">print</span>(iris.feature_names)</span>
<span id="cb1-14"><a href="#cb1-14"></a><span class="bu">print</span>(X.shape)</span>
<span id="cb1-15"><a href="#cb1-15"></a><span class="bu">print</span>(y.shape)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>['setosa' 'versicolor' 'virginica']
['sepal length (cm)', 'sepal width (cm)', 'petal length (cm)', 'petal width (cm)']
(150, 4)
(150,)</code></pre>
</div>
</div>
<p>Implementamos la red neuronal artificial y la entrenamos con la base de datos <code>iris</code>.</p>
<div id="74ef1f81" class="cell" data-execution_count="2">
<details open="" class="code-fold">
<summary>Código</summary>
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1"></a><span class="co"># Dividir la base de datos en entrenamiento y prueba</span></span>
<span id="cb3-2"><a href="#cb3-2"></a>X_train, X_test, y_train, y_test <span class="op">=</span> train_test_split(X, y, test_size<span class="op">=</span><span class="fl">0.2</span>, random_state<span class="op">=</span><span class="dv">42</span>)</span>
<span id="cb3-3"><a href="#cb3-3"></a></span>
<span id="cb3-4"><a href="#cb3-4"></a><span class="co"># Crear la red neuronal artificial</span></span>
<span id="cb3-5"><a href="#cb3-5"></a>clf <span class="op">=</span> MLPClassifier(hidden_layer_sizes<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">10</span>), max_iter<span class="op">=</span><span class="dv">1000</span>, random_state<span class="op">=</span><span class="dv">42</span>, </span>
<span id="cb3-6"><a href="#cb3-6"></a>                    activation<span class="op">=</span><span class="st">'relu'</span>, solver<span class="op">=</span><span class="st">'sgd'</span>, learning_rate<span class="op">=</span><span class="st">'adaptive'</span>, </span>
<span id="cb3-7"><a href="#cb3-7"></a>                    learning_rate_init<span class="op">=</span><span class="fl">0.001</span>)</span>
<span id="cb3-8"><a href="#cb3-8"></a></span>
<span id="cb3-9"><a href="#cb3-9"></a><span class="co"># Entrenar la red neuronal artificial</span></span>
<span id="cb3-10"><a href="#cb3-10"></a>clf.fit(X_train, y_train)</span>
<span id="cb3-11"><a href="#cb3-11"></a></span>
<span id="cb3-12"><a href="#cb3-12"></a><span class="co"># Evaluar la red neuronal artificial</span></span>
<span id="cb3-13"><a href="#cb3-13"></a>score <span class="op">=</span> clf.score(X_test, y_test)</span>
<span id="cb3-14"><a href="#cb3-14"></a><span class="bu">print</span>(score)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>0.9333333333333333</code></pre>
</div>
</div>
<p>La clase <code>MLPClassifier</code> tiene varios parámetros que permiten configurar la red neuronal artificial. En este ejemplo, utilizamos los siguientes parámetros:</p>
<ul>
<li><code>hidden_layer_sizes</code>: Número de neuronas en cada capa oculta.</li>
<li><code>max_iter</code>: Número máximo de iteraciones para entrenar la red neuronal artificial.</li>
<li><code>random_state</code>: Semilla para la generación de números aleatorios.</li>
<li><code>solver</code>: Algoritmo de optimización para entrenar la red neuronal artificial.</li>
<li><code>activation</code>: Función de activación para las neuronas en las capas ocultas.</li>
<li><code>learning_rate</code>: Tasa de aprendizaje para actualizar los pesos de la red neuronal artificial.</li>
<li><code>learning_rate_init</code>: Tasa de aprendizaje inicial para actualizar los pesos de la red neuronal artificial.</li>
</ul>
<p>El método <code>score</code> permite evaluar la precisión de la red neuronal artificial en la base de datos de prueba.</p>
<p>Podemos obtener las predicciones de la red neuronal artificial para la base de datos de prueba.</p>
<div id="998761c6" class="cell" data-execution_count="3">
<details open="" class="code-fold">
<summary>Código</summary>
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1"></a><span class="co"># Obtener las predicciones de la red neuronal artificial</span></span>
<span id="cb5-2"><a href="#cb5-2"></a>y_pred <span class="op">=</span> clf.predict(X_test)</span>
<span id="cb5-3"><a href="#cb5-3"></a><span class="bu">print</span>(y_pred)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>[1 0 2 1 1 0 1 2 2 1 2 0 0 0 0 1 2 1 1 2 0 2 0 2 1 2 2 2 0 0]</code></pre>
</div>
</div>
<p>Para evaluar la red neuronal artificial, podemos calcular la matriz de confusión.</p>
<div id="07167829" class="cell" data-execution_count="4">
<details open="" class="code-fold">
<summary>Código</summary>
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1"></a><span class="im">from</span> sklearn.metrics <span class="im">import</span> confusion_matrix</span>
<span id="cb7-2"><a href="#cb7-2"></a></span>
<span id="cb7-3"><a href="#cb7-3"></a><span class="co"># Calcular la matriz de confusión</span></span>
<span id="cb7-4"><a href="#cb7-4"></a>cm <span class="op">=</span> confusion_matrix(y_test, y_pred)</span>
<span id="cb7-5"><a href="#cb7-5"></a><span class="bu">print</span>(cm)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>[[10  0  0]
 [ 0  8  1]
 [ 0  1 10]]</code></pre>
</div>
</div>
<p>Podemos visualizar la matriz de confusión utilizando la librería <code>seaborn</code>.</p>
<div id="02c2daa2" class="cell" data-execution_count="5">
<details open="" class="code-fold">
<summary>Código</summary>
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1"></a><span class="im">import</span> seaborn <span class="im">as</span> sns</span>
<span id="cb9-2"><a href="#cb9-2"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb9-3"><a href="#cb9-3"></a></span>
<span id="cb9-4"><a href="#cb9-4"></a><span class="co"># Visualizar la matriz de confusión</span></span>
<span id="cb9-5"><a href="#cb9-5"></a>sns.heatmap(cm, annot<span class="op">=</span><span class="va">True</span>, fmt<span class="op">=</span><span class="st">'d'</span>, </span>
<span id="cb9-6"><a href="#cb9-6"></a>            xticklabels<span class="op">=</span>iris.target_names, </span>
<span id="cb9-7"><a href="#cb9-7"></a>            yticklabels<span class="op">=</span>iris.target_names,</span>
<span id="cb9-8"><a href="#cb9-8"></a>            cmap<span class="op">=</span><span class="st">'Blues'</span>)</span>
<span id="cb9-9"><a href="#cb9-9"></a>plt.xlabel(<span class="st">'Predicción'</span>)</span>
<span id="cb9-10"><a href="#cb9-10"></a>plt.ylabel(<span class="st">'Real'</span>)</span>
<span id="cb9-11"><a href="#cb9-11"></a>plt.show()</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="ann_python_files/figure-html/cell-6-output-1.png" width="547" height="434" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<p>Con este mapa de color podemos visualizar la matriz de confusión. Las filas representan las categorías reales y las columnas representan las categorías predichas. Los valores en la diagonal principal representan las predicciones correctas y esperamos que un buen modelo tenga valores altos en la diagonal principal.</p>
<p>POdemos usar el área bajo la curva ROC para evaluar la red neuronal artificial.</p>
<div id="11ce3ee5" class="cell" data-execution_count="6">
<details open="" class="code-fold">
<summary>Código</summary>
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1"></a><span class="im">from</span> sklearn.metrics <span class="im">import</span> roc_auc_score</span>
<span id="cb10-2"><a href="#cb10-2"></a></span>
<span id="cb10-3"><a href="#cb10-3"></a><span class="co"># Calcular el área bajo la curva ROC</span></span>
<span id="cb10-4"><a href="#cb10-4"></a>y_prob <span class="op">=</span> clf.predict_proba(X_test)</span>
<span id="cb10-5"><a href="#cb10-5"></a>roc_auc <span class="op">=</span> roc_auc_score(y_test, y_prob, multi_class<span class="op">=</span><span class="st">'ovr'</span>)</span>
<span id="cb10-6"><a href="#cb10-6"></a><span class="bu">print</span>(roc_auc)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>0.9966414352379265</code></pre>
</div>
</div>
<p>Aquí el parámetro <code>multi_class</code> se refiere a la estrategia de codificación de clases. En este caso, utilizamos <code>ovr</code> que significa “one-vs-rest”, que evalúa cada clase en comparación con el resto de las clases y es sensible a datos desequilibrados.</p>
<p>Entre más cercano a 1 sea el valor del área bajo la curva ROC, mejor será el modelo, ya que significa que el modelo es capaz de distinguir entre las diferentes clases.</p>
</section>
</section>
<section id="pytorch" class="level2">
<h2 class="anchored" data-anchor-id="pytorch"><code>PyTorch</code></h2>
<p><code>PyTorch</code> es una librería de Python que permite implementar redes neuronales artificiales de manera eficiente. En particular, <code>PyTorch</code> incluye una clase llamada <code>nn.Module</code> que permite definir la arquitectura de la red neuronal artificial.</p>
<section id="uso-básico-de-pytorch" class="level3">
<h3 class="anchored" data-anchor-id="uso-básico-de-pytorch">Uso básico de PyTorch</h3>
<p>Para utilizar <code>PyTorch</code>, primero debemos instalar la librería, el comando que recomienda la página de <code>PyTorch</code> es el siguiente para Windows y sin el uso de GPU.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode numberSource {bash} number-lines code-with-copy"><code class="sourceCode"><span id="cb12-1"><a href="#cb12-1"></a>!pip install torch torchvision torchaudio --index-url https://download.pytorch.org/whl/cpu</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<section id="tensores" class="level4">
<h4 class="anchored" data-anchor-id="tensores">Tensores</h4>
<p>En <code>PyTorch</code>, los datos se almacenan en tensores, que son arreglos multidimensionales similares a los arreglos de <code>NumPy</code>. Podemos crear tensores en <code>PyTorch</code> de la siguiente manera.</p>
<div id="c1998f10" class="cell" data-execution_count="7">
<details open="" class="code-fold">
<summary>Código</summary>
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1"></a><span class="im">import</span> torch</span>
<span id="cb13-2"><a href="#cb13-2"></a></span>
<span id="cb13-3"><a href="#cb13-3"></a><span class="co"># Crear un tensor de ceros</span></span>
<span id="cb13-4"><a href="#cb13-4"></a>x <span class="op">=</span> torch.zeros(<span class="dv">2</span>, <span class="dv">3</span>)</span>
<span id="cb13-5"><a href="#cb13-5"></a></span>
<span id="cb13-6"><a href="#cb13-6"></a><span class="bu">print</span>(x)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>tensor([[0., 0., 0.],
        [0., 0., 0.]])</code></pre>
</div>
</div>
<p>Podemos crear tensores a partir de arreglos de <code>NumPy</code>.</p>
<div id="576a56e5" class="cell" data-execution_count="8">
<details open="" class="code-fold">
<summary>Código</summary>
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb15-2"><a href="#cb15-2"></a></span>
<span id="cb15-3"><a href="#cb15-3"></a><span class="co"># Crear un arreglo de NumPy</span></span>
<span id="cb15-4"><a href="#cb15-4"></a>arr <span class="op">=</span> np.array([[<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>], [<span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">6</span>]])</span>
<span id="cb15-5"><a href="#cb15-5"></a></span>
<span id="cb15-6"><a href="#cb15-6"></a><span class="co"># Crear un tensor de PyTorch a partir de un arreglo de NumPy</span></span>
<span id="cb15-7"><a href="#cb15-7"></a>x <span class="op">=</span> torch.tensor(arr)</span>
<span id="cb15-8"><a href="#cb15-8"></a></span>
<span id="cb15-9"><a href="#cb15-9"></a><span class="bu">print</span>(x)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>tensor([[1, 2, 3],
        [4, 5, 6]])</code></pre>
</div>
</div>
<p>Los tensores pueden ser de diferentes tipos de datos, como <code>float32</code>, <code>int64</code>, <code>bool</code>, etc.</p>
<div id="bb213812" class="cell" data-execution_count="9">
<details open="" class="code-fold">
<summary>Código</summary>
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1"></a><span class="co"># Crear un tensor de enteros</span></span>
<span id="cb17-2"><a href="#cb17-2"></a>x <span class="op">=</span> torch.tensor([[<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>], [<span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">6</span>]], dtype<span class="op">=</span>torch.int64)</span>
<span id="cb17-3"><a href="#cb17-3"></a></span>
<span id="cb17-4"><a href="#cb17-4"></a><span class="bu">print</span>(x)</span>
<span id="cb17-5"><a href="#cb17-5"></a></span>
<span id="cb17-6"><a href="#cb17-6"></a><span class="co"># Crear un tensor de booleanos</span></span>
<span id="cb17-7"><a href="#cb17-7"></a>x <span class="op">=</span> torch.tensor([[<span class="va">True</span>, <span class="va">False</span>], [<span class="va">False</span>, <span class="va">True</span>]])</span>
<span id="cb17-8"><a href="#cb17-8"></a></span>
<span id="cb17-9"><a href="#cb17-9"></a><span class="bu">print</span>(x)</span>
<span id="cb17-10"><a href="#cb17-10"></a></span>
<span id="cb17-11"><a href="#cb17-11"></a><span class="co"># Crear un tensor de punto flotante</span></span>
<span id="cb17-12"><a href="#cb17-12"></a>x <span class="op">=</span> torch.tensor([[<span class="fl">1.0</span>, <span class="fl">2.0</span>], [<span class="fl">3.0</span>, <span class="fl">4.0</span>]], dtype<span class="op">=</span>torch.float32)</span>
<span id="cb17-13"><a href="#cb17-13"></a></span>
<span id="cb17-14"><a href="#cb17-14"></a><span class="bu">print</span>(x)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>tensor([[1, 2, 3],
        [4, 5, 6]])
tensor([[ True, False],
        [False,  True]])
tensor([[1., 2.],
        [3., 4.]])</code></pre>
</div>
</div>
<p>Podemos tener tensores de cualquier dimensión.</p>
<div id="91c8aa28" class="cell" data-execution_count="10">
<details open="" class="code-fold">
<summary>Código</summary>
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1"></a><span class="co"># Crear un tensor de 3 dimensiones</span></span>
<span id="cb19-2"><a href="#cb19-2"></a>x <span class="op">=</span> torch.tensor([[[<span class="dv">1</span>, <span class="dv">2</span>], [<span class="dv">3</span>, <span class="dv">4</span>]], [[<span class="dv">5</span>, <span class="dv">6</span>], [<span class="dv">7</span>, <span class="dv">8</span>]]])</span>
<span id="cb19-3"><a href="#cb19-3"></a></span>
<span id="cb19-4"><a href="#cb19-4"></a><span class="bu">print</span>(x)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>tensor([[[1, 2],
         [3, 4]],

        [[5, 6],
         [7, 8]]])</code></pre>
</div>
</div>
</section>
<section id="operaciones-con-tensores" class="level4">
<h4 class="anchored" data-anchor-id="operaciones-con-tensores">Operaciones con tensores</h4>
<p>Podemos realizar operaciones matemáticas con tensores en <code>PyTorch</code>.</p>
<div id="b181b320" class="cell" data-execution_count="11">
<details open="" class="code-fold">
<summary>Código</summary>
<div class="sourceCode cell-code" id="cb21"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1"></a><span class="co"># Crear dos tensores</span></span>
<span id="cb21-2"><a href="#cb21-2"></a>x <span class="op">=</span> torch.tensor([[<span class="dv">1</span>, <span class="dv">2</span>], [<span class="dv">3</span>, <span class="dv">4</span>]], dtype<span class="op">=</span>torch.float32)</span>
<span id="cb21-3"><a href="#cb21-3"></a>y <span class="op">=</span> torch.tensor([[<span class="dv">5</span>, <span class="dv">6</span>], [<span class="dv">7</span>, <span class="dv">8</span>]], dtype<span class="op">=</span>torch.float32)</span>
<span id="cb21-4"><a href="#cb21-4"></a></span>
<span id="cb21-5"><a href="#cb21-5"></a><span class="co"># Sumar los tensores</span></span>
<span id="cb21-6"><a href="#cb21-6"></a>z <span class="op">=</span> x <span class="op">+</span> y</span>
<span id="cb21-7"><a href="#cb21-7"></a></span>
<span id="cb21-8"><a href="#cb21-8"></a><span class="bu">print</span>(z)</span>
<span id="cb21-9"><a href="#cb21-9"></a></span>
<span id="cb21-10"><a href="#cb21-10"></a><span class="co"># Multiplicar los tensores</span></span>
<span id="cb21-11"><a href="#cb21-11"></a>z <span class="op">=</span> x <span class="op">*</span> y</span>
<span id="cb21-12"><a href="#cb21-12"></a><span class="bu">print</span>(z)</span>
<span id="cb21-13"><a href="#cb21-13"></a></span>
<span id="cb21-14"><a href="#cb21-14"></a><span class="co"># Multiplicar un tensor por un escalar</span></span>
<span id="cb21-15"><a href="#cb21-15"></a>z <span class="op">=</span> <span class="dv">2</span> <span class="op">*</span> x</span>
<span id="cb21-16"><a href="#cb21-16"></a><span class="bu">print</span>(z)</span>
<span id="cb21-17"><a href="#cb21-17"></a></span>
<span id="cb21-18"><a href="#cb21-18"></a><span class="co"># Calcular la transpuesta de un tensor</span></span>
<span id="cb21-19"><a href="#cb21-19"></a>z <span class="op">=</span> x.t()</span>
<span id="cb21-20"><a href="#cb21-20"></a><span class="bu">print</span>(z)</span>
<span id="cb21-21"><a href="#cb21-21"></a></span>
<span id="cb21-22"><a href="#cb21-22"></a><span class="co"># Calcular el producto punto de dos tensores</span></span>
<span id="cb21-23"><a href="#cb21-23"></a>z <span class="op">=</span> torch.dot(x.view(<span class="op">-</span><span class="dv">1</span>), y.view(<span class="op">-</span><span class="dv">1</span>))</span>
<span id="cb21-24"><a href="#cb21-24"></a><span class="bu">print</span>(z)</span>
<span id="cb21-25"><a href="#cb21-25"></a></span>
<span id="cb21-26"><a href="#cb21-26"></a><span class="co"># Calcular el producto matricial de dos tensores</span></span>
<span id="cb21-27"><a href="#cb21-27"></a>z <span class="op">=</span> torch.mm(x, y)</span>
<span id="cb21-28"><a href="#cb21-28"></a></span>
<span id="cb21-29"><a href="#cb21-29"></a><span class="bu">print</span>(z)</span>
<span id="cb21-30"><a href="#cb21-30"></a></span>
<span id="cb21-31"><a href="#cb21-31"></a><span class="co"># Calcular la inversa de un tensor</span></span>
<span id="cb21-32"><a href="#cb21-32"></a>z <span class="op">=</span> torch.inverse(x)</span>
<span id="cb21-33"><a href="#cb21-33"></a></span>
<span id="cb21-34"><a href="#cb21-34"></a><span class="bu">print</span>(z)</span>
<span id="cb21-35"><a href="#cb21-35"></a></span>
<span id="cb21-36"><a href="#cb21-36"></a><span class="co"># Calcular la norma de un tensor</span></span>
<span id="cb21-37"><a href="#cb21-37"></a>z <span class="op">=</span> torch.norm(x)</span>
<span id="cb21-38"><a href="#cb21-38"></a></span>
<span id="cb21-39"><a href="#cb21-39"></a><span class="bu">print</span>(z)</span>
<span id="cb21-40"><a href="#cb21-40"></a></span>
<span id="cb21-41"><a href="#cb21-41"></a><span class="co"># Calcular la media de un tensor</span></span>
<span id="cb21-42"><a href="#cb21-42"></a>z <span class="op">=</span> torch.mean(x)</span>
<span id="cb21-43"><a href="#cb21-43"></a></span>
<span id="cb21-44"><a href="#cb21-44"></a><span class="bu">print</span>(z)</span>
<span id="cb21-45"><a href="#cb21-45"></a></span>
<span id="cb21-46"><a href="#cb21-46"></a><span class="co"># Calcular la desviación estándar de un tensor</span></span>
<span id="cb21-47"><a href="#cb21-47"></a>z <span class="op">=</span> torch.std(x)</span>
<span id="cb21-48"><a href="#cb21-48"></a></span>
<span id="cb21-49"><a href="#cb21-49"></a><span class="bu">print</span>(z)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>tensor([[ 6.,  8.],
        [10., 12.]])
tensor([[ 5., 12.],
        [21., 32.]])
tensor([[2., 4.],
        [6., 8.]])
tensor([[1., 3.],
        [2., 4.]])
tensor(70.)
tensor([[19., 22.],
        [43., 50.]])
tensor([[-2.0000,  1.0000],
        [ 1.5000, -0.5000]])
tensor(5.4772)
tensor(2.5000)
tensor(1.2910)</code></pre>
</div>
</div>
</section>
<section id="métodos-de-tensores" class="level4">
<h4 class="anchored" data-anchor-id="métodos-de-tensores">Métodos de tensores</h4>
<p>Los tensores en <code>PyTorch</code> tienen varios métodos útiles.</p>
<div id="fb9d56a8" class="cell" data-execution_count="12">
<details open="" class="code-fold">
<summary>Código</summary>
<div class="sourceCode cell-code" id="cb23"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1"></a><span class="co"># Crear un tensor de 3 dimensiones</span></span>
<span id="cb23-2"><a href="#cb23-2"></a>x <span class="op">=</span> torch.tensor([[[<span class="dv">1</span>, <span class="dv">2</span>], [<span class="dv">3</span>, <span class="dv">4</span>]], [[<span class="dv">5</span>, <span class="dv">6</span>], [<span class="dv">7</span>, <span class="dv">8</span>]]])</span>
<span id="cb23-3"><a href="#cb23-3"></a></span>
<span id="cb23-4"><a href="#cb23-4"></a><span class="co"># Obtener la forma del tensor</span></span>
<span id="cb23-5"><a href="#cb23-5"></a><span class="bu">print</span>(<span class="ss">f"Shape: </span><span class="sc">{</span>x<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb23-6"><a href="#cb23-6"></a></span>
<span id="cb23-7"><a href="#cb23-7"></a><span class="co"># Obtener el número de elementos en el tensor</span></span>
<span id="cb23-8"><a href="#cb23-8"></a><span class="bu">print</span>(<span class="ss">f"Size: </span><span class="sc">{</span>x<span class="sc">.</span>size()<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb23-9"><a href="#cb23-9"></a></span>
<span id="cb23-10"><a href="#cb23-10"></a><span class="co"># Obtener el tipo de datos del tensor</span></span>
<span id="cb23-11"><a href="#cb23-11"></a><span class="bu">print</span>(<span class="ss">f"Data type: </span><span class="sc">{</span>x<span class="sc">.</span>dtype<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb23-12"><a href="#cb23-12"></a></span>
<span id="cb23-13"><a href="#cb23-13"></a><span class="co"># Obtener el dispositivo en el que se almacena el tensor</span></span>
<span id="cb23-14"><a href="#cb23-14"></a><span class="bu">print</span>(<span class="ss">f"Device: </span><span class="sc">{</span>x<span class="sc">.</span>device<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb23-15"><a href="#cb23-15"></a></span>
<span id="cb23-16"><a href="#cb23-16"></a><span class="co"># Obtener el número de dimensiones del tensor</span></span>
<span id="cb23-17"><a href="#cb23-17"></a><span class="bu">print</span>(<span class="ss">f"Number of dimensions: </span><span class="sc">{</span>x<span class="sc">.</span>dim()<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb23-18"><a href="#cb23-18"></a></span>
<span id="cb23-19"><a href="#cb23-19"></a><span class="co"># Obtener el número de elementos en una dimensión específica</span></span>
<span id="cb23-20"><a href="#cb23-20"></a><span class="bu">print</span>(<span class="ss">f"Number of elements in the first dimension: </span><span class="sc">{</span>x<span class="sc">.</span>size(<span class="dv">0</span>)<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb23-21"><a href="#cb23-21"></a></span>
<span id="cb23-22"><a href="#cb23-22"></a><span class="co"># Obtener el elemento en una posición específica</span></span>
<span id="cb23-23"><a href="#cb23-23"></a><span class="bu">print</span>(<span class="ss">f"Element at position (0, 1, 1): </span><span class="sc">{</span>x[<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">1</span>]<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb23-24"><a href="#cb23-24"></a></span>
<span id="cb23-25"><a href="#cb23-25"></a><span class="co"># Obtener un subtensor</span></span>
<span id="cb23-26"><a href="#cb23-26"></a><span class="bu">print</span>(<span class="ss">f"Subtensor: </span><span class="sc">{</span>x[<span class="dv">0</span>, :, :]<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb23-27"><a href="#cb23-27"></a></span>
<span id="cb23-28"><a href="#cb23-28"></a><span class="co"># Cambiar la forma del tensor</span></span>
<span id="cb23-29"><a href="#cb23-29"></a><span class="bu">print</span>(<span class="ss">f"Reshape: </span><span class="sc">{</span>x<span class="sc">.</span>view(<span class="dv">2</span>, <span class="dv">4</span>)<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb23-30"><a href="#cb23-30"></a></span>
<span id="cb23-31"><a href="#cb23-31"></a><span class="co"># Aplanar el tensor</span></span>
<span id="cb23-32"><a href="#cb23-32"></a><span class="bu">print</span>(<span class="ss">f"Flatten: </span><span class="sc">{</span>x<span class="sc">.</span>view(<span class="op">-</span><span class="dv">1</span>)<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb23-33"><a href="#cb23-33"></a></span>
<span id="cb23-34"><a href="#cb23-34"></a><span class="co"># Concatenar tensores</span></span>
<span id="cb23-35"><a href="#cb23-35"></a>y <span class="op">=</span> torch.tensor([[[<span class="dv">9</span>, <span class="dv">10</span>], [<span class="dv">11</span>, <span class="dv">12</span>]], [[<span class="dv">13</span>, <span class="dv">14</span>], [<span class="dv">15</span>, <span class="dv">16</span>]]])</span>
<span id="cb23-36"><a href="#cb23-36"></a>z <span class="op">=</span> torch.cat((x, y), dim<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb23-37"><a href="#cb23-37"></a></span>
<span id="cb23-38"><a href="#cb23-38"></a><span class="bu">print</span>(z)</span>
<span id="cb23-39"><a href="#cb23-39"></a></span>
<span id="cb23-40"><a href="#cb23-40"></a><span class="co"># Dividir un tensor</span></span>
<span id="cb23-41"><a href="#cb23-41"></a>z1, z2 <span class="op">=</span> torch.chunk(z, <span class="dv">2</span>, dim<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb23-42"><a href="#cb23-42"></a></span>
<span id="cb23-43"><a href="#cb23-43"></a><span class="bu">print</span>(<span class="ss">f"z1: </span><span class="sc">{</span>z1<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb23-44"><a href="#cb23-44"></a><span class="bu">print</span>(<span class="ss">f"z2: </span><span class="sc">{</span>z2<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb23-45"><a href="#cb23-45"></a></span>
<span id="cb23-46"><a href="#cb23-46"></a><span class="co"># Calcular la suma acumulada de un tensor</span></span>
<span id="cb23-47"><a href="#cb23-47"></a>z <span class="op">=</span> torch.cumsum(x, dim<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb23-48"><a href="#cb23-48"></a></span>
<span id="cb23-49"><a href="#cb23-49"></a><span class="bu">print</span>(<span class="ss">f"Cumulative sum: </span><span class="sc">{</span>z<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>Shape: torch.Size([2, 2, 2])
Size: torch.Size([2, 2, 2])
Data type: torch.int64
Device: cpu
Number of dimensions: 3
Number of elements in the first dimension: 2
Element at position (0, 1, 1): 4
Subtensor: tensor([[1, 2],
        [3, 4]])
Reshape: tensor([[1, 2, 3, 4],
        [5, 6, 7, 8]])
Flatten: tensor([1, 2, 3, 4, 5, 6, 7, 8])
tensor([[[ 1,  2],
         [ 3,  4]],

        [[ 5,  6],
         [ 7,  8]],

        [[ 9, 10],
         [11, 12]],

        [[13, 14],
         [15, 16]]])
z1: tensor([[[1, 2],
         [3, 4]],

        [[5, 6],
         [7, 8]]])
z2: tensor([[[ 9, 10],
         [11, 12]],

        [[13, 14],
         [15, 16]]])
Cumulative sum: tensor([[[ 1,  2],
         [ 3,  4]],

        [[ 6,  8],
         [10, 12]]])</code></pre>
</div>
</div>
</section>
</section>
<section id="estructura-de-una-red-neuronal-artificial-en-pytorch" class="level3">
<h3 class="anchored" data-anchor-id="estructura-de-una-red-neuronal-artificial-en-pytorch">Estructura de una red neuronal artificial en PyTorch</h3>
<p>Veamos las distintas partes de una red neuronal artificial en <code>PyTorch</code>.</p>
<section id="ejemplo-de-clasificación-1" class="level4">
<h4 class="anchored" data-anchor-id="ejemplo-de-clasificación-1">Ejemplo de clasificación</h4>
<p>En este ejemplo, vamos a utilizar la base de datos <code>iris</code> para entrenar una red neuronal artificial que permita clasificar las flores en tres categorías: <code>setosa</code>, <code>versicolor</code> y <code>virginica</code>.</p>
<div id="90bce513" class="cell" data-execution_count="13">
<details open="" class="code-fold">
<summary>Código</summary>
<div class="sourceCode cell-code" id="cb25"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1"></a><span class="im">import</span> torch</span>
<span id="cb25-2"><a href="#cb25-2"></a><span class="im">import</span> torch.nn <span class="im">as</span> nn</span>
<span id="cb25-3"><a href="#cb25-3"></a></span>
<span id="cb25-4"><a href="#cb25-4"></a><span class="co"># Crear la red neuronal artificial</span></span>
<span id="cb25-5"><a href="#cb25-5"></a></span>
<span id="cb25-6"><a href="#cb25-6"></a><span class="kw">class</span> MLP(nn.Module):</span>
<span id="cb25-7"><a href="#cb25-7"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>):</span>
<span id="cb25-8"><a href="#cb25-8"></a>        <span class="bu">super</span>(MLP, <span class="va">self</span>).<span class="fu">__init__</span>()</span>
<span id="cb25-9"><a href="#cb25-9"></a>        <span class="va">self</span>.fc1 <span class="op">=</span> nn.Linear(<span class="dv">4</span>, <span class="dv">10</span>)</span>
<span id="cb25-10"><a href="#cb25-10"></a>        <span class="va">self</span>.fc2 <span class="op">=</span> nn.Linear(<span class="dv">10</span>, <span class="dv">10</span>)</span>
<span id="cb25-11"><a href="#cb25-11"></a>        <span class="va">self</span>.fc3 <span class="op">=</span> nn.Linear(<span class="dv">10</span>, <span class="dv">3</span>)</span>
<span id="cb25-12"><a href="#cb25-12"></a>        <span class="va">self</span>.relu <span class="op">=</span> nn.ReLU()</span>
<span id="cb25-13"><a href="#cb25-13"></a>        <span class="va">self</span>.softmax <span class="op">=</span> nn.Softmax(dim<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb25-14"><a href="#cb25-14"></a>        </span>
<span id="cb25-15"><a href="#cb25-15"></a>    <span class="kw">def</span> forward(<span class="va">self</span>, x):</span>
<span id="cb25-16"><a href="#cb25-16"></a>        x <span class="op">=</span> <span class="va">self</span>.relu(<span class="va">self</span>.fc1(x))</span>
<span id="cb25-17"><a href="#cb25-17"></a>        x <span class="op">=</span> <span class="va">self</span>.relu(<span class="va">self</span>.fc2(x))</span>
<span id="cb25-18"><a href="#cb25-18"></a>        x <span class="op">=</span> <span class="va">self</span>.fc3(x)</span>
<span id="cb25-19"><a href="#cb25-19"></a>        x <span class="op">=</span> <span class="va">self</span>.softmax(x)</span>
<span id="cb25-20"><a href="#cb25-20"></a>        <span class="cf">return</span> x</span>
<span id="cb25-21"><a href="#cb25-21"></a></span>
<span id="cb25-22"><a href="#cb25-22"></a>model <span class="op">=</span> MLP()</span>
<span id="cb25-23"><a href="#cb25-23"></a></span>
<span id="cb25-24"><a href="#cb25-24"></a><span class="bu">print</span>(model)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>MLP(
  (fc1): Linear(in_features=4, out_features=10, bias=True)
  (fc2): Linear(in_features=10, out_features=10, bias=True)
  (fc3): Linear(in_features=10, out_features=3, bias=True)
  (relu): ReLU()
  (softmax): Softmax(dim=1)
)</code></pre>
</div>
</div>
<p>Para crear la red neuronal artificial, definimos una clase llamada <code>MLP</code> que hereda de <code>nn.Module</code>. En el método <code>__init__</code>, definimos las capas de la red neuronal artificial y las funciones de activación. En el método <code>forward</code>, definimos la arquitectura de la red neuronal artificial.</p>
<p>Dentro del método <code>__init__</code>, usamos la función <code>super</code> para inicializar la clase base <code>nn.Module</code>. Luego, definimos las capas de la red neuronal artificial utilizando la clase <code>nn.Linear</code> que representa una capa de neuronas completamente conectada. En este caso, definimos tres capas de neuronas con 4, 10 y 3 neuronas respectivamente.</p>
<p>También definimos las funciones de activación <code>nn.ReLU</code> y <code>nn.Softmax</code> para las capas ocultas y de salida respectivamente. La función de activación <code>ReLU</code> se utiliza para introducir no linealidades en la red neuronal artificial, mientras que la función de activación <code>Softmax</code> se utiliza para obtener probabilidades de las clases y recive como argumento la dimensión en la que se calcula el softmax.</p>
<p>En el método <code>forward</code>, definimos la arquitectura de la red neuronal artificial. Primero aplicamos la capa <code>fc1</code> seguida de la función de activación <code>ReLU</code>. Luego aplicamos la capa <code>fc2</code> seguida de la función de activación <code>ReLU</code>. Finalmente aplicamos la capa <code>fc3</code> seguida de la función de activación <code>Softmax</code>.</p>
<p>La función <code>Linear</code> aplicará una transformación lineal a los datos de entrada: <span class="math inline">\(y = xA^T + b\)</span>, donde <span class="math inline">\(x\)</span> es la entrada, <span class="math inline">\(A\)</span> es la matriz de pesos y <span class="math inline">\(b\)</span> es el vector de sesgos.</p>
<p>Es importante que las neuronas entre capas tengan la misma cantidad de neuronas que la capa anterior y la capa siguiente. En este caso, la capa de entrada tiene 4 neuronas, la capa oculta tiene 10 neuronas y la capa de salida tiene 3 neuronas.</p>
<p>Vamos a usar la base de datos <code>iris</code> para ver que resultados obtenemos.</p>
<div id="49672b2e" class="cell" data-execution_count="14">
<details open="" class="code-fold">
<summary>Código</summary>
<div class="sourceCode cell-code" id="cb27"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb27-1"><a href="#cb27-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb27-2"><a href="#cb27-2"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb27-3"><a href="#cb27-3"></a><span class="im">from</span> sklearn.datasets <span class="im">import</span> load_iris</span>
<span id="cb27-4"><a href="#cb27-4"></a></span>
<span id="cb27-5"><a href="#cb27-5"></a><span class="co"># Cargar la base de datos iris</span></span>
<span id="cb27-6"><a href="#cb27-6"></a>iris <span class="op">=</span> load_iris()</span>
<span id="cb27-7"><a href="#cb27-7"></a>X <span class="op">=</span> iris.data</span>
<span id="cb27-8"><a href="#cb27-8"></a>y <span class="op">=</span> iris.target</span>
<span id="cb27-9"><a href="#cb27-9"></a></span>
<span id="cb27-10"><a href="#cb27-10"></a>model <span class="op">=</span> MLP()</span>
<span id="cb27-11"><a href="#cb27-11"></a></span>
<span id="cb27-12"><a href="#cb27-12"></a><span class="co"># Convertir los datos a tensores de PyTorch</span></span>
<span id="cb27-13"><a href="#cb27-13"></a>X <span class="op">=</span> torch.tensor(X, dtype<span class="op">=</span>torch.float32)</span>
<span id="cb27-14"><a href="#cb27-14"></a>y <span class="op">=</span> torch.tensor(y, dtype<span class="op">=</span>torch.<span class="bu">long</span>)</span>
<span id="cb27-15"><a href="#cb27-15"></a></span>
<span id="cb27-16"><a href="#cb27-16"></a><span class="bu">print</span>(X.shape)</span>
<span id="cb27-17"><a href="#cb27-17"></a><span class="bu">print</span>(y.shape)</span>
<span id="cb27-18"><a href="#cb27-18"></a></span>
<span id="cb27-19"><a href="#cb27-19"></a><span class="co"># Obtener las predicciones de la red neuronal artificial</span></span>
<span id="cb27-20"><a href="#cb27-20"></a>y_pred <span class="op">=</span> model(X)</span>
<span id="cb27-21"><a href="#cb27-21"></a></span>
<span id="cb27-22"><a href="#cb27-22"></a><span class="bu">print</span>(y_pred)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>torch.Size([150, 4])
torch.Size([150])
tensor([[0.3815, 0.2707, 0.3478],
        [0.3707, 0.2763, 0.3529],
        [0.3767, 0.2748, 0.3485],
        [0.3761, 0.2767, 0.3472],
        [0.3848, 0.2700, 0.3452],
        [0.3857, 0.2675, 0.3468],
        [0.3805, 0.2740, 0.3455],
        [0.3804, 0.2723, 0.3473],
        [0.3722, 0.2792, 0.3486],
        [0.3762, 0.2751, 0.3487],
        [0.3846, 0.2679, 0.3474],
        [0.3825, 0.2732, 0.3442],
        [0.3740, 0.2762, 0.3498],
        [0.3763, 0.2772, 0.3465],
        [0.3872, 0.2628, 0.3499],
        [0.3947, 0.2610, 0.3442],
        [0.3835, 0.2665, 0.3500],
        [0.3790, 0.2712, 0.3498],
        [0.3833, 0.2669, 0.3498],
        [0.3871, 0.2685, 0.3445],
        [0.3782, 0.2714, 0.3503],
        [0.3820, 0.2700, 0.3479],
        [0.3859, 0.2704, 0.3438],
        [0.3707, 0.2750, 0.3542],
        [0.3841, 0.2740, 0.3418],
        [0.3710, 0.2765, 0.3525],
        [0.3759, 0.2736, 0.3505],
        [0.3813, 0.2706, 0.3481],
        [0.3782, 0.2713, 0.3505],
        [0.3783, 0.2756, 0.3461],
        [0.3751, 0.2763, 0.3487],
        [0.3722, 0.2719, 0.3559],
        [0.3988, 0.2640, 0.3371],
        [0.3958, 0.2623, 0.3418],
        [0.3737, 0.2756, 0.3506],
        [0.3738, 0.2735, 0.3527],
        [0.3777, 0.2690, 0.3532],
        [0.3881, 0.2698, 0.3420],
        [0.3741, 0.2779, 0.3480],
        [0.3796, 0.2719, 0.3485],
        [0.3793, 0.2713, 0.3494],
        [0.3538, 0.2849, 0.3613],
        [0.3791, 0.2759, 0.3450],
        [0.3735, 0.2737, 0.3529],
        [0.3867, 0.2701, 0.3432],
        [0.3691, 0.2772, 0.3537],
        [0.3901, 0.2682, 0.3417],
        [0.3781, 0.2754, 0.3465],
        [0.3854, 0.2683, 0.3463],
        [0.3773, 0.2730, 0.3496],
        [0.3250, 0.2925, 0.3825],
        [0.3263, 0.2936, 0.3801],
        [0.3203, 0.2957, 0.3840],
        [0.3146, 0.3016, 0.3837],
        [0.3154, 0.3000, 0.3847],
        [0.3272, 0.2929, 0.3800],
        [0.3270, 0.2936, 0.3794],
        [0.3322, 0.2924, 0.3754],
        [0.3230, 0.2938, 0.3832],
        [0.3244, 0.2970, 0.3785],
        [0.3196, 0.2988, 0.3816],
        [0.3244, 0.2961, 0.3795],
        [0.3173, 0.2974, 0.3853],
        [0.3239, 0.2944, 0.3816],
        [0.3294, 0.2935, 0.3772],
        [0.3242, 0.2940, 0.3818],
        [0.3271, 0.2943, 0.3786],
        [0.3342, 0.2883, 0.3776],
        [0.3119, 0.3071, 0.3809],
        [0.3256, 0.2940, 0.3803],
        [0.3213, 0.2986, 0.3800],
        [0.3233, 0.2955, 0.3811],
        [0.3136, 0.3026, 0.3839],
        [0.3275, 0.2911, 0.3814],
        [0.3241, 0.2940, 0.3818],
        [0.3223, 0.2953, 0.3824],
        [0.3160, 0.2979, 0.3861],
        [0.3157, 0.3008, 0.3834],
        [0.3213, 0.2972, 0.3815],
        [0.3307, 0.2913, 0.3780],
        [0.3234, 0.2956, 0.3810],
        [0.3272, 0.2933, 0.3795],
        [0.3259, 0.2940, 0.3801],
        [0.3147, 0.3010, 0.3843],
        [0.3287, 0.2937, 0.3776],
        [0.3317, 0.2916, 0.3767],
        [0.3216, 0.2956, 0.3828],
        [0.3131, 0.3023, 0.3846],
        [0.3331, 0.2904, 0.3765],
        [0.3200, 0.2984, 0.3816],
        [0.3268, 0.2932, 0.3801],
        [0.3265, 0.2931, 0.3804],
        [0.3234, 0.2953, 0.3813],
        [0.3282, 0.2944, 0.3774],
        [0.3248, 0.2950, 0.3802],
        [0.3364, 0.2879, 0.3757],
        [0.3294, 0.2921, 0.3784],
        [0.3257, 0.2934, 0.3809],
        [0.3285, 0.2949, 0.3766],
        [0.3266, 0.2940, 0.3794],
        [0.3149, 0.3109, 0.3742],
        [0.3139, 0.3066, 0.3794],
        [0.3139, 0.3074, 0.3787],
        [0.3150, 0.3018, 0.3833],
        [0.3141, 0.3085, 0.3774],
        [0.3133, 0.3066, 0.3801],
        [0.3142, 0.3049, 0.3809],
        [0.3139, 0.3020, 0.3841],
        [0.3121, 0.3071, 0.3808],
        [0.3163, 0.3076, 0.3762],
        [0.3162, 0.3037, 0.3801],
        [0.3134, 0.3073, 0.3793],
        [0.3143, 0.3078, 0.3779],
        [0.3125, 0.3112, 0.3763],
        [0.3129, 0.3155, 0.3716],
        [0.3153, 0.3091, 0.3757],
        [0.3154, 0.3012, 0.3834],
        [0.3179, 0.2985, 0.3836],
        [0.3100, 0.3151, 0.3749],
        [0.3120, 0.3055, 0.3826],
        [0.3147, 0.3090, 0.3762],
        [0.3145, 0.3075, 0.3780],
        [0.3123, 0.3070, 0.3807],
        [0.3139, 0.3061, 0.3800],
        [0.3162, 0.3033, 0.3805],
        [0.3160, 0.2988, 0.3852],
        [0.3146, 0.3049, 0.3805],
        [0.3159, 0.3019, 0.3821],
        [0.3133, 0.3093, 0.3774],
        [0.3154, 0.2978, 0.3868],
        [0.3130, 0.3059, 0.3811],
        [0.3184, 0.2957, 0.3859],
        [0.3130, 0.3113, 0.3757],
        [0.3172, 0.2980, 0.3848],
        [0.3172, 0.2967, 0.3861],
        [0.3127, 0.3121, 0.3752],
        [0.3162, 0.3076, 0.3762],
        [0.3161, 0.2998, 0.3841],
        [0.3160, 0.3020, 0.3820],
        [0.3148, 0.3070, 0.3782],
        [0.3140, 0.3122, 0.3739],
        [0.3143, 0.3118, 0.3739],
        [0.3139, 0.3066, 0.3794],
        [0.3148, 0.3083, 0.3769],
        [0.3149, 0.3114, 0.3737],
        [0.3138, 0.3124, 0.3738],
        [0.3123, 0.3104, 0.3773],
        [0.3149, 0.3060, 0.3791],
        [0.3167, 0.3059, 0.3775],
        [0.3164, 0.3010, 0.3826]], grad_fn=&lt;SoftmaxBackward0&gt;)</code></pre>
</div>
</div>
<p>Que nos regresa un tensor con las probabilidades de cada clase para cada observación. Para obtener la clase predicha, podemos usar la función <code>argmax</code> de PyTorch.</p>
<div id="7867662a" class="cell" data-execution_count="15">
<details open="" class="code-fold">
<summary>Código</summary>
<div class="sourceCode cell-code" id="cb29"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb29-1"><a href="#cb29-1"></a><span class="co"># Obtener la clase predicha</span></span>
<span id="cb29-2"><a href="#cb29-2"></a>y_pred <span class="op">=</span> torch.argmax(y_pred, dim<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb29-3"><a href="#cb29-3"></a></span>
<span id="cb29-4"><a href="#cb29-4"></a><span class="bu">print</span>(y_pred)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>tensor([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0,
        0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2])</code></pre>
</div>
</div>
</section>
<section id="funciones-de-activación-en-pytorch" class="level4">
<h4 class="anchored" data-anchor-id="funciones-de-activación-en-pytorch">Funciones de activación en PyTorch</h4>
<p>En <code>PyTorch</code>, las funciones de activación se pueden utilizar como capas en una red neuronal artificial. Las funciones de activación más comunes son <code>ReLU</code>, <code>Sigmoid</code> y <code>Softmax</code>.</p>
<div id="50f7f92d" class="cell" data-execution_count="16">
<details open="" class="code-fold">
<summary>Código</summary>
<div class="sourceCode cell-code" id="cb31"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb31-1"><a href="#cb31-1"></a><span class="im">import</span> torch</span>
<span id="cb31-2"><a href="#cb31-2"></a></span>
<span id="cb31-3"><a href="#cb31-3"></a><span class="co"># Crear un tensor de entrada</span></span>
<span id="cb31-4"><a href="#cb31-4"></a>x <span class="op">=</span> torch.tensor([[<span class="fl">1.0</span>, <span class="op">-</span><span class="fl">1.0</span>], [<span class="op">-</span><span class="fl">1.0</span>, <span class="fl">1.0</span>]])</span>
<span id="cb31-5"><a href="#cb31-5"></a></span>
<span id="cb31-6"><a href="#cb31-6"></a><span class="co"># Función de activación ReLU</span></span>
<span id="cb31-7"><a href="#cb31-7"></a>relu <span class="op">=</span> torch.nn.ReLU()</span>
<span id="cb31-8"><a href="#cb31-8"></a>y <span class="op">=</span> relu(x)</span>
<span id="cb31-9"><a href="#cb31-9"></a></span>
<span id="cb31-10"><a href="#cb31-10"></a><span class="bu">print</span>(<span class="ss">f"ReLU: </span><span class="sc">{</span>y<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb31-11"><a href="#cb31-11"></a></span>
<span id="cb31-12"><a href="#cb31-12"></a><span class="co"># Función de activación Sigmoid</span></span>
<span id="cb31-13"><a href="#cb31-13"></a>sigmoid <span class="op">=</span> torch.nn.Sigmoid()</span>
<span id="cb31-14"><a href="#cb31-14"></a>y <span class="op">=</span> sigmoid(x)</span>
<span id="cb31-15"><a href="#cb31-15"></a></span>
<span id="cb31-16"><a href="#cb31-16"></a><span class="bu">print</span>(<span class="ss">f"Sigmoid: </span><span class="sc">{</span>y<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb31-17"><a href="#cb31-17"></a></span>
<span id="cb31-18"><a href="#cb31-18"></a><span class="co"># Función de activación Softmax</span></span>
<span id="cb31-19"><a href="#cb31-19"></a>softmax <span class="op">=</span> torch.nn.Softmax(dim<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb31-20"><a href="#cb31-20"></a>y <span class="op">=</span> softmax(x)</span>
<span id="cb31-21"><a href="#cb31-21"></a></span>
<span id="cb31-22"><a href="#cb31-22"></a><span class="bu">print</span>(<span class="ss">f"Softmax: </span><span class="sc">{</span>y<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb31-23"><a href="#cb31-23"></a></span>
<span id="cb31-24"><a href="#cb31-24"></a><span class="co"># Función de activación Tanh</span></span>
<span id="cb31-25"><a href="#cb31-25"></a>tanh <span class="op">=</span> torch.nn.Tanh()</span>
<span id="cb31-26"><a href="#cb31-26"></a>y <span class="op">=</span> tanh(x)</span>
<span id="cb31-27"><a href="#cb31-27"></a></span>
<span id="cb31-28"><a href="#cb31-28"></a><span class="bu">print</span>(<span class="ss">f"Tanh: </span><span class="sc">{</span>y<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb31-29"><a href="#cb31-29"></a></span>
<span id="cb31-30"><a href="#cb31-30"></a><span class="co"># Función de activación LeakyReLU</span></span>
<span id="cb31-31"><a href="#cb31-31"></a>leaky_relu <span class="op">=</span> torch.nn.LeakyReLU(negative_slope<span class="op">=</span><span class="fl">0.01</span>)</span>
<span id="cb31-32"><a href="#cb31-32"></a>y <span class="op">=</span> leaky_relu(x)</span>
<span id="cb31-33"><a href="#cb31-33"></a></span>
<span id="cb31-34"><a href="#cb31-34"></a><span class="bu">print</span>(<span class="ss">f"LeakyReLU: </span><span class="sc">{</span>y<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>ReLU: tensor([[1., 0.],
        [0., 1.]])
Sigmoid: tensor([[0.7311, 0.2689],
        [0.2689, 0.7311]])
Softmax: tensor([[0.8808, 0.1192],
        [0.1192, 0.8808]])
Tanh: tensor([[ 0.7616, -0.7616],
        [-0.7616,  0.7616]])
LeakyReLU: tensor([[ 1.0000, -0.0100],
        [-0.0100,  1.0000]])</code></pre>
</div>
</div>
</section>
</section>
<section id="entrenamiento-de-la-red-neuronal" class="level3">
<h3 class="anchored" data-anchor-id="entrenamiento-de-la-red-neuronal">Entrenamiento de la red neuronal</h3>
<p>Para entrenar la red neuronal artificial, primero debemos definir una función de pérdida y un optimizador.</p>
<section id="función-de-pérdida" class="level4">
<h4 class="anchored" data-anchor-id="función-de-pérdida">Función de pérdida</h4>
<p>La función de pérdida mide la diferencia entre las predicciones de la red neuronal artificial y las etiquetas reales. Existen diversas funciones de pérdida para problemas de clasificación y regresión.</p>
<ul>
<li>Funciones de pérdida para problemas de clasificación:
<ul>
<li><code>nn.CrossEntropyLoss</code>: Utilizada para problemas de clasificación multiclase.</li>
<li><code>nn.BCELoss</code>: Utilizada para problemas de clasificación binaria.</li>
<li><code>nn.NLLLoss</code>: Utilizada para problemas de clasificación multiclase con salida logarítmica.</li>
</ul></li>
<li>Funciones de pérdida para problemas de regresión:
<ul>
<li><code>nn.MSELoss</code>: Utilizada para problemas de regresión de mínimos cuadrados.</li>
<li><code>nn.L1Loss</code>: Utilizada para problemas de regresión de mínimos absolutos.</li>
<li><code>nn.SmoothL1Loss</code>: Utilizada para problemas de regresión de mínimos suavizados.</li>
</ul></li>
</ul>
<div id="9b1ab40e" class="cell" data-execution_count="17">
<details open="" class="code-fold">
<summary>Código</summary>
<div class="sourceCode cell-code" id="cb33"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb33-1"><a href="#cb33-1"></a><span class="im">import</span> torch.nn <span class="im">as</span> nn</span>
<span id="cb33-2"><a href="#cb33-2"></a></span>
<span id="cb33-3"><a href="#cb33-3"></a>y_pred <span class="op">=</span> torch.tensor([[<span class="fl">0.1</span>, <span class="fl">0.2</span>, <span class="fl">0.7</span>], [<span class="fl">0.8</span>, <span class="fl">0.1</span>, <span class="fl">0.1</span>], [<span class="fl">0.2</span>, <span class="fl">0.6</span>, <span class="fl">0.2</span>]])</span>
<span id="cb33-4"><a href="#cb33-4"></a>y <span class="op">=</span> torch.tensor([<span class="dv">2</span>, <span class="dv">0</span>, <span class="dv">1</span>])</span>
<span id="cb33-5"><a href="#cb33-5"></a></span>
<span id="cb33-6"><a href="#cb33-6"></a><span class="co"># Crear la función de pérdida</span></span>
<span id="cb33-7"><a href="#cb33-7"></a>criterion <span class="op">=</span> nn.CrossEntropyLoss()</span>
<span id="cb33-8"><a href="#cb33-8"></a></span>
<span id="cb33-9"><a href="#cb33-9"></a><span class="co"># Calcular la pérdida</span></span>
<span id="cb33-10"><a href="#cb33-10"></a>loss <span class="op">=</span> criterion(y_pred, y)</span>
<span id="cb33-11"><a href="#cb33-11"></a></span>
<span id="cb33-12"><a href="#cb33-12"></a><span class="bu">print</span>(loss)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>tensor(0.7694)</code></pre>
</div>
</div>
<p>Nos regresa el error de la red neuronal. Para minimizar la función de pérdida, utilizamos un optimizador.</p>
</section>
<section id="optimizador" class="level4">
<h4 class="anchored" data-anchor-id="optimizador">Optimizador</h4>
<p>El optimizador ajusta los pesos de la red neuronal artificial para minimizar la función de pérdida. Existen diversos optimizadores que se pueden utilizar para entrenar una red neuronal artificial.</p>
<ul>
<li>Optimizadores basados en gradiente:
<ul>
<li><code>torch.optim.SGD</code>: Descenso de gradiente estocástico.</li>
<li><code>torch.optim.Adam</code>: Algoritmo de optimización basado en el método de Adam.</li>
<li><code>torch.optim.RMSprop</code>: Algoritmo de optimización basado en el método de RMSprop.</li>
</ul></li>
</ul>
<p>Cadad optimizador tiene sus propios hiperparámetros que se pueden ajustar para mejorar el rendimiento de la red neuronal artificial.</p>
<div id="1cdfc55a" class="cell" data-execution_count="18">
<details open="" class="code-fold">
<summary>Código</summary>
<div class="sourceCode cell-code" id="cb35"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb35-1"><a href="#cb35-1"></a><span class="im">import</span> torch.optim <span class="im">as</span> optim</span>
<span id="cb35-2"><a href="#cb35-2"></a></span>
<span id="cb35-3"><a href="#cb35-3"></a><span class="co"># Crear el optimizador</span></span>
<span id="cb35-4"><a href="#cb35-4"></a>optimizer <span class="op">=</span> optim.SGD(model.parameters(), lr<span class="op">=</span><span class="fl">0.01</span>)</span>
<span id="cb35-5"><a href="#cb35-5"></a></span>
<span id="cb35-6"><a href="#cb35-6"></a><span class="co"># Realizar la retropropagación</span></span>
<span id="cb35-7"><a href="#cb35-7"></a>optimizer.zero_grad()</span>
<span id="cb35-8"><a href="#cb35-8"></a></span>
<span id="cb35-9"><a href="#cb35-9"></a><span class="co"># loss.backward()</span></span>
<span id="cb35-10"><a href="#cb35-10"></a></span>
<span id="cb35-11"><a href="#cb35-11"></a><span class="co"># Actualizar los pesos</span></span>
<span id="cb35-12"><a href="#cb35-12"></a>optimizer.step()</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>En este caso, utilizamos el optimizador <code>SGD</code> con una tasa de aprendizaje de 0.01. Primero, llamamos al método <code>zero_grad</code> para restablecer los gradientes de los pesos de la red neuronal artificial. Luego, llamamos al método <code>backward</code> para calcular los gradientes de la función de pérdida con respecto a los pesos. Finalmente, llamamos al método <code>step</code> para actualizar los pesos de la red neuronal artificial utilizando el algoritmo de optimización.</p>
<p>Estos pasos se repiten varias veces para entrenar la red neuronal artificial en un conjunto de datos.</p>
</section>
</section>
<section id="preparación-de-los-datos" class="level3">
<h3 class="anchored" data-anchor-id="preparación-de-los-datos">Preparación de los datos</h3>
<p>Para entrenar una red neuronal artificial, primero debemos preparar los datos en tensores de PyTorch.</p>
<div id="c66894fb" class="cell" data-execution_count="19">
<details open="" class="code-fold">
<summary>Código</summary>
<div class="sourceCode cell-code" id="cb36"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb36-1"><a href="#cb36-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb36-2"><a href="#cb36-2"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb36-3"><a href="#cb36-3"></a><span class="im">from</span> sklearn.datasets <span class="im">import</span> load_iris</span>
<span id="cb36-4"><a href="#cb36-4"></a><span class="im">from</span> sklearn.model_selection <span class="im">import</span> train_test_split</span>
<span id="cb36-5"><a href="#cb36-5"></a></span>
<span id="cb36-6"><a href="#cb36-6"></a><span class="co"># Cargar la base de datos iris</span></span>
<span id="cb36-7"><a href="#cb36-7"></a>iris <span class="op">=</span> load_iris()</span>
<span id="cb36-8"><a href="#cb36-8"></a>X <span class="op">=</span> iris.data</span>
<span id="cb36-9"><a href="#cb36-9"></a>y <span class="op">=</span> iris.target</span>
<span id="cb36-10"><a href="#cb36-10"></a></span>
<span id="cb36-11"><a href="#cb36-11"></a><span class="co"># Dividir la base de datos en entrenamiento y prueba</span></span>
<span id="cb36-12"><a href="#cb36-12"></a>X_train, X_test, y_train, y_test <span class="op">=</span> train_test_split(X, y, test_size<span class="op">=</span><span class="fl">0.2</span>, random_state<span class="op">=</span><span class="dv">1014</span>)</span>
<span id="cb36-13"><a href="#cb36-13"></a></span>
<span id="cb36-14"><a href="#cb36-14"></a><span class="co"># Convertir los datos a tensores de PyTorch</span></span>
<span id="cb36-15"><a href="#cb36-15"></a>X_train <span class="op">=</span> torch.tensor(X_train, dtype<span class="op">=</span>torch.float32)</span>
<span id="cb36-16"><a href="#cb36-16"></a>X_test <span class="op">=</span> torch.tensor(X_test, dtype<span class="op">=</span>torch.float32)</span>
<span id="cb36-17"><a href="#cb36-17"></a>y_train <span class="op">=</span> torch.tensor(y_train, dtype<span class="op">=</span>torch.<span class="bu">long</span>)</span>
<span id="cb36-18"><a href="#cb36-18"></a>y_test <span class="op">=</span> torch.tensor(y_test, dtype<span class="op">=</span>torch.<span class="bu">long</span>)</span>
<span id="cb36-19"><a href="#cb36-19"></a></span>
<span id="cb36-20"><a href="#cb36-20"></a><span class="bu">print</span>(X_train.shape)</span>
<span id="cb36-21"><a href="#cb36-21"></a><span class="bu">print</span>(X_test.shape)</span>
<span id="cb36-22"><a href="#cb36-22"></a><span class="bu">print</span>(y_train.shape)</span>
<span id="cb36-23"><a href="#cb36-23"></a><span class="bu">print</span>(y_test.shape)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>torch.Size([120, 4])
torch.Size([30, 4])
torch.Size([120])
torch.Size([30])</code></pre>
</div>
</div>
<p>Los datos tipo <code>torch.long</code> es equivalente a <code>int64</code> en <code>NumPy</code> y se utiliza para representar las etiquetas de las clases.</p>
</section>
<section id="red-neuronal-con-pytorch" class="level3">
<h3 class="anchored" data-anchor-id="red-neuronal-con-pytorch">Red Neuronal con PyTorch</h3>
<p>Vamos a definir una red neuronal de 2 capas ocultas con 4 neuronas cada capa y una capa de salida con 3 neuronas.</p>
<div id="ffda0bcc" class="cell" data-execution_count="20">
<details open="" class="code-fold">
<summary>Código</summary>
<div class="sourceCode cell-code" id="cb38"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb38-1"><a href="#cb38-1"></a><span class="kw">class</span> NeuralNetwork(nn.Module):</span>
<span id="cb38-2"><a href="#cb38-2"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>):</span>
<span id="cb38-3"><a href="#cb38-3"></a>        <span class="bu">super</span>(NeuralNetwork, <span class="va">self</span>).<span class="fu">__init__</span>()</span>
<span id="cb38-4"><a href="#cb38-4"></a>        <span class="va">self</span>.fc1 <span class="op">=</span> nn.Linear(<span class="dv">4</span>, <span class="dv">4</span>)</span>
<span id="cb38-5"><a href="#cb38-5"></a>        <span class="va">self</span>.fc2 <span class="op">=</span> nn.Linear(<span class="dv">4</span>, <span class="dv">4</span>)</span>
<span id="cb38-6"><a href="#cb38-6"></a>        <span class="va">self</span>.fc3 <span class="op">=</span> nn.Linear(<span class="dv">4</span>, <span class="dv">3</span>)</span>
<span id="cb38-7"><a href="#cb38-7"></a>        <span class="va">self</span>.relu <span class="op">=</span> nn.ReLU()</span>
<span id="cb38-8"><a href="#cb38-8"></a>        <span class="va">self</span>.softmax <span class="op">=</span> nn.Softmax(dim<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb38-9"><a href="#cb38-9"></a>        </span>
<span id="cb38-10"><a href="#cb38-10"></a>    <span class="kw">def</span> forward(<span class="va">self</span>, x):</span>
<span id="cb38-11"><a href="#cb38-11"></a>        x <span class="op">=</span> <span class="va">self</span>.relu(<span class="va">self</span>.fc1(x))</span>
<span id="cb38-12"><a href="#cb38-12"></a>        x <span class="op">=</span> <span class="va">self</span>.relu(<span class="va">self</span>.fc2(x))</span>
<span id="cb38-13"><a href="#cb38-13"></a>        x <span class="op">=</span> <span class="va">self</span>.fc3(x)</span>
<span id="cb38-14"><a href="#cb38-14"></a>        x <span class="op">=</span> <span class="va">self</span>.softmax(x)</span>
<span id="cb38-15"><a href="#cb38-15"></a>        <span class="cf">return</span> x</span>
<span id="cb38-16"><a href="#cb38-16"></a>    </span>
<span id="cb38-17"><a href="#cb38-17"></a>    <span class="kw">def</span> predict(<span class="va">self</span>, x):</span>
<span id="cb38-18"><a href="#cb38-18"></a>        <span class="cf">with</span> torch.no_grad():</span>
<span id="cb38-19"><a href="#cb38-19"></a>            y <span class="op">=</span> <span class="va">self</span>.forward(x)</span>
<span id="cb38-20"><a href="#cb38-20"></a>            <span class="cf">return</span> torch.argmax(y, dim<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb38-21"><a href="#cb38-21"></a>    </span>
<span id="cb38-22"><a href="#cb38-22"></a>model <span class="op">=</span> NeuralNetwork()</span>
<span id="cb38-23"><a href="#cb38-23"></a></span>
<span id="cb38-24"><a href="#cb38-24"></a><span class="bu">print</span>(model)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>NeuralNetwork(
  (fc1): Linear(in_features=4, out_features=4, bias=True)
  (fc2): Linear(in_features=4, out_features=4, bias=True)
  (fc3): Linear(in_features=4, out_features=3, bias=True)
  (relu): ReLU()
  (softmax): Softmax(dim=1)
)</code></pre>
</div>
</div>
<p>Ahora creemos una función para entrenar la red neuronal.</p>
<div id="46635f26" class="cell" data-execution_count="21">
<details open="" class="code-fold">
<summary>Código</summary>
<div class="sourceCode cell-code" id="cb40"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb40-1"><a href="#cb40-1"></a><span class="kw">def</span> train(model, X_train, y_train, criterion, optimizer, epochs):</span>
<span id="cb40-2"><a href="#cb40-2"></a>    <span class="cf">for</span> epoch <span class="kw">in</span> <span class="bu">range</span>(epochs):</span>
<span id="cb40-3"><a href="#cb40-3"></a>        optimizer.zero_grad()</span>
<span id="cb40-4"><a href="#cb40-4"></a>        y_pred <span class="op">=</span> model(X_train)</span>
<span id="cb40-5"><a href="#cb40-5"></a>        loss <span class="op">=</span> criterion(y_pred, y_train)</span>
<span id="cb40-6"><a href="#cb40-6"></a>        loss.backward()</span>
<span id="cb40-7"><a href="#cb40-7"></a>        optimizer.step()</span>
<span id="cb40-8"><a href="#cb40-8"></a>        </span>
<span id="cb40-9"><a href="#cb40-9"></a>        <span class="cf">if</span> (epoch <span class="op">+</span> <span class="dv">1</span>) <span class="op">%</span> <span class="dv">50</span> <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb40-10"><a href="#cb40-10"></a>            <span class="bu">print</span>(<span class="ss">f"Epoch </span><span class="sc">{</span>epoch <span class="op">+</span> <span class="dv">1</span><span class="sc">}</span><span class="ss">/</span><span class="sc">{</span>epochs<span class="sc">}</span><span class="ss">, Loss: </span><span class="sc">{</span>loss<span class="sc">.</span>item()<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Ahora vamos a entrenar la red neuronal.</p>
<div id="0da59443" class="cell" data-execution_count="22">
<details open="" class="code-fold">
<summary>Código</summary>
<div class="sourceCode cell-code" id="cb41"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb41-1"><a href="#cb41-1"></a>criterion <span class="op">=</span> nn.CrossEntropyLoss()</span>
<span id="cb41-2"><a href="#cb41-2"></a>optimizer <span class="op">=</span> optim.SGD(model.parameters(), lr<span class="op">=</span><span class="fl">0.01</span>)</span>
<span id="cb41-3"><a href="#cb41-3"></a></span>
<span id="cb41-4"><a href="#cb41-4"></a>train(model, X_train, y_train, criterion, optimizer, epochs<span class="op">=</span><span class="dv">1000</span>)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>Epoch 50/1000, Loss: 1.0754790306091309
Epoch 100/1000, Loss: 1.07102370262146
Epoch 150/1000, Loss: 1.067678689956665
Epoch 200/1000, Loss: 1.0643763542175293
Epoch 250/1000, Loss: 1.0608757734298706
Epoch 300/1000, Loss: 1.0570424795150757
Epoch 350/1000, Loss: 1.052795648574829
Epoch 400/1000, Loss: 1.0484215021133423
Epoch 450/1000, Loss: 1.043760895729065
Epoch 500/1000, Loss: 1.0385349988937378
Epoch 550/1000, Loss: 1.0325710773468018
Epoch 600/1000, Loss: 1.0256762504577637
Epoch 650/1000, Loss: 1.0176128149032593
Epoch 700/1000, Loss: 1.0081112384796143
Epoch 750/1000, Loss: 0.9968506693840027
Epoch 800/1000, Loss: 0.9835156798362732
Epoch 850/1000, Loss: 0.9678962826728821
Epoch 900/1000, Loss: 0.9499657154083252
Epoch 950/1000, Loss: 0.9237939119338989
Epoch 1000/1000, Loss: 0.9007318615913391</code></pre>
</div>
</div>
<p>Finalmente, vamos a evaluar la red neuronal en la base de datos de prueba.</p>
<div id="eb998cc5" class="cell" data-execution_count="23">
<details open="" class="code-fold">
<summary>Código</summary>
<div class="sourceCode cell-code" id="cb43"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb43-1"><a href="#cb43-1"></a>y_pred <span class="op">=</span> model.predict(X_test)</span>
<span id="cb43-2"><a href="#cb43-2"></a></span>
<span id="cb43-3"><a href="#cb43-3"></a><span class="bu">print</span>(y_pred)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>tensor([2, 2, 2, 0, 2, 0, 2, 0, 2, 2, 0, 2, 0, 2, 2, 2, 0, 0, 2, 2, 2, 2, 2, 2,
        0, 2, 2, 0, 2, 2])</code></pre>
</div>
</div>
<p>Calculamos la precisión de la red neuronal.</p>
<div id="84307d2b" class="cell" data-execution_count="24">
<details open="" class="code-fold">
<summary>Código</summary>
<div class="sourceCode cell-code" id="cb45"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb45-1"><a href="#cb45-1"></a>accuracy <span class="op">=</span> torch.<span class="bu">sum</span>(y_pred <span class="op">==</span> y_test).item() <span class="op">/</span> <span class="bu">len</span>(y_test)</span>
<span id="cb45-2"><a href="#cb45-2"></a></span>
<span id="cb45-3"><a href="#cb45-3"></a><span class="bu">print</span>(<span class="ss">f"Accuracy: </span><span class="sc">{</span>accuracy<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>Accuracy: 0.5</code></pre>
</div>
</div>
<p>Como vemos, la red tiene un precisión muy baja, esto se debe a que la red neuronal es muy compleja para el problema que estamos tratando de resolver. Dismunuyamos la complejidad de la red neuronal.</p>
<div id="90e67930" class="cell" data-execution_count="25">
<details open="" class="code-fold">
<summary>Código</summary>
<div class="sourceCode cell-code" id="cb47"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb47-1"><a href="#cb47-1"></a><span class="kw">class</span> NeuralNetwork(nn.Module):</span>
<span id="cb47-2"><a href="#cb47-2"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>):</span>
<span id="cb47-3"><a href="#cb47-3"></a>        <span class="bu">super</span>(NeuralNetwork, <span class="va">self</span>).<span class="fu">__init__</span>()</span>
<span id="cb47-4"><a href="#cb47-4"></a>        <span class="va">self</span>.fc1 <span class="op">=</span> nn.Linear(<span class="dv">4</span>, <span class="dv">2</span>)</span>
<span id="cb47-5"><a href="#cb47-5"></a>        <span class="va">self</span>.fc2 <span class="op">=</span> nn.Linear(<span class="dv">2</span>, <span class="dv">3</span>)</span>
<span id="cb47-6"><a href="#cb47-6"></a>        <span class="va">self</span>.relu <span class="op">=</span> nn.ReLU()</span>
<span id="cb47-7"><a href="#cb47-7"></a>        <span class="va">self</span>.softmax <span class="op">=</span> nn.Softmax(dim<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb47-8"><a href="#cb47-8"></a>        </span>
<span id="cb47-9"><a href="#cb47-9"></a>    <span class="kw">def</span> forward(<span class="va">self</span>, x):</span>
<span id="cb47-10"><a href="#cb47-10"></a>        x <span class="op">=</span> <span class="va">self</span>.relu(<span class="va">self</span>.fc1(x))</span>
<span id="cb47-11"><a href="#cb47-11"></a>        x <span class="op">=</span> <span class="va">self</span>.fc2(x)</span>
<span id="cb47-12"><a href="#cb47-12"></a>        x <span class="op">=</span> <span class="va">self</span>.softmax(x)</span>
<span id="cb47-13"><a href="#cb47-13"></a>        <span class="cf">return</span> x</span>
<span id="cb47-14"><a href="#cb47-14"></a>    </span>
<span id="cb47-15"><a href="#cb47-15"></a>    <span class="kw">def</span> predict(<span class="va">self</span>, x):</span>
<span id="cb47-16"><a href="#cb47-16"></a>        <span class="cf">with</span> torch.no_grad():</span>
<span id="cb47-17"><a href="#cb47-17"></a>            y <span class="op">=</span> <span class="va">self</span>.forward(x)</span>
<span id="cb47-18"><a href="#cb47-18"></a>            <span class="cf">return</span> torch.argmax(y, dim<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb47-19"><a href="#cb47-19"></a></span>
<span id="cb47-20"><a href="#cb47-20"></a>model <span class="op">=</span> NeuralNetwork()</span>
<span id="cb47-21"><a href="#cb47-21"></a></span>
<span id="cb47-22"><a href="#cb47-22"></a><span class="bu">print</span>(model)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>NeuralNetwork(
  (fc1): Linear(in_features=4, out_features=2, bias=True)
  (fc2): Linear(in_features=2, out_features=3, bias=True)
  (relu): ReLU()
  (softmax): Softmax(dim=1)
)</code></pre>
</div>
</div>
<p>Entrenamos la red neuronal.</p>
<div id="26a6895a" class="cell" data-execution_count="26">
<details open="" class="code-fold">
<summary>Código</summary>
<div class="sourceCode cell-code" id="cb49"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb49-1"><a href="#cb49-1"></a>criterion <span class="op">=</span> nn.CrossEntropyLoss()</span>
<span id="cb49-2"><a href="#cb49-2"></a>optimizer <span class="op">=</span> optim.SGD(model.parameters(), lr<span class="op">=</span><span class="fl">0.1</span>)</span>
<span id="cb49-3"><a href="#cb49-3"></a></span>
<span id="cb49-4"><a href="#cb49-4"></a>train(model, X_train, y_train, criterion, optimizer, epochs<span class="op">=</span><span class="dv">1500</span>)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>Epoch 50/1500, Loss: 1.0786900520324707
Epoch 100/1500, Loss: 1.0306339263916016
Epoch 150/1500, Loss: 0.9199546575546265
Epoch 200/1500, Loss: 0.8805767297744751
Epoch 250/1500, Loss: 0.8552428483963013
Epoch 300/1500, Loss: 0.8381394147872925
Epoch 350/1500, Loss: 0.8256418704986572
Epoch 400/1500, Loss: 0.8157903552055359
Epoch 450/1500, Loss: 0.8073647022247314
Epoch 500/1500, Loss: 0.7996431589126587
Epoch 550/1500, Loss: 0.792230486869812
Epoch 600/1500, Loss: 0.7848939299583435
Epoch 650/1500, Loss: 0.7775012850761414
Epoch 700/1500, Loss: 0.7699931859970093
Epoch 750/1500, Loss: 0.7623674273490906
Epoch 800/1500, Loss: 0.7546666860580444
Epoch 850/1500, Loss: 0.7469660043716431
Epoch 900/1500, Loss: 0.7393587231636047
Epoch 950/1500, Loss: 0.7319421172142029
Epoch 1000/1500, Loss: 0.7248038053512573
Epoch 1050/1500, Loss: 0.7180129289627075
Epoch 1100/1500, Loss: 0.711614727973938
Epoch 1150/1500, Loss: 0.7056317925453186
Epoch 1200/1500, Loss: 0.7000667452812195
Epoch 1250/1500, Loss: 0.6949079632759094
Epoch 1300/1500, Loss: 0.6901333332061768
Epoch 1350/1500, Loss: 0.6857159733772278
Epoch 1400/1500, Loss: 0.6816268563270569
Epoch 1450/1500, Loss: 0.6778366565704346
Epoch 1500/1500, Loss: 0.6743176579475403</code></pre>
</div>
</div>
<p>Evaluamos la red neuronal.</p>
<div id="d8676d00" class="cell" data-execution_count="27">
<details open="" class="code-fold">
<summary>Código</summary>
<div class="sourceCode cell-code" id="cb51"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb51-1"><a href="#cb51-1"></a>y_pred <span class="op">=</span> model.predict(X_test)</span>
<span id="cb51-2"><a href="#cb51-2"></a></span>
<span id="cb51-3"><a href="#cb51-3"></a>accuracy <span class="op">=</span> torch.<span class="bu">sum</span>(y_pred <span class="op">==</span> y_test).item() <span class="op">/</span> <span class="bu">len</span>(y_test)</span>
<span id="cb51-4"><a href="#cb51-4"></a></span>
<span id="cb51-5"><a href="#cb51-5"></a><span class="bu">print</span>(<span class="ss">f"Accuracy: </span><span class="sc">{</span>accuracy<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>Accuracy: 0.9666666666666667</code></pre>
</div>
</div>
<p>Esto mejora la precisión de la red neuronal. Podemos visualizar la matriz de confusión.</p>
<div id="4c67a58b" class="cell" data-execution_count="28">
<details open="" class="code-fold">
<summary>Código</summary>
<div class="sourceCode cell-code" id="cb53"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb53-1"><a href="#cb53-1"></a><span class="im">from</span> sklearn.metrics <span class="im">import</span> confusion_matrix</span>
<span id="cb53-2"><a href="#cb53-2"></a><span class="im">import</span> seaborn <span class="im">as</span> sns</span>
<span id="cb53-3"><a href="#cb53-3"></a></span>
<span id="cb53-4"><a href="#cb53-4"></a>cm <span class="op">=</span> confusion_matrix(y_test, y_pred)</span>
<span id="cb53-5"><a href="#cb53-5"></a></span>
<span id="cb53-6"><a href="#cb53-6"></a>sns.heatmap(cm, annot<span class="op">=</span><span class="va">True</span>, fmt<span class="op">=</span><span class="st">'d'</span>, </span>
<span id="cb53-7"><a href="#cb53-7"></a>            xticklabels<span class="op">=</span>iris.target_names, </span>
<span id="cb53-8"><a href="#cb53-8"></a>            yticklabels<span class="op">=</span>iris.target_names,</span>
<span id="cb53-9"><a href="#cb53-9"></a>            cmap<span class="op">=</span><span class="st">'Blues'</span>)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="ann_python_files/figure-html/cell-29-output-1.png" width="529" height="416" class="figure-img"></p>
</figure>
</div>
</div>
</div>
</section>
</section>
<section id="aspectos-importantes" class="level1">
<h1>Aspectos importantes</h1>
<p>La inicialización de los pesos de la red neuronal puede afectar significativamente el rendimiento del modelo. En general, es importante inicializar los pesos de la red neuronal de manera que no se saturen las neuronas y se evite el problema del desvanecimiento o explosión del gradiente. Existen diversas técnicas de inicialización de pesos que se pueden utilizar para mejorar el rendimiento de la red neuronal artificial. Una de ellas es la <strong>inicialización de Xavier</strong>, que ajusta los pesos de la red neuronal de manera que la varianza de las salidas de las neuronas sea igual a la varianza de las entradas de las neuronas.</p>
<p>Otro aspecto importante es la <strong>regularización de la red neuronal</strong>, que se utiliza para evitar el sobreajuste de la red neuronal a los datos de entrenamiento. Existen diversas técnicas de regularización que se pueden utilizar para mejorar el rendimiento de la red neuronal artificial. Una de ellas es la <strong>regularización L2</strong>, que penaliza los pesos de la red neuronal para evitar que se vuelvan demasiado grandes.</p>
<p>Además, es importante ajustar los hiperparámetros de la red neuronal, como el número de capas ocultas, el número de neuronas en cada capa oculta, la tasa de aprendizaje, el número de épocas de entrenamiento, etc. para mejorar el rendimiento de la red neuronal artificial.</p>
<p>Es importante la escala de los datos, ya que si los datos no están normalizados, la red neuronal puede tener dificultades para converger. Por lo tanto, es importante normalizar los datos antes de entrenar la red neuronal artificial.</p>
<p>Existen diversas formas de normalizar los datos, como la normalización min-max, la normalización z-score, la normalización por rango, etc. En python, podemos utilizar la librería <code>scikit-learn</code> para normalizar los datos.</p>
<div id="3f5c77fb" class="cell" data-execution_count="29">
<details open="" class="code-fold">
<summary>Código</summary>
<div class="sourceCode cell-code" id="cb54"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb54-1"><a href="#cb54-1"></a><span class="im">from</span> sklearn.preprocessing <span class="im">import</span> MinMaxScaler</span>
<span id="cb54-2"><a href="#cb54-2"></a><span class="im">from</span> sklearn.preprocessing <span class="im">import</span> StandardScaler</span>
<span id="cb54-3"><a href="#cb54-3"></a><span class="im">from</span> sklearn.preprocessing <span class="im">import</span> RobustScaler</span>
<span id="cb54-4"><a href="#cb54-4"></a></span>
<span id="cb54-5"><a href="#cb54-5"></a><span class="co"># Normalizar los datos utilizando la normalización min-max</span></span>
<span id="cb54-6"><a href="#cb54-6"></a>scaler <span class="op">=</span> MinMaxScaler()</span>
<span id="cb54-7"><a href="#cb54-7"></a>X_train <span class="op">=</span> scaler.fit_transform(X_train)</span>
<span id="cb54-8"><a href="#cb54-8"></a>X_test <span class="op">=</span> scaler.transform(X_test)</span>
<span id="cb54-9"><a href="#cb54-9"></a></span>
<span id="cb54-10"><a href="#cb54-10"></a>df <span class="op">=</span> pd.DataFrame(X_train, columns<span class="op">=</span>iris.feature_names)</span>
<span id="cb54-11"><a href="#cb54-11"></a><span class="bu">print</span>(df.head())</span>
<span id="cb54-12"><a href="#cb54-12"></a></span>
<span id="cb54-13"><a href="#cb54-13"></a><span class="co"># Normalizar los datos utilizando la normalización z-score</span></span>
<span id="cb54-14"><a href="#cb54-14"></a>scaler <span class="op">=</span> StandardScaler()</span>
<span id="cb54-15"><a href="#cb54-15"></a></span>
<span id="cb54-16"><a href="#cb54-16"></a>X_train <span class="op">=</span> scaler.fit_transform(X_train)</span>
<span id="cb54-17"><a href="#cb54-17"></a>X_test <span class="op">=</span> scaler.transform(X_test)</span>
<span id="cb54-18"><a href="#cb54-18"></a></span>
<span id="cb54-19"><a href="#cb54-19"></a>df <span class="op">=</span> pd.DataFrame(X_train, columns<span class="op">=</span>iris.feature_names)</span>
<span id="cb54-20"><a href="#cb54-20"></a><span class="bu">print</span>(df.head())</span>
<span id="cb54-21"><a href="#cb54-21"></a></span>
<span id="cb54-22"><a href="#cb54-22"></a><span class="co"># Normalizar los datos utilizando la normalización por rango</span></span>
<span id="cb54-23"><a href="#cb54-23"></a>scaler <span class="op">=</span> RobustScaler()</span>
<span id="cb54-24"><a href="#cb54-24"></a></span>
<span id="cb54-25"><a href="#cb54-25"></a>X_train <span class="op">=</span> scaler.fit_transform(X_train)</span>
<span id="cb54-26"><a href="#cb54-26"></a>X_test <span class="op">=</span> scaler.transform(X_test)</span>
<span id="cb54-27"><a href="#cb54-27"></a></span>
<span id="cb54-28"><a href="#cb54-28"></a>df <span class="op">=</span> pd.DataFrame(X_train, columns<span class="op">=</span>iris.feature_names)</span>
<span id="cb54-29"><a href="#cb54-29"></a><span class="bu">print</span>(df.head())</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>   sepal length (cm)  sepal width (cm)  petal length (cm)  petal width (cm)
0           0.250000          0.590909           0.084746          0.041667
1           0.583333          0.454545           0.593220          0.583333
2           0.472222          0.545455           0.593220          0.625000
3           0.500000          0.318182           0.627119          0.541667
4           0.388889          0.363636           0.542373          0.458333
   sepal length (cm)  sepal width (cm)  petal length (cm)  petal width (cm)
0          -0.813744          1.000766          -1.257121         -1.298710
1           0.611793          0.288759           0.384982          0.359218
2           0.136614          0.763431           0.384982          0.486751
3           0.255408         -0.423249           0.494455          0.231685
4          -0.219770         -0.185913           0.220772         -0.023381
   sepal length (cm)  sepal width (cm)  petal length (cm)  petal width (cm)
0          -0.461539          0.833333          -0.805369         -0.786885
1           0.461538          0.333333           0.000000          0.065574
2           0.153846          0.666667           0.000000          0.131148
3           0.230769         -0.166666           0.053691          0.000000
4          -0.076923          0.000000          -0.080537         -0.131147</code></pre>
</div>
</div>
<p>Es importante realizar este proceso <strong>después</strong> de haber dividido los datos en entrenamiento y prueba, para evitar el sesgo en la evaluación del modelo, ya que si se realiza antes de dividir los datos, se estaría utilizando información de la base de datos de prueba para normalizar los datos de entrenamiento y dar de forma indirecta información de la base de datos de prueba a la red neuronal.</p>
</section>
<section id="tensorflow" class="level1">
<h1><code>TensorFlow</code></h1>
<p><code>TensorFlow</code> es una librería de Python que permite implementar redes neuronales artificiales de manera eficiente. En particular, <code>TensorFlow</code> incluye una clase llamada <code>tf.keras.Sequential</code> que permite definir la arquitectura de la red neuronal artificial.</p>
<section id="uso-básico-de-tensorflow" class="level3">
<h3 class="anchored" data-anchor-id="uso-básico-de-tensorflow">Uso básico de TensorFlow</h3>
<p>Para utilizar <code>TensorFlow</code>, primero debemos instalar la librería.</p>
<div class="sourceCode" id="cb56"><pre class="sourceCode numberSource {bash} number-lines code-with-copy"><code class="sourceCode"><span id="cb56-1"><a href="#cb56-1"></a>!pip install tensorflow</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><code>Tensorflow</code> se basa igualmente en el uso de tensores para realizar operaciones matemáticas.</p>
<div id="26f250b8" class="cell" data-execution_count="30">
<details open="" class="code-fold">
<summary>Código</summary>
<div class="sourceCode cell-code" id="cb57"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb57-1"><a href="#cb57-1"></a><span class="im">import</span> tensorflow <span class="im">as</span> tf</span>
<span id="cb57-2"><a href="#cb57-2"></a></span>
<span id="cb57-3"><a href="#cb57-3"></a><span class="co"># Crear un tensor de ceros</span></span>
<span id="cb57-4"><a href="#cb57-4"></a>x <span class="op">=</span> tf.zeros((<span class="dv">2</span>, <span class="dv">3</span>))</span>
<span id="cb57-5"><a href="#cb57-5"></a></span>
<span id="cb57-6"><a href="#cb57-6"></a><span class="bu">print</span>(x)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>tf.Tensor(
[[0. 0. 0.]
 [0. 0. 0.]], shape=(2, 3), dtype=float32)</code></pre>
</div>
</div>
<p>Podemos realizar operaciones matemáticas con tensores en <code>TensorFlow</code>.</p>
<div id="a3e10dd2" class="cell" data-execution_count="31">
<details open="" class="code-fold">
<summary>Código</summary>
<div class="sourceCode cell-code" id="cb59"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb59-1"><a href="#cb59-1"></a><span class="co"># Crear dos tensores</span></span>
<span id="cb59-2"><a href="#cb59-2"></a>x <span class="op">=</span> tf.constant([[<span class="dv">1</span>, <span class="dv">2</span>], [<span class="dv">3</span>, <span class="dv">4</span>]], dtype<span class="op">=</span>tf.float32)</span>
<span id="cb59-3"><a href="#cb59-3"></a>y <span class="op">=</span> tf.constant([[<span class="dv">5</span>, <span class="dv">6</span>], [<span class="dv">7</span>, <span class="dv">8</span>]], dtype<span class="op">=</span>tf.float32)</span>
<span id="cb59-4"><a href="#cb59-4"></a></span>
<span id="cb59-5"><a href="#cb59-5"></a><span class="co"># Sumar los tensores</span></span>
<span id="cb59-6"><a href="#cb59-6"></a>z <span class="op">=</span> x <span class="op">+</span> y</span>
<span id="cb59-7"><a href="#cb59-7"></a></span>
<span id="cb59-8"><a href="#cb59-8"></a><span class="bu">print</span>(z)</span>
<span id="cb59-9"><a href="#cb59-9"></a></span>
<span id="cb59-10"><a href="#cb59-10"></a><span class="co"># Multiplicar los tensores</span></span>
<span id="cb59-11"><a href="#cb59-11"></a>z <span class="op">=</span> x <span class="op">*</span> y</span>
<span id="cb59-12"><a href="#cb59-12"></a></span>
<span id="cb59-13"><a href="#cb59-13"></a><span class="bu">print</span>(z)</span>
<span id="cb59-14"><a href="#cb59-14"></a></span>
<span id="cb59-15"><a href="#cb59-15"></a><span class="co"># Multiplicar un tensor por un escalar</span></span>
<span id="cb59-16"><a href="#cb59-16"></a>z <span class="op">=</span> <span class="dv">2</span> <span class="op">*</span> x</span>
<span id="cb59-17"><a href="#cb59-17"></a></span>
<span id="cb59-18"><a href="#cb59-18"></a><span class="bu">print</span>(z)</span>
<span id="cb59-19"><a href="#cb59-19"></a></span>
<span id="cb59-20"><a href="#cb59-20"></a><span class="co"># Calcular la transpuesta de un tensor</span></span>
<span id="cb59-21"><a href="#cb59-21"></a>z <span class="op">=</span> tf.transpose(x)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>tf.Tensor(
[[ 6.  8.]
 [10. 12.]], shape=(2, 2), dtype=float32)
tf.Tensor(
[[ 5. 12.]
 [21. 32.]], shape=(2, 2), dtype=float32)
tf.Tensor(
[[2. 4.]
 [6. 8.]], shape=(2, 2), dtype=float32)</code></pre>
</div>
</div>
<p>Todo las operaciones que se pueden realizar en <code>PyTorch</code> se pueden realizar en <code>TensorFlow</code>.</p>
</section>
<section id="estructura-de-una-red-neuronal-artificial-en-tensorflow" class="level3">
<h3 class="anchored" data-anchor-id="estructura-de-una-red-neuronal-artificial-en-tensorflow">Estructura de una red neuronal artificial en TensorFlow</h3>
<p>Veamos las distintas partes de una red neuronal artificial en <code>TensorFlow</code>.</p>
<section id="ejemplo-de-clasificación-2" class="level4">
<h4 class="anchored" data-anchor-id="ejemplo-de-clasificación-2">Ejemplo de clasificación</h4>
<p>En este ejemplo, vamos a utilizar la base de datos <code>iris</code> para entrenar una red neuronal artificial que permita clasificar las flores en tres categorías: <code>setosa</code>, <code>versicolor</code> y <code>virginica</code>.</p>
<div id="8cfc0efa" class="cell" data-execution_count="32">
<details open="" class="code-fold">
<summary>Código</summary>
<div class="sourceCode cell-code" id="cb61"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb61-1"><a href="#cb61-1"></a><span class="im">import</span> tensorflow <span class="im">as</span> tf</span>
<span id="cb61-2"><a href="#cb61-2"></a></span>
<span id="cb61-3"><a href="#cb61-3"></a><span class="co"># Crear la red neuronal artificial</span></span>
<span id="cb61-4"><a href="#cb61-4"></a>model <span class="op">=</span> tf.keras.Sequential([</span>
<span id="cb61-5"><a href="#cb61-5"></a>    tf.keras.Input(shape<span class="op">=</span>(<span class="dv">4</span>,)),</span>
<span id="cb61-6"><a href="#cb61-6"></a>    tf.keras.layers.Dense(<span class="dv">10</span>, activation<span class="op">=</span><span class="st">'relu'</span>),</span>
<span id="cb61-7"><a href="#cb61-7"></a>    tf.keras.layers.Dense(<span class="dv">10</span>, activation<span class="op">=</span><span class="st">'relu'</span>),</span>
<span id="cb61-8"><a href="#cb61-8"></a>    tf.keras.layers.Dense(<span class="dv">3</span>, activation<span class="op">=</span><span class="st">'softmax'</span>)</span>
<span id="cb61-9"><a href="#cb61-9"></a>])</span>
<span id="cb61-10"><a href="#cb61-10"></a></span>
<span id="cb61-11"><a href="#cb61-11"></a>model.summary()</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<pre style="white-space:pre;overflow-x:auto;line-height:normal;font-family:Menlo,'DejaVu Sans Mono',consolas,'Courier New',monospace"><span style="font-weight: bold">Model: "sequential_7"</span>
</pre>
</div>
<div class="cell-output cell-output-display">
<pre style="white-space:pre;overflow-x:auto;line-height:normal;font-family:Menlo,'DejaVu Sans Mono',consolas,'Courier New',monospace">┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━┓
┃<span style="font-weight: bold"> Layer (type)                    </span>┃<span style="font-weight: bold"> Output Shape           </span>┃<span style="font-weight: bold">       Param # </span>┃
┡━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━┩
│ dense_21 (<span style="color: #0087ff; text-decoration-color: #0087ff">Dense</span>)                │ (<span style="color: #00d7ff; text-decoration-color: #00d7ff">None</span>, <span style="color: #00af00; text-decoration-color: #00af00">10</span>)             │            <span style="color: #00af00; text-decoration-color: #00af00">50</span> │
├─────────────────────────────────┼────────────────────────┼───────────────┤
│ dense_22 (<span style="color: #0087ff; text-decoration-color: #0087ff">Dense</span>)                │ (<span style="color: #00d7ff; text-decoration-color: #00d7ff">None</span>, <span style="color: #00af00; text-decoration-color: #00af00">10</span>)             │           <span style="color: #00af00; text-decoration-color: #00af00">110</span> │
├─────────────────────────────────┼────────────────────────┼───────────────┤
│ dense_23 (<span style="color: #0087ff; text-decoration-color: #0087ff">Dense</span>)                │ (<span style="color: #00d7ff; text-decoration-color: #00d7ff">None</span>, <span style="color: #00af00; text-decoration-color: #00af00">3</span>)              │            <span style="color: #00af00; text-decoration-color: #00af00">33</span> │
└─────────────────────────────────┴────────────────────────┴───────────────┘
</pre>
</div>
<div class="cell-output cell-output-display">
<pre style="white-space:pre;overflow-x:auto;line-height:normal;font-family:Menlo,'DejaVu Sans Mono',consolas,'Courier New',monospace"><span style="font-weight: bold"> Total params: </span><span style="color: #00af00; text-decoration-color: #00af00">193</span> (772.00 B)
</pre>
</div>
<div class="cell-output cell-output-display">
<pre style="white-space:pre;overflow-x:auto;line-height:normal;font-family:Menlo,'DejaVu Sans Mono',consolas,'Courier New',monospace"><span style="font-weight: bold"> Trainable params: </span><span style="color: #00af00; text-decoration-color: #00af00">193</span> (772.00 B)
</pre>
</div>
<div class="cell-output cell-output-display">
<pre style="white-space:pre;overflow-x:auto;line-height:normal;font-family:Menlo,'DejaVu Sans Mono',consolas,'Courier New',monospace"><span style="font-weight: bold"> Non-trainable params: </span><span style="color: #00af00; text-decoration-color: #00af00">0</span> (0.00 B)
</pre>
</div>
</div>
<p>Con <code>TensorFlow</code> se puede definir la red neuronal de manera más sencilla que con <code>PyTorch</code>. En este caso, utilizamos la clase <code>tf.keras.Sequential</code> para definir la arquitectura de la red neuronal artificial. La clase <code>tf.keras.layers.Dense</code> representa una capa de neuronas completamente conectada. En este caso, definimos tres capas de neuronas con 10, 10 y 3 neuronas respectivamente. La función <code>tf.keras.Input</code> define la capa de entrada de la red neuronal.</p>
<p>Vamos a entrenar la red neuronal.</p>
<div id="7e42a860" class="cell" data-execution_count="33">
<details open="" class="code-fold">
<summary>Código</summary>
<div class="sourceCode cell-code" id="cb62"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb62-1"><a href="#cb62-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb62-2"><a href="#cb62-2"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb62-3"><a href="#cb62-3"></a><span class="im">from</span> sklearn.datasets <span class="im">import</span> load_iris</span>
<span id="cb62-4"><a href="#cb62-4"></a><span class="im">from</span> sklearn.model_selection <span class="im">import</span> train_test_split</span>
<span id="cb62-5"><a href="#cb62-5"></a></span>
<span id="cb62-6"><a href="#cb62-6"></a><span class="co"># Cargar la base de datos iris</span></span>
<span id="cb62-7"><a href="#cb62-7"></a>iris <span class="op">=</span> load_iris()</span>
<span id="cb62-8"><a href="#cb62-8"></a>X <span class="op">=</span> iris.data</span>
<span id="cb62-9"><a href="#cb62-9"></a>y <span class="op">=</span> iris.target</span>
<span id="cb62-10"><a href="#cb62-10"></a></span>
<span id="cb62-11"><a href="#cb62-11"></a><span class="co"># Dividir la base de datos en entrenamiento y prueba</span></span>
<span id="cb62-12"><a href="#cb62-12"></a>X_train, X_test, y_train, y_test <span class="op">=</span> train_test_split(X, y, test_size<span class="op">=</span><span class="fl">0.2</span>, random_state<span class="op">=</span><span class="dv">1014</span>)</span>
<span id="cb62-13"><a href="#cb62-13"></a></span>
<span id="cb62-14"><a href="#cb62-14"></a><span class="co"># Convertir los datos a tensores de TensorFlow</span></span>
<span id="cb62-15"><a href="#cb62-15"></a>X_train <span class="op">=</span> tf.constant(X_train, dtype<span class="op">=</span>tf.float32)</span>
<span id="cb62-16"><a href="#cb62-16"></a>X_test <span class="op">=</span> tf.constant(X_test, dtype<span class="op">=</span>tf.float32)</span>
<span id="cb62-17"><a href="#cb62-17"></a></span>
<span id="cb62-18"><a href="#cb62-18"></a>y_train <span class="op">=</span> tf.constant(y_train, dtype<span class="op">=</span>tf.int64)</span>
<span id="cb62-19"><a href="#cb62-19"></a>y_test <span class="op">=</span> tf.constant(y_test, dtype<span class="op">=</span>tf.int64)</span>
<span id="cb62-20"><a href="#cb62-20"></a></span>
<span id="cb62-21"><a href="#cb62-21"></a><span class="bu">print</span>(X_train.shape)</span>
<span id="cb62-22"><a href="#cb62-22"></a><span class="bu">print</span>(X_test.shape)</span>
<span id="cb62-23"><a href="#cb62-23"></a></span>
<span id="cb62-24"><a href="#cb62-24"></a><span class="bu">print</span>(y_train.shape)</span>
<span id="cb62-25"><a href="#cb62-25"></a><span class="bu">print</span>(y_test.shape)</span>
<span id="cb62-26"><a href="#cb62-26"></a></span>
<span id="cb62-27"><a href="#cb62-27"></a><span class="co"># Compilar la red neuronal</span></span>
<span id="cb62-28"><a href="#cb62-28"></a>model.<span class="bu">compile</span>(optimizer<span class="op">=</span><span class="st">'sgd'</span>, loss<span class="op">=</span><span class="st">'sparse_categorical_crossentropy'</span>, metrics<span class="op">=</span>[<span class="st">'accuracy'</span>])</span>
<span id="cb62-29"><a href="#cb62-29"></a></span>
<span id="cb62-30"><a href="#cb62-30"></a><span class="co"># Entrenar la red neuronal</span></span>
<span id="cb62-31"><a href="#cb62-31"></a>model.fit(X_train, y_train, epochs<span class="op">=</span><span class="dv">1000</span>, verbose<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb62-32"><a href="#cb62-32"></a></span>
<span id="cb62-33"><a href="#cb62-33"></a><span class="co"># Evaluar la red neuronal</span></span>
<span id="cb62-34"><a href="#cb62-34"></a>loss, accuracy <span class="op">=</span> model.evaluate(X_test, y_test)</span>
<span id="cb62-35"><a href="#cb62-35"></a></span>
<span id="cb62-36"><a href="#cb62-36"></a><span class="bu">print</span>(<span class="ss">f"Loss: </span><span class="sc">{</span>loss<span class="sc">}</span><span class="ss">, Accuracy: </span><span class="sc">{</span>accuracy<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>(120, 4)
(30, 4)
(120,)
(30,)
1/1 ━━━━━━━━━━━━━━━━━━━━ 0s 98ms/step - accuracy: 1.0000 - loss: 0.03731/1 ━━━━━━━━━━━━━━━━━━━━ 0s 100ms/step - accuracy: 1.0000 - loss: 0.0373
Loss: 0.03730132058262825, Accuracy: 1.0</code></pre>
</div>
</div>
<p>Con el método <code>compile</code> se compila la red neuronal con un optimizador, una función de pérdida y métricas de evaluación. En este caso, utilizamos el optimizador <code>sgd</code> (descenso de gradiente estocástico), la función de pérdida <code>sparse_categorical_crossentropy</code> y la métrica <code>accuracy</code> para evaluar la precisión de la red neuronal.</p>
<p>Con el método <code>fit</code> se entrena la red neuronal con los datos de entrenamiento. En este caso, utilizamos 1000 épocas de entrenamiento. El argumento <code>verbose=0</code> indica que no se mostrará información sobre el entrenamiento, para mostrar la información se puede cambiar a <code>verbose=1</code>.</p>
<p>Con el método <code>evaluate</code> se evalúa la red neuronal con los datos de prueba. El método <code>evaluate</code> devuelve la pérdida y la precisión de la red neuronal en los datos de prueba.</p>
<p>Podemos obtener las predicciones de la red neuronal para la base de datos de prueba.</p>
<div id="25e9d1d4" class="cell" data-execution_count="34">
<details open="" class="code-fold">
<summary>Código</summary>
<div class="sourceCode cell-code" id="cb64"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb64-1"><a href="#cb64-1"></a>y_pred <span class="op">=</span> model.predict(X_test)</span>
<span id="cb64-2"><a href="#cb64-2"></a></span>
<span id="cb64-3"><a href="#cb64-3"></a><span class="bu">print</span>(y_pred)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>1/1 ━━━━━━━━━━━━━━━━━━━━ 0s 34ms/step1/1 ━━━━━━━━━━━━━━━━━━━━ 0s 35ms/step
[[9.3780188e-03 9.9053556e-01 8.6380802e-05]
 [2.6691245e-05 6.1251414e-01 3.8745919e-01]
 [2.8749557e-07 5.9596896e-02 9.4040269e-01]
 [9.9821705e-01 1.7829464e-03 7.0882692e-12]
 [3.1476901e-04 9.9696678e-01 2.7184207e-03]
 [9.9806172e-01 1.9382917e-03 4.5069222e-12]
 [4.7594633e-05 9.9566221e-01 4.2900806e-03]
 [9.9946874e-01 5.3111481e-04 5.8261650e-14]
 [7.6720468e-04 9.9874258e-01 4.9011409e-04]
 [4.5947208e-06 3.0641466e-01 6.9358081e-01]
 [9.9916506e-01 8.3498686e-04 3.6297191e-13]
 [6.1792984e-05 9.9003565e-01 9.9024186e-03]
 [9.9943411e-01 5.6587165e-04 6.9331653e-14]
 [1.2681982e-04 9.9869889e-01 1.1743259e-03]
 [1.3101969e-07 6.3623767e-03 9.9363756e-01]
 [1.1187630e-03 9.9319637e-01 5.6849075e-03]
 [9.9854863e-01 1.4513362e-03 3.3198364e-12]
 [9.9968213e-01 3.1789864e-04 6.2396470e-15]
 [2.2063234e-04 9.5556730e-01 4.4211969e-02]
 [2.8410594e-03 9.9692291e-01 2.3596971e-04]
 [2.3421185e-08 3.8140393e-03 9.9618596e-01]
 [2.8064492e-04 9.9876738e-01 9.5207797e-04]
 [2.1451027e-10 4.6397839e-04 9.9953604e-01]
 [3.4913389e-04 9.9937332e-01 2.7746896e-04]
 [9.9886537e-01 1.1346943e-03 1.2733420e-12]
 [3.7266931e-04 9.9817073e-01 1.4565402e-03]
 [1.1772375e-04 9.2994481e-01 6.9937520e-02]
 [9.9625766e-01 3.7422990e-03 1.7923980e-10]
 [2.0222605e-04 9.8535591e-01 1.4441739e-02]
 [1.8129933e-09 2.6365283e-03 9.9736351e-01]]</code></pre>
</div>
</div>
<p>Para obtener la clase predicha, podemos usar la función <code>argmax</code> de <code>NumPy</code>.</p>
<div id="075b16a7" class="cell" data-execution_count="35">
<details open="" class="code-fold">
<summary>Código</summary>
<div class="sourceCode cell-code" id="cb66"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb66-1"><a href="#cb66-1"></a>y_pred <span class="op">=</span> np.argmax(y_pred, axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb66-2"><a href="#cb66-2"></a></span>
<span id="cb66-3"><a href="#cb66-3"></a><span class="bu">print</span>(y_pred)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>[1 1 2 0 1 0 1 0 1 2 0 1 0 1 2 1 0 0 1 1 2 1 2 1 0 1 1 0 1 2]</code></pre>
</div>
</div>
<p>Podemos visualizar la matriz de confusión.</p>
<div id="7b28e3c1" class="cell" data-execution_count="36">
<details open="" class="code-fold">
<summary>Código</summary>
<div class="sourceCode cell-code" id="cb68"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb68-1"><a href="#cb68-1"></a><span class="im">from</span> sklearn.metrics <span class="im">import</span> confusion_matrix</span>
<span id="cb68-2"><a href="#cb68-2"></a><span class="im">import</span> seaborn <span class="im">as</span> sns</span>
<span id="cb68-3"><a href="#cb68-3"></a></span>
<span id="cb68-4"><a href="#cb68-4"></a>cm <span class="op">=</span> confusion_matrix(y_test, y_pred)</span>
<span id="cb68-5"><a href="#cb68-5"></a></span>
<span id="cb68-6"><a href="#cb68-6"></a>sns.heatmap(cm, annot<span class="op">=</span><span class="va">True</span>, fmt<span class="op">=</span><span class="st">'d'</span>, </span>
<span id="cb68-7"><a href="#cb68-7"></a>            xticklabels<span class="op">=</span>iris.target_names, </span>
<span id="cb68-8"><a href="#cb68-8"></a>            yticklabels<span class="op">=</span>iris.target_names,</span>
<span id="cb68-9"><a href="#cb68-9"></a>            cmap<span class="op">=</span><span class="st">'Blues'</span>)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="ann_python_files/figure-html/cell-37-output-1.png" width="529" height="411" class="figure-img"></p>
</figure>
</div>
</div>
</div>
</section>
</section>
</section>
<section id="salvando-y-cargando-modelos" class="level1">
<h1>Salvando y cargando modelos</h1>
<p>En <code>PyTorch</code> se pueden guardar y cargar modelos utilizando el método <code>save</code> y <code>load</code>.</p>
<div id="fc5a5985" class="cell" data-execution_count="37">
<details open="" class="code-fold">
<summary>Código</summary>
<div class="sourceCode cell-code" id="cb69"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb69-1"><a href="#cb69-1"></a><span class="co"># Guardar el modelo</span></span>
<span id="cb69-2"><a href="#cb69-2"></a><span class="co">#torch.save(model.state_dict(), 'model.pth')</span></span>
<span id="cb69-3"><a href="#cb69-3"></a></span>
<span id="cb69-4"><a href="#cb69-4"></a><span class="co"># Cargar el modelo</span></span>
<span id="cb69-5"><a href="#cb69-5"></a><span class="co">#model.load_state_dict(torch.load('model.pth'))</span></span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>En <code>TensorFlow</code> se pueden guardar y cargar modelos utilizando el método <code>save</code> y <code>load</code>.</p>
<div id="daebf239" class="cell" data-execution_count="38">
<details open="" class="code-fold">
<summary>Código</summary>
<div class="sourceCode cell-code" id="cb70"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb70-1"><a href="#cb70-1"></a><span class="co"># Guardar el modelo</span></span>
<span id="cb70-2"><a href="#cb70-2"></a>model.save(<span class="st">'model.keras'</span>)</span>
<span id="cb70-3"><a href="#cb70-3"></a></span>
<span id="cb70-4"><a href="#cb70-4"></a><span class="co"># Cargar el modelo</span></span>
<span id="cb70-5"><a href="#cb70-5"></a><span class="co">#model = keras.models.load_model('path/to/location.keras')</span></span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Esto sirve para guardar el modelo y poder utilizarlo en otro momento sin tener que volver a entrenarlo.</p>
</section>
<section id="conclusiones" class="level1">
<h1>Conclusiones</h1>
<p>En este tutorial, hemos visto cómo implementar redes neuronales artificiales en Python utilizando las librerías <code>scikit-learn</code>, <code>PyTorch</code> y <code>TensorFlow</code>. Hemos visto cómo cargar una base de datos, dividirla en entrenamiento y prueba, definir la arquitectura de la red neuronal, entrenar la red neuronal, evaluar la red neuronal y visualizar la matriz de confusión. También hemos visto cómo normalizar los datos y ajustar los hiperparámetros de la red neuronal para mejorar el rendimiento del modelo.</p>


</section>

<a onclick="window.scrollTo(0, 0); return false;" role="button" id="quarto-back-to-top"><i class="bi bi-arrow-up"></i> Volver arriba</a></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
    const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
    const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
    let newTheme = '';
    if(darkModeDefault) {
      newTheme = isAlternate ? baseTheme : alternateTheme;
    } else {
      newTheme = isAlternate ? alternateTheme : baseTheme;
    }
    const changeGiscusTheme = () => {
      // From: https://github.com/giscus/giscus/issues/336
      const sendMessage = (message) => {
        const iframe = document.querySelector('iframe.giscus-frame');
        if (!iframe) return;
        iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
      }
      sendMessage({
        setConfig: {
          theme: newTheme
        }
      });
    }
    const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
    if (isGiscussLoaded) {
      changeGiscusTheme();
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  const darkModeDefault = false;
  let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
    toggleGiscusIfUsed(toAlternate, darkModeDefault);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copiado");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copiado");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
  const viewSource = window.document.getElementById('quarto-view-source') ||
                     window.document.getElementById('quarto-code-tools-source');
  if (viewSource) {
    const sourceUrl = viewSource.getAttribute("data-quarto-source-url");
    viewSource.addEventListener("click", function(e) {
      if (sourceUrl) {
        // rstudio viewer pane
        if (/\bcapabilities=\b/.test(window.location)) {
          window.open(sourceUrl);
        } else {
          window.location.href = sourceUrl;
        }
      } else {
        const modal = new bootstrap.Modal(document.getElementById('quarto-embedded-source-code-modal'));
        modal.show();
      }
      return false;
    });
  }
  function toggleCodeHandler(show) {
    return function(e) {
      const detailsSrc = window.document.querySelectorAll(".cell > details > .sourceCode");
      for (let i=0; i<detailsSrc.length; i++) {
        const details = detailsSrc[i].parentElement;
        if (show) {
          details.open = true;
        } else {
          details.removeAttribute("open");
        }
      }
      const cellCodeDivs = window.document.querySelectorAll(".cell > .sourceCode");
      const fromCls = show ? "hidden" : "unhidden";
      const toCls = show ? "unhidden" : "hidden";
      for (let i=0; i<cellCodeDivs.length; i++) {
        const codeDiv = cellCodeDivs[i];
        if (codeDiv.classList.contains(fromCls)) {
          codeDiv.classList.remove(fromCls);
          codeDiv.classList.add(toCls);
        } 
      }
      return false;
    }
  }
  const hideAllCode = window.document.getElementById("quarto-hide-all-code");
  if (hideAllCode) {
    hideAllCode.addEventListener("click", toggleCodeHandler(false));
  }
  const showAllCode = window.document.getElementById("quarto-show-all-code");
  if (showAllCode) {
    showAllCode.addEventListener("click", toggleCodeHandler(true));
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/christian-f-badillo\.github\.io\/Ciencia-de-datos-con-Python-de-estadistica-descriptiva-a-redes-neuronales\/");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
          // default icon
          link.classList.add("external");
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="../neural_neworks/neural_networks.html" class="pagination-link" aria-label="Introducción a Redes Neuronales">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text">Introducción a Redes Neuronales</span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
  </div>
</nav>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<p>Copyright <i class="fa-brands fa-creative-commons" aria-label="creative-commons"></i> 2024 por Christian Francisco Badillo Hernández <br> Contenido con licencia <i class="fa-brands fa-creative-commons" aria-label="creative-commons"></i> <i class="fa-brands fa-creative-commons-by" aria-label="creative-commons-by"></i> <i class="fa-brands fa-creative-commons-nc" aria-label="creative-commons-nc"></i> <a href="https://creativecommons.org/licenses/by-nc/4.0/">Creative Commons Attribution-NonCommercial 4.0 International license (CC BY-NC 4.0)</a></p>
</div>   
    <div class="nav-footer-center">
<p>Proyecto Apoyado por el Proyecto PAPIME PE309624</p>
<div class="toc-actions d-sm-block d-md-none"><ul><li><a href="https://github.com/Christian-F-Badillo/Ciencia-de-datos-con-Python-de-estadistica-descriptiva-a-redes-neuronales/edit/main/neural_neworks/ann_python.qmd" class="toc-action"><i class="bi bi-github"></i>Editar esta página</a></li><li><a href="https://github.com/Christian-F-Badillo/Ciencia-de-datos-con-Python-de-estadistica-descriptiva-a-redes-neuronales/issues/new" class="toc-action"><i class="bi empty"></i>Informar de un problema</a></li></ul></div><div class="cookie-consent-footer"><a href="#" id="open_preferences_center">Preferencias para Cookies</a></div></div>
    <div class="nav-footer-right">
<p>Hecho con <a href="https://www.python.org/"><i class="fa-brands fa-python" aria-label="python"></i></a> y <a href="https://quarto.org">Quarto</a> <br> Código fuente disponible en <a href="https://github.com/Christian-F-Badillo/Ciencia-de-datos-con-Python-de-estadistica-descriptiva-a-redes-neuronales">GitHub</a></p>
</div>
  </div>
</footer>




</body></html>