---
title: "Funciones y Bucles de Control"
author: "Christian Badillo"
format: html
date: today
order: 3
jupyter: python3
ipynb-shell-interactivity: all
filters:
  - pyodide
  - fontawesome
  - iconify
---

# Funciones

Las ***funciones*** son bloques de código que se pueden reutilizar en diferentes partes de un programa, permitiendo que el código sea más modular y fácil de mantener. En Python, las funciones se definen con la palabra clave `def`, seguida del nombre de la función y una lista de parámetros entre paréntesis. El cuerpo de la función se define con sangría y puede contener cualquier número de instrucciones.

Primero elaboremos una función sencilla, la cual se llamará `saludo` y recibirá un parámetro `nombre`:

```{python}
def saludo(nombre):
    print(f'Hola, {nombre}!')

saludo('Christian')
```

Hemos usado una **f-string** para imprimir el saludo. Las f-strings son una forma de formatear cadenas de texto en Python, permitiendo la interpolación de variables dentro de una cadena. Para definir una f-string, se coloca una `f` antes de las comillas de apertura y se encierra la variable entre llaves `{}`. Es decir, le estamos diciendo a Python que reemplace `{nombre}` con el valor de la variable `nombre` que en este caso es `'Christian'`.

Las funciones pueden devolver un valor usando la palabra clave `return`. Por ejemplo, la siguiente función `cuadrado` recibe un número `x` y devuelve su cuadrado:

```{python}
def cuadrado(x):
    return x ** 2

print(cuadrado(5))
```

Como habrás notado en los ejemplos anteriores, hemos usado el nombre de la función seguido de paréntesis para llamarla. En el caso de la función `saludo`, hemos pasado un argumento `nombre` entre los paréntesis. En el caso de la función `cuadrado`, hemos pasado el número `5`. Estos argumentos se llaman ***parámetros*** y son los valores que la función espera recibir para realizar su tarea.

Hay varias formas de poner los argumentos en una función:

- **Argumentos posicionales**: Los argumentos se pasan en el orden en que se definen en la función.
- **Argumentos con nombre**: Los argumentos se pasan con el nombre del parámetro al que corresponden.
- **Argumentos por defecto**: Los argumentos tienen un valor por defecto que se usa si no se proporciona un valor.
- **Argumentos variables**: Los argumentos se pasan como una lista o un diccionario.

En los ejemplos hemos utilizado argumentos posicionales. A continuación, veremos cómo usar argumentos con nombre:

```{python}
def resta(num1, num2):
    return num1 - num2

print(resta(num1=10, num2=5))
```

En este caso, hemos pasado los argumentos `num1` y `num2` con sus nombres correspondientes y les hemos asignado valores. Esto nos permite pasar los argumentos en cualquier orden, siempre y cuando especifiquemos el nombre del parámetro al que corresponden.

Ahora veamos cómo usar argumentos por defecto:

```{python}
def potencia(base, exponente=2):
    return base ** exponente

print(potencia(2))
print(potencia(2, 3))
```

En este caso, la función `potencia` tiene un argumento `exponente` con un valor por defecto de `2`. Si no se proporciona un valor para `exponente`, se usará el valor por defecto. Si se proporciona un valor, se usará ese valor en su lugar.

## Funciones Lambda

Las funciones lambda son funciones anónimas que se pueden definir en una sola línea. Se definen con la palabra clave `lambda`, seguida de una lista de parámetros y una expresión que se evalúa y devuelve el resultado. Por ejemplo, la siguiente función lambda calcula el cuadrado de un número:

```{python}
cuadrado_lamda = lambda x: x ** 2

print(cuadrado_lamda(5))
```

Las funciones lambda son útiles cuando se necesita una función simple y no es necesario definirla con una declaración `def`. 

Ahora definamos una función lambda un poco más compleja para sumar dos números:

```{python}
suma_lambda = lambda x, y: x + y

print(suma_lambda(3, 4))
```

## Creando funciones legibles

Es importante que las funciones sean fáciles de leer y entender. Para ello, es recomendable seguir las siguientes buenas prácticas:

- **Nombres descriptivos**: Usa nombres descriptivos para las funciones y los parámetros.
- **Comentarios**: Añade comentarios para explicar lo que hace cada parte de la función.
- **Documentación**: Usa [docstrings](https://peps.python.org/pep-0257/) para documentar la función y proporcionar información sobre su propósito, los parámetros que espera y el valor que devuelve.
- **Dividir en funciones más pequeñas**: Si una función es demasiado larga o hace demasiadas cosas, divídela en funciones más pequeñas que realicen tareas específicas.

Veamos un ejemplo de una función bien documentada y legible:

```{pyodide-python}
import numpy as np
import matplotlib.pyplot as plt

def sine_wave(amplitude: float = None, frequency: float = None, phase: float = None, duration: float = None, sample_rate: float = None):
    """
    Generate a sine wave signal.

    Parameters:
    - amplitude: The amplitude of the sine wave.
    - frequency: The frequency of the sine wave in Hz.
    - phase: The phase of the sine wave in radians.
    - duration: The duration of the signal in seconds.
    - sample_rate: The sample rate of the signal in Hz.

    Returns:
    - t: An array of time values.
    - x: An array of signal values.
    """
    t = np.linspace(0, duration, int(sample_rate * duration), endpoint=False) # Generate time values
    x = amplitude * np.sin(2 * np.pi * frequency * t + phase) # Generate signal values
    return t, x

# Generate a sine wave signal with amplitude 1, frequency 1 Hz, phase 0, duration 1 second, and sample rate 1000 Hz
t, x = sine_wave(amplitude=1, frequency=1, phase=0, duration=1, sample_rate=1000) 

# Plot the sine wave signal
def plot_signal(t, x):
    plt.figure() # Create a new figure
    plt.plot(t, x) # Plot the signal
    plt.xlabel('Time (s)') # Set the x-axis label
    plt.ylabel('Amplitude') # Set the y-axis label
    plt.grid(True) # Show grid
    plt.show() # Show the plot

plot_signal(t, x)
```

En este ejemplo, hemos definido una función `sine_wave` que genera una señal de onda sinusoidal con los parámetros de amplitud, frecuencia, fase, duración y tasa de muestreo especificados. Hemos documentado la función con un docstring que explica los parámetros que espera y el valor que devuelve. También hemos definido una función `plot_signal` que traza la señal generada. Esta función es más legible y fácil de entender gracias a los comentarios y la documentación.
